<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>éŸ³ç¬¦å°„æ‰‹ å…ƒç¥–BanG Dream</title>
  <style>
    :root {
      --primary-color: #ff69b4; /* Hot Pink */
      --secondary-color: #9370db; /* Medium Purple */
      --text-color: #ffffff;
      --shadow-color: rgba(0, 0, 0, 0.5);
    }

    body {
      margin: 0;
      padding: 0;
      background-color: #333;
      color: var(--text-color);
      font-family: "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100dvh;
      overflow: hidden;
    }

    #game-container {
      position: relative;
      background-color: #6c757d;

      /* ä¿æŒ 9:16 æ¯”ä¾‹ï¼Œæœ€å¤§åŒ–é“ºæ»¡ */
      width: 100vw;
      height: 100dvh;
      aspect-ratio: 9 / 16;

      /* é™åˆ¶ç¼©æ”¾ï¼Œä¿è¯ä¸ä¼šè¶…å‡ºå±å¹• */
      max-width: 500px;
      max-height: 100dvh;

      /* å±…ä¸­æ˜¾ç¤ºï¼Œè¶…å‡ºéƒ¨åˆ†è‡ªåŠ¨è£åˆ‡ */
      object-fit: contain;
      overflow: hidden;

      box-shadow: 0 0 20px var(--shadow-color);
    }

    #game-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #707070; /* Road color */
    }

    .start-adjust {
      justify-content: flex-start !important;
    }

    .game-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background-color: rgba(0, 0, 0, 0.3);
      text-align: center;
      z-index: 10;
      transition: opacity 0.5s ease;
      padding-top: 0;
    }

    .game-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .overlay-title {
      margin: 15px 0px;
      font-size: 2rem;
      font-weight: bold;
      text-shadow: 0 0 10px var(--primary-color), 0 0 20px var(--primary-color);
      animation: pulse 1.5s infinite;
      @media (max-width: 500px) {
        font-size: 1.8rem;
      }
      @media (max-width: 375px) {
        font-size: 1.6rem;
        margin: 10px 0px;
      }
    }

    .result-text,
    .overlay-text {
      font-size: 22px;
      font-weight: 600; /* ç¨å¾®åŠ ç²— */
      color: #ffffff; /* ç™½è‰² */
      text-shadow: -2px -2px 0 #000,
      2px -2px 0 #000,
      -2px 2px 0 #000,
      2px 2px 0 #000,
      0 0 10px rgba(255, 105, 180, 0.8);
      /*text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5), 0 0 6px rgba(255, 105, 180, 0.6);  é˜´å½± + ç²‰è‰²å…‰æ™• */
      margin: 10px 0;
      line-height: 1.5;
      @media (max-width: 450px) {
        font-size: 18px;
        margin: 8px 0;
      }
    }

    .result-text {
      font-size: 28px;
      line-height: 1.8;
      margin: 0;
      @media (max-width: 450px) {
        font-size: 22px;
      }
    }

    .end-button,
    .start-button {
      padding: 10px 20px;
      font-size: 1.3rem;
      font-weight: bold;
      color: var(--secondary-color);
      background-color: var(--text-color);
      border: none;
      border-radius: 20px;
      cursor: pointer;
      box-shadow: 0 5px 15px var(--shadow-color);
      transition: transform 0.2s, box-shadow 0.2s;
      @media (max-width: 400px) {
        padding: 8px 16px;
        font-size: 1.2rem;
      }
    }

    .end-button:hover,
    .start-button:hover {
      transform: scale(1.1);
      box-shadow: 0 8px 25px var(--shadow-color);
    }

    .end-button {
      margin: 15px 0px;
      @media (max-width: 400px) {
        margin: 12px 0px;
      }
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.05);
      }
      100% {
        transform: scale(1);
      }
    }

    .difficulty-selector,
    .language-selector {
      display: flex;
      gap: 10px;
      margin: 10px 0;
      transition: opacity 0.3s ease;
      @media (max-width: 450px) {
        margin: 5px 0;
      }
    }

    .difficulty-selector.hidden,
    .language-selector.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .contact-btn,
    .difficulty-btn,
    .lang-btn {
      padding: 8px 12px;
      font-size: 16px;
      color: var(--text-color);
      background-color: rgba(0, 0, 0, 0.5);
      border: 2px solid transparent;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.2s;
      @media (max-width: 450px) {
        padding: 4px 8px;
        font-size: 14px;
      }
    }

    .contact-btn:hover,
    .difficulty-btn:hover,
    .lang-btn:hover {
      background-color: rgba(255, 105, 180, 0.3);
    }

    .contact-btn.active,
    .difficulty-btn.active,
    .lang-btn.active {
      border-color: var(--primary-color);
      background-color: rgba(255, 105, 180, 0.5);
    }

    .version-info {
      margin-top: 20px;
      font-size: 16px;
      color: rgba(255, 255, 255, 0.7);
      text-align: center;
      line-height: 1.8;
      @media (max-width: 400px) {
        font-size: 14px;
      }
    }

    .github-btn {
      margin-top: 10px;
      color: rgba(255, 255, 255, 0.7);
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 5px;
      transition: color 0.2s;
      position: relative;
      z-index: 1000;
      cursor: pointer;
    }

    .github-btn:hover {
      color: #ff69b4;
    }

    #fps-display {
      position: absolute;
      bottom: 5px;
      left: 5px;
      color: #0f0;
      font-size: 15px;
      font-weight: bold;
      text-shadow: 0 0 3px #000;
      z-index: 20;
      line-height: 1.2;
      cursor: pointer;
    }


    /* è”ç³»ä½œè€…éƒ¨åˆ† */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.4);
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background-color: #fff;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
      width: 90%;
      max-width: 400px;
      text-align: left;
    }

    .modal-content h3 {
      margin-top: 0;
      font-size: 1.1rem;
      color: #333;
    }

    .modal-content textarea {
      width: 100%;
      height: 100px;
      margin: 10px 0;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #ccc;
      resize: none;
      font-size: 0.95rem;
      box-sizing: border-box;
    }

    .modal-actions {
      text-align: right;
    }

    .modal-actions button {
      margin-left: 10px;
      padding: 6px 12px;
      border: none;
      border-radius: 6px;
      background-color: #4caf50;
      color: #fff;
      cursor: pointer;
      font-size: 0.95rem;
      transition: background-color 0.3s ease;
    }

    .modal-actions button:hover {
      background-color: #45a049;
    }

    .modal-actions button#cancel-btn {
      background-color: #aaa;
    }

    .modal-actions button#cancel-btn:hover {
      background-color: #888;
    }

    .close {
      float: right;
      font-size: 1.3rem;
      cursor: pointer;
    }


    .music-control:hover {
      background: rgba(255, 105, 180, 1);
      box-shadow: 0 6px 20px rgba(255, 105, 180, 0.6);
    }

    .music-control svg {
      width: 20px;
      height: 20px;
      fill: white;
      transition: all 0.2s ease;
    }

    .start-button-container {
      position: relative;
      display: flex;
      justify-content: center;
      margin: 15px 0px;
    }

    .music-control {
      position: absolute;
      left: calc(50% + 90px);
      top: 50%;
      transform: translateY(-50%);
      margin-left: 0;
      width: 40px;
      height: 40px;
      background: rgba(255, 105, 180, 0.8);
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(255, 105, 180, 0.4);
    }

    /* æ¸¸æˆä¸­çš„éŸ³ä¹æ§åˆ¶æŒ‰é’® */
    .game-music-control {
      position: absolute;
      bottom: 15px;
      right: 15px;
      width: 32px;
      height: 32px;
      background: rgba(255, 105, 180, 0.8);
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(255, 105, 180, 0.4);
      z-index: 15;
    }

    .game-music-control:hover {
      background: rgba(255, 105, 180, 1);
      box-shadow: 0 6px 20px rgba(255, 105, 180, 0.6);
    }

    .game-music-control svg {
      width: 16px;
      height: 16px;
      fill: white;
      transition: all 0.2s ease;
    }

    @media (max-width: 400px) {
      .music-control {
        left: calc(50% + 75px);
        width: 36px;
        height: 36px;
      }

      .music-control svg {
        width: 18px;
        height: 18px;
      }

      .game-music-control {
        width: 28px;
        height: 28px;
        bottom: 10px;
        right: 10px;
      }

      .game-music-control svg {
        width: 14px;
        height: 14px;
      }
    }

    #loading-line {
      width: 60%;
      max-width: 400px;
      height: 10px;
      margin: 5px auto;
      background: rgba(255,255,255,0.2);
      border-radius: 6px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #loading-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #00d2ff, #3a7bd5);
      transition: width 0.25s ease-out;
    }

    #loading-text {
      text-align: center;
      color: white;
      font-size: 16px;
    }
    /* å»é™¤ç§»åŠ¨ç«¯ç‚¹å‡»æŒ‰é’®çš„é«˜äº®é—ªæ¡† */
    * {
      -webkit-tap-highlight-color: transparent;
    }
  </style>
</head>
<body>

<div id="game-container">
  <canvas id="game-canvas"></canvas>
  <div id="fps-display">
    <div>FPS: 0</div>
  </div>

  <!-- æ¸¸æˆä¸­çš„éŸ³ä¹æ§åˆ¶æŒ‰é’® -->
  <div id="game-music-control" class="game-music-control" style="display: none;">
    <svg id="game-music-icon-play" viewBox="0 0 24 24">
      <path
        d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
    </svg>
    <svg id="game-music-icon-mute" viewBox="0 0 24 24" style="display: none;">
      <path
        d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
    </svg>
  </div>

  <!-- èƒŒæ™¯éŸ³ä¹ -->
  <div id="audio-container"></div>

  <div id="start-screen" class="game-overlay start-adjust">
    <img id="header-image" style="width: 100%; position: absolute; top: 0; left: 0; z-index: -1;">
    <div style="display: flex; flex-direction: column; align-items: center; margin-top: 20vh;">
      <h1 class="overlay-title" data-text="title">éŸ³ç¬¦å°„æ‰‹</h1>
      <p class="overlay-text" data-text="instructions">ç§»åŠ¨é¼ æ ‡æˆ–æ‰‹æŒ‡æ¥æ§åˆ¶è§’è‰²<br>æŒ‰ä½å±å¹•æŒç»­å‘å°„éŸ³ç¬¦ï¼</p>
      <div class="difficulty-selector">
        <button class="difficulty-btn" data-difficulty="easy" data-text="easy">ç®€å•</button>
        <button class="difficulty-btn" data-difficulty="normal" data-text="normal">æ™®é€š</button>
        <button class="difficulty-btn" data-difficulty="hard" data-text="hard">å›°éš¾</button>
        <button class="difficulty-btn" data-difficulty="endless" data-text="endless">æ— å°½æ¨¡å¼</button>
      </div>
      <div class="start-button-container">
        <button id="start-button" class="start-button" data-text="startGame">å¼€å§‹æ¸¸æˆ</button>
        <div id="music-control" class="music-control">
          <svg id="music-icon-play" viewBox="0 0 24 24">
            <path
              d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
          </svg>
          <svg id="music-icon-mute" viewBox="0 0 24 24" style="display: none;">
            <path
              d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
          </svg>
        </div>
      </div>
      <div id="language-selector" class="language-selector">
        <button class="lang-btn" data-lang="zh">ä¸­æ–‡</button>
        <button class="lang-btn" data-lang="en">English</button>
        <button class="lang-btn" data-lang="ja">æ—¥æœ¬èª</button>
        <button class="contact-btn" data-text="contact" id="contact-btn">è”ç³»ä½œè€…</button>
      </div>
    </div>
    <div id="contact-modal" class="modal">
      <div class="modal-content">
        <span class="close">&times;</span>
        <h3 data-text="contact">è”ç³»ä½œè€…</h3>
        <textarea id="contact-text" data-placeholder="contactHolder"
                  placeholder="è¯·è¾“å…¥å†…å®¹ï¼ˆä¸è¶…è¿‡100å­— å¦‚æœä½ å¸Œæœ›æ”¶åˆ°ä½œè€…å›å¤ï¼Œè®°å¾—ç•™ä¸‹é‚®ç®±åœ°å€ï¼‰"
                  maxlength="100"></textarea>
        <div class="modal-actions">
          <button id="send-btn" data-text="submit">æäº¤</button>
          <button id="cancel-btn" data-text="close">å…³é—­</button>
        </div>
      </div>
    </div>
    <!-- åŠ è½½è¿›åº¦ç•Œé¢ -->
    <div id="loading-line">
      <div id="loading-fill"></div>
    </div>
    <div id="loading-text">Loading... 0%</div>

    <div class="version-info">
      <div><span data-text="version">ç‰ˆæœ¬</span>ï¼š0.4</div>
      <div><span data-text="updateTime">æ›´æ–°æ—¶é—´</span>ï¼š2025-10-07</div>
      <div>
        <a href="https://github.com/zfkdiyi/bangdream" id="github-button" class="github-btn">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path
              d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
          </svg>
          GitHub
        </a>
      </div>
      <div id="online-count"></div>
    </div>
  </div>

  <div id="defeat-screen" class="game-overlay hidden">
    <div style="display: flex; flex-direction: column; align-items: center;">
      <p id="game-time-defeat" class="result-text"></p>
      <img id="defeat-image" alt="DEFEAT"
           style="max-width: 80%; max-height: 60%; object-fit: contain;">
      <p class="overlay-text" data-text="defeatMessage">ä¸è¦ç°å¿ƒï¼Œå†æ¥ä¸€æ¬¡ï¼</p>
      <button id="restart-button-defeat" class="end-button" data-text="retry">é‡è¯•</button>
      <button id="home-button-defeat" class="end-button" data-text="backToHome">å›åˆ°é¦–é¡µ</button>
    </div>
  </div>

  <div id="win-screen" class="game-overlay hidden">
    <div style="display: flex; flex-direction: column; align-items: center;">
      <p id="game-time-win" class="result-text"></p>
      <img id="win-image" alt="YOU WIN" style="max-width: 80%; max-height: 60%; object-fit: contain;">
      <p class="overlay-text" data-text="winMessage">é—ªé—ªå‘å…‰ï¼Œå¿ƒåŠ¨ä¸å·²ï¼</p>
      <button id="restart-button-win" class="end-button" data-text="playAgain">å†ç©ä¸€æ¬¡</button>
      <button id="home-button-win" class="end-button" data-text="backToHome">å›åˆ°é¦–é¡µ</button>
    </div>
  </div>
</div>

<script>
  (function () {
    let currentLang = 'zh';
    const languages = {
      zh: {
        title: 'å…ƒç¥–ï¼BanG Dreamé…±<br>éŸ³ç¬¦å°„æ‰‹',
        instructions: 'ç§»åŠ¨é¼ æ ‡æˆ–æ‰‹æŒ‡æ¥æ§åˆ¶è§’è‰²<br>æŒ‰ä½å±å¹•æŒç»­å‘å°„éŸ³ç¬¦ï¼',
        startGame: 'å¼€å§‹æ¸¸æˆ',
        defeatMessage: 'ä¸è¦ç°å¿ƒï¼Œå†æ¥ä¸€æ¬¡ï¼',
        retry: 'é‡è¯•ä¸€æ¬¡',
        winMessage: 'é—ªé—ªå‘å…‰ å¿ƒåŠ¨ä¸å·²ï¼',
        playAgain: 'å†ç©ä¸€æ¬¡',
        backToHome: 'å›åˆ°é¦–é¡µ',
        lives: 'ç”Ÿå‘½æ•°',
        score: 'ç§¯åˆ†',
        version: 'ç‰ˆæœ¬',
        updateTime: 'æ›´æ–°æ—¶é—´',
        contact: 'è”ç³»ä½œè€…',
        submit: 'æäº¤',
        close: 'å…³é—­',
        contactHolder: 'è¯·è¾“å…¥å†…å®¹ï¼ˆä¸è¶…è¿‡100å­— å¦‚æœä½ å¸Œæœ›æ”¶åˆ°ä½œè€…å›å¤ï¼Œè®°å¾—ç•™ä¸‹é‚®ç®±åœ°å€ï¼‰',
        easy: 'å®¹æ˜“',
        normal: 'ä¸­ç­‰',
        hard: 'å›°éš¾',
        endless: 'æ— å°½æ¨¡å¼',
        gameTime: 'æ¸¸æˆæ—¶é—´',
        mode: 'æ¨¡å¼',
        alertEmpty: 'è¯·è¾“å…¥å†…å®¹',
        alertFrequent: 'è¯·å‹¿é¢‘ç¹æäº¤',
        alertSuccess: 'å·²æˆåŠŸæäº¤ï¼',
        alertError: 'æäº¤å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•',
        killScore: 'å‡»æ€å¾—åˆ†',
        maxCombo: 'æœ€å¤§è¿å‡»',
        totalScore: 'æ€»å¾—åˆ†'
      },
      en: {
        title: 'GANSO! BanG Dream Chan<br>Note Shooter',
        instructions: 'Move mouse or finger to control character<br>Hold screen to shoot notes continuously!',
        startGame: 'Start Game',
        defeatMessage: 'Don\'t give up, try again!',
        retry: 'Retry',
        winMessage: 'KIRAKIRA DOKIDOKI!',
        playAgain: 'Play Again',
        backToHome: 'Back to Home',
        lives: 'Lives',
        score: 'Score',
        version: 'Version',
        updateTime: 'Update time',
        contact: 'Contact Me',
        submit: 'Submit',
        close: 'Close',
        contactHolder: "Please enter your message (up to 100 characters). If youâ€™d like a reply, donâ€™t forget to leave your email address.",
        easy: 'Easy',
        normal: 'Normal',
        hard: 'Hard',
        endless: 'Endless',
        gameTime: 'Game Time',
        mode: 'Mode',
        alertEmpty: 'Please enter content',
        alertFrequent: 'Please do not submit frequently',
        alertSuccess: 'Successfully submitted!',
        alertError: 'Submission failed, please try again later',
        killScore: 'Kill Score',
        maxCombo: 'Max Combo',
        totalScore: 'Total Score'
      },
      ja: {
        title: 'ã€Œå…ƒç¥–ï¼ãƒãƒ³ãƒ‰ãƒªã¡ã‚ƒã‚“ã€<br>ãƒãƒ¼ãƒˆã‚·ãƒ¥ãƒ¼ã‚¿ãƒ¼',
        instructions: 'ãƒã‚¦ã‚¹ã‚„æŒ‡ã§ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’æ“ä½œ<br>ç”»é¢ã‚’æŠ¼ã—ç¶šã‘ã¦ ãƒãƒ¼ãƒˆã‚’é€£å°„ï¼',
        startGame: 'ã‚²ãƒ¼ãƒ é–‹å§‹',
        defeatMessage: 'è«¦ã‚ãªã„ã§ã€ã‚‚ã†ä¸€åº¦ï¼',
        retry: 'ãƒªãƒˆãƒ©ã‚¤',
        winMessage: 'ã‚­ãƒ©ã‚­ãƒ©ãƒ‰ã‚­ãƒ‰ã‚­ï¼',
        playAgain: 'ã‚‚ã†ä¸€åº¦',
        backToHome: 'ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹',
        lives: 'ãƒ©ã‚¤ãƒ•',
        score: 'ãƒã‚¤ãƒ³ãƒˆ',
        version: 'ãƒãƒ¼ã‚¸ãƒ§ãƒ³',
        updateTime: 'æ›´æ–°æ—¥æ™‚',
        contact: 'ãŠå•ã„åˆã‚ã›',
        submit: 'é€ä¿¡',
        close: 'é–‰ã˜ã‚‹',
        contactHolder: "å†…å®¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆ100æ–‡å­—ä»¥å†…ï¼‰ã€‚è¿”ä¿¡ã‚’ã”å¸Œæœ›ã®æ–¹ã¯ã€ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å¿˜ã‚Œãšã«ã”è¨˜å…¥ãã ã•ã„ã€‚",
        easy: 'ç°¡å˜',
        normal: 'æ™®é€š',
        hard: 'é›£ã—ã„',
        endless: 'ç„¡é™ãƒ¢ãƒ¼ãƒ‰',
        gameTime: 'ã‚²ãƒ¼ãƒ æ™‚é–“',
        mode: 'ãƒ¢ãƒ¼ãƒ‰',
        alertEmpty: 'å†…å®¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„',
        alertFrequent: 'é »ç¹ã«é€ä¿¡ã—ãªã„ã§ãã ã•ã„',
        alertSuccess: 'é€ä¿¡ãŒå®Œäº†ã—ã¾ã—ãŸï¼',
        alertError: 'é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãã—ã¦ã‹ã‚‰ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„',
        killScore: 'æ’ƒç ´ã‚¹ã‚³ã‚¢',
        maxCombo: 'æœ€å¤§ã‚³ãƒ³ãƒœ',
        totalScore: 'åˆè¨ˆã‚¹ã‚³ã‚¢'
      }
    };


    // éšæœºé€‰æ‹©å¤´å›¾
    const setRandomHeaderImage = () => {
      const randomIndex = Math.floor(Math.random() * 10) + 1;
      document.getElementById('header-image').src =
      'https://cdn.badmintonranks.com/bangdream/img/head' + randomIndex +'.jpg';
    };

    // è‡ªåŠ¨æ£€æµ‹æµè§ˆå™¨è¯­è¨€
    const detectLanguage = () => {
      const lang = (navigator.language || navigator.userLanguage || 'en').toLowerCase();
      if (lang.startsWith('zh')) return 'zh';
      if (lang.startsWith('ja')) return 'ja';
      return 'en';
    };
    // æ›´æ–°è¯­è¨€å†…å®¹
    const updateLanguage = (lang) => {
      const texts = languages[lang] || languages.en;
      // æ›´æ–°æ–‡å­—å†…å®¹
      document.querySelectorAll('[data-text]').forEach(el => {
        const key = el.dataset.text;
        if (texts[key]) el.innerHTML = texts[key];
      });
      // æ›´æ–° placeholder
      document.querySelectorAll('[data-placeholder]').forEach(el => {
        const key = el.dataset.placeholder;
        if (texts[key]) el.placeholder = texts[key];
      });
      // æ›´æ–°é¡µé¢æ ‡é¢˜ (ç”¨æ­£åˆ™æ›¿æ¢æ‰æ‰€æœ‰<br>æ¢è¡Œç¬¦ï¼‰
      document.title = texts.title.replace(/<br\s*\/?>/g, ' ');
      // æ›´æ–°è¯­è¨€æŒ‰é’®çŠ¶æ€
      document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.lang === lang);
      });
    };
    // éŸ³ä¹æ§åˆ¶ç›¸å…³å˜é‡
    let menuMusic, battleMusic, endMusic;
    let currentMusic = null;
    let isMusicEnabled = false;

    // å…¬å…±å‰ç¼€
    const audioPrefix = "https://cdn.badmintonranks.com/bangdream/music/";
    // éŸ³ä¹æ–‡ä»¶åæ•°ç»„
    const musicFiles = [
      { id: "menu-music", file: "menu.mp3", loop: true },
      { id: "battle-music", file: "battle1.mp3", loop: true },
      { id: "end-music", file: "end.mp3", loop: true }
    ];
    // éå†ç”Ÿæˆ <audio> æ ‡ç­¾
    function createMusic() {
      const audioContainer = document.getElementById("audio-container");
      musicFiles.forEach(music => {
        const audio = document.createElement("audio");
        audio.id = music.id;
        audio.loop = music.loop;
        // autoè¡¨ç¤ºæµè§ˆå™¨å°½å¯èƒ½åœ°æå‰åŠ è½½æ•´ä¸ªéŸ³é¢‘æ–‡ä»¶ï¼Œä»¥ä¾¿ç”¨æˆ·ä¸€ç‚¹å‡»æ’­æ”¾å°±èƒ½ç«‹å³å¼€å§‹ã€‚
        // noneè¡¨ç¤ºæµè§ˆå™¨ä¸ä¸‹è½½éŸ³é¢‘ï¼Œé™¤éç”¨æˆ·ç‚¹å‡»æ’­æ”¾ã€‚å»¶è¿Ÿå¤§
        audio.preload = "auto";

        const source = document.createElement("source");
        source.src = `${audioPrefix}${music.file}`;
        source.type = "audio/mpeg";

        audio.appendChild(source);
        audioContainer.appendChild(audio);
        initMusicControl();
      });
    }



    // æ’­æ”¾æŒ‡å®šéŸ³ä¹
    const playMusic = (musicType) => {
      // åœæ­¢æ‰€æœ‰éŸ³ä¹
      [menuMusic, battleMusic, endMusic].forEach(music => {
        if (music) {
          music.pause();
          music.currentTime = 0;
        }
      });
      // æ’­æ”¾æŒ‡å®šéŸ³ä¹
      if (isMusicEnabled) {
        if (musicType === 'menu') {
          currentMusic = menuMusic;
        } else if (musicType === 'battle') {
          currentMusic = battleMusic;
        } else if (musicType === 'end') {
          currentMusic = endMusic;
        }

        if (currentMusic) {
          currentMusic.play().catch(e => console.log('éŸ³ä¹æ’­æ”¾å¤±è´¥:', e));
        }
      }
    };

    // æ›´æ–°éŸ³ä¹æŒ‰é’®å›¾æ ‡
    const updateMusicIcons = () => {
      const playIcons = document.querySelectorAll('[id$="-icon-play"]');
      const muteIcons = document.querySelectorAll('[id$="-icon-mute"]');

      playIcons.forEach(icon => {
        icon.style.display = isMusicEnabled ? 'none' : 'block';
      });
      muteIcons.forEach(icon => {
        icon.style.display = isMusicEnabled ? 'block' : 'none';
      });
    };

    // åˆ‡æ¢éŸ³ä¹å¼€å…³
    const toggleMusic = () => {
      isMusicEnabled = !isMusicEnabled;
      updateMusicIcons();

      if (!isMusicEnabled) {
        // å…³é—­éŸ³ä¹
        [menuMusic, battleMusic, endMusic].forEach(music => {
          if (music) music.pause();
        });
      } else {
        // å¼€å¯éŸ³ä¹ï¼Œæ ¹æ®å½“å‰çŠ¶æ€æ’­æ”¾å¯¹åº”éŸ³ä¹
        if (gameState === 'playing') {
          playMusic('battle');
        } else if (gameState === 'over') {
          const isGameOverScreen = !startScreen.classList.contains('hidden') ? false : true;
          if (isGameOverScreen) {
            playMusic('end');
          } else {
            playMusic('menu');
          }
        } else {
          playMusic('menu');
        }
      }
    };
    // åˆå§‹åŒ–éŸ³ä¹æ§åˆ¶
    const initMusicControl = () => {
      menuMusic = document.getElementById('menu-music');
      battleMusic = document.getElementById('battle-music');
      endMusic = document.getElementById('end-music');

      const musicControl = document.getElementById('music-control');
      const gameMusicControl = document.getElementById('game-music-control');
      // ä¸»èœå•éŸ³ä¹æ§åˆ¶æŒ‰é’®
      musicControl.addEventListener('click', toggleMusic);
      // æ¸¸æˆä¸­éŸ³ä¹æ§åˆ¶æŒ‰é’®
      gameMusicControl.addEventListener('click', toggleMusic);
      // Chromeä¸å…è®¸ç”¨æˆ·ä¸€æ‰“å¼€ç½‘ç«™å°±è‡ªåŠ¨æ’­æ”¾å£°éŸ³
    };

    // åˆå§‹åŒ–è¯­è¨€
    function setLanguage() {
      currentLang = detectLanguage();
      updateLanguage(currentLang);
      // è¯­è¨€åˆ‡æ¢æŒ‰é’®ç›‘å¬
      document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          currentLang = btn.dataset.lang;
          updateLanguage(currentLang);
        });
      });
    }

    // è”ç³»ä½œè€…å¼¹çª—é€»è¾‘
    const contactBtn = document.getElementById('contact-btn');
    const modal = document.getElementById('contact-modal');
    const closeBtn = modal.querySelector('.close');
    const cancelBtn = document.getElementById('cancel-btn');
    const sendBtn = document.getElementById('send-btn');
    const textarea = document.getElementById('contact-text');
    contactBtn.onclick = () => {
      modal.style.display = 'flex';
    };
    closeBtn.onclick = cancelBtn.onclick = () => {
      modal.style.display = 'none';
      textarea.value = '';
    };
    sendBtn.onclick = async () => {
      const text = textarea.value.trim();
      if (!text) {
        alert(languages[currentLang].alertEmpty);
        return;
      }
      try {
        const response = await fetch('https://badmintonranks.com/prod-api/bilibiliContact', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: text
        });
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        const data = await response.json();
        if (data.code == 427) {
          alert(languages[currentLang].alertFrequent);
          return;
        }
        alert(languages[currentLang].alertSuccess);
        modal.style.display = 'none';
        textarea.value = '';
      } catch (error) {
        console.error(error);
        alert(languages[currentLang].alertError);
      }
    };
    // FPSæ˜¾ç¤º
    const fpsDisplay = document.getElementById('fps-display');
    let lastTimes = performance.now();
    let frames = 0;
    let fps = 0;
    let fpsVisible = true;

    function updateFPS() {
      const now = performance.now();
      frames++;
      if (now - lastTimes >= 1000) { // æ¯ç§’æ›´æ–°ä¸€æ¬¡
        fps = frames;
        frames = 0;
        lastTimes = now;
        fpsDisplay.textContent = 'FPS: ' + fps;
      }
    }
    // åˆå§‹åŒ–FPSæ˜¾ç¤ºçŠ¶æ€
    function initFPS() {
      fpsDisplay.addEventListener('click', () => {
        fpsVisible = !fpsVisible;
        fpsDisplay.style.display = fpsVisible ? 'block' : 'none';
      });
    }

    //è·å–åœ¨çº¿äººæ•°
    async function sendStat() {
      let from = document.referrer;
      let width = window.outerWidth;
      let height = window.window.outerHeight;
      const res = await fetch('https://badmintonranks.com/prod-api/openStat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({from, width, height})
      });
      const data = await res.json();
      if (data.online !== undefined) {
        document.getElementById('online-count').textContent = `Online: ${data.online}`;
      }
    }

    // å‘é€æ¸¸æˆç»“æœç»Ÿè®¡
    function gameStat(stage, mode, fps, win, duration, kumaKill, kumaLive, maxCombo, lifeLost, bossDamage, finalScore) {
      fetch('https://badmintonranks.com/prod-api/gameStat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          stage, mode, fps, win, duration,
          kumaKill, kumaLive, maxCombo, lifeLost, bossDamage, finalScore
        })
      });
    }

    //æ¸¸æˆéš¾åº¦å’Œæ¨¡å¼é€‰æ‹©
    let currentDifficulty = 'normal';
    let gameStartTime = 0;
    let isEndlessMode = false;

    // æ›´æ–°éš¾åº¦æŒ‰é’®è¢«é€‰ä¸­çš„çŠ¶æ€
    function updateDifficultyButtons() {
      document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.classList.toggle('active', btn.getAttribute('data-difficulty') === currentDifficulty);
      });
    }

    // åˆå§‹åŒ–éš¾åº¦æŒ‰é’®çŠ¶æ€
    updateDifficultyButtons();
    // éš¾åº¦æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    document.querySelectorAll('.difficulty-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        currentDifficulty = btn.getAttribute('data-difficulty');
        isEndlessMode = currentDifficulty === 'endless';
        updateDifficultyButtons();
      });
    });

    // è·å–ç”»å¸ƒå’Œå®¹å™¨å…ƒç´ 
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('game-container');

    // è·å–æ¸¸æˆç•Œé¢å…ƒç´ 
    const startScreen = document.getElementById('start-screen');
    const defeatScreen = document.getElementById('defeat-screen');
    const winScreen = document.getElementById('win-screen');

    const startButton = document.getElementById('start-button');
    const restartButtonDefeat = document.getElementById('restart-button-defeat');
    const restartButtonWin = document.getElementById('restart-button-win');
    const homeButtonDefeat = document.getElementById('home-button-defeat');
    const homeButtonWin = document.getElementById('home-button-win');
    startButton.addEventListener('click', startGame);// å¼€å§‹æ¸¸æˆæŒ‰é’®
    restartButtonDefeat.addEventListener('click', startGame);// å¤±è´¥é‡è¯•æŒ‰é’®
    restartButtonWin.addEventListener('click', startGame);// èƒœåˆ©é‡ç©æŒ‰é’®
    homeButtonDefeat.addEventListener('click', backToHome);// å¤±è´¥å›åˆ°é¦–é¡µæŒ‰é’®
    homeButtonWin.addEventListener('click', backToHome);// èƒœåˆ©å›åˆ°é¦–é¡µæŒ‰é’®


    // æ¸¸æˆåŸºç¡€å˜é‡
    let canvasWidth, canvasHeight;  // ç”»å¸ƒå°ºå¯¸
    let player, bullets, bears, boss, explosions;  // æ¸¸æˆå¯¹è±¡
    let currentStage = 1; //å½“å‰å…³å¡
    let uiFont = 16; // UIå­—ä½“å¤§å°
    let uiAdjust = 0; // UIå­—ä½“è·ç¦»åç§»é‡
    let bearSpawnTimer = 0;  // å°ç†Šç”Ÿæˆè®¡æ—¶å™¨
    let bearSpawnInterval = 700;  // å°ç†Šç”Ÿæˆé—´éš”ï¼ˆæ¯«ç§’ï¼‰
    let killCount = 0;  // æ€»å‡»æ€æ•°
    let killsSinceLastLife = 0;  // è‡ªä¸Šæ¬¡è·å¾—ç”Ÿå‘½ä»¥æ¥çš„å‡»æ€æ•°
    let comboCount = 0;  // è¿å‡»æ•°
    let maxComboCount = 0;  // æœ€å¤§è¿å‡»æ•°
    let escapedBearCount = 0;  // é€ƒèµ°å°ç†Šæ•°
    let deathCount = 0;  // é˜µäº¡æ¬¡æ•°
    let bossSpawned = false;  // BOSSæ˜¯å¦å·²ç”Ÿæˆ
    let gameLoopId;  // æ¸¸æˆå¾ªç¯ID
    let roadLineY = -100;  // é“è·¯çº¿æ¡Yåæ ‡
    let gameState;  // æ¸¸æˆçŠ¶æ€
    let bossDeathPosition;  // BOSSæ­»äº¡ä½ç½®
    let screenFlashAlpha = 0;  // å±å¹•é—ªå…‰é€æ˜åº¦
    let bossFlashTimer = 0;  // BOSSå—å‡»é—ªå…‰è®¡æ—¶å™¨
    let playerInvulnerable = false;  // ç©å®¶æ— æ•ŒçŠ¶æ€
    let invulnerabilityTimer = 0;  // æ— æ•Œæ—¶é—´è®¡æ—¶å™¨
    let flashEffects = [];  // é—ªå…‰æ•ˆæœæ•°ç»„
    let isShooting = false;  // æ˜¯å¦æ­£åœ¨å°„å‡»
    let shootTimer = 0;  // å°„å‡»è®¡æ—¶å™¨
    let shootInterval = 80;  // å°„å‡»é—´éš”ï¼ˆæ¯«ç§’ï¼‰è¶Šå°å­å¼¹å‘å°„è¶Šå¯†é›†ï¼Œç«åŠ›æ›´å¼º


    // å…¬å…±å‰ç¼€
    // const IMG_PATH = 'img/';
    const IMG_PATH = 'https://cdn.badmintonranks.com/bangdream/img/';
    // æ¸¸æˆèµ„æºå®šä¹‰
    const assets = {
      player1: 'player1.png',
      player2: 'player2.png',
      player3: 'player3.png',
      player4: 'player4.png',
      player5: 'player5.png',
      player6: 'player6.png',
      bear1: 'kuma1.png',
      bear2: 'kuma2.png',
      boss1: 'kkr1.png',
      boss2: 'kkr2.png',
      boss3: 'kkr3.png',
      boss4: 'kkr4.png',
      bullet1: 'bullet1.png',
      bullet2: 'bullet2.png',
      bullet3: 'bullet3.png',
      flash1: 'flash1.png',
      flash2: 'flash2.png',
      defeat1: 'defeat1.png',
      defeat2: 'defeat2.png',
      defeat3: 'defeat3.png',
      scoreIcon: 'kumaIcon.png',
      comboIcon: 'combo.png',
      win: 'win.png',
      defeat: 'defeat.png'
    };
    // å­˜å‚¨åŠ è½½åçš„å›¾åƒå¯¹è±¡
    const assetImages = {};

    function loadAssets(callback, onProgress) {
      let loadedCount = 0;
      const totalCount = Object.keys(assets).length;

      function handleProgress() {
        loadedCount++;
        if (onProgress) onProgress(loadedCount, totalCount);
        if (loadedCount === totalCount) callback();
      }

      Object.entries(assets).forEach(([key, filename]) => {
        const img = new Image();
        img.src = IMG_PATH + filename;
        img.onload = handleProgress;
        img.onerror = () => {
          console.warn(`âŒ Failed to load: ${img.src}ï¼Œé‡è¯•ä¸­...`);
          retryLoad(img, IMG_PATH + filename, 3, handleProgress);
        };
        assetImages[key] = img;
      });
    }

    function retryLoad(img, src, retries, onSuccess) {
      let attempts = 0;

      function tryAgain() {
        if (attempts >= retries) {
          console.error(`ğŸš« å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œå·²æ”¾å¼ƒ: ${src}`);
          onSuccess(); // å³ä½¿å¤±è´¥ï¼Œä¹Ÿæ¨è¿›è¿›åº¦
          return;
        }
        attempts++;
        setTimeout(() => {
          img.src = src + '?retry=' + attempts;
        }, 30 * attempts);
      }

      img.onerror = tryAgain;
      img.onload = onSuccess;
      tryAgain();
    }

    function loadData() {
      const loadingText = document.getElementById('loading-text');
      const progressBarFill = document.getElementById('loading-fill');
      const loadingLine = document.getElementById('loading-line');
      loadAssets(
        () => {
          progressBarFill.style.width = '100%';
          setTimeout(() => {
            loadingLine.style.opacity = '0';
            loadingText.style.opacity = '0';
            setTimeout(() => {
              loadingLine.style.visibility = 'hidden';
              loadingText.style.visibility = 'hidden';
            }, 500);
          }, 800);
          // ç»™HTMLå›¾ç‰‡èµ‹å€¼src
          document.getElementById('win-image').src = assetImages.win.src;
          document.getElementById('defeat-image').src = assetImages.defeat.src;
        },
        (loaded, total) => {
          const percent = Math.round((loaded / total) * 100);
          loadingText.textContent = `Loading... ${percent}%`;
          progressBarFill.style.width = `${percent}%`;
        }
      );
    }

    // ç©å®¶ç±»
    class Player {
      constructor() {
        this.width = canvasWidth / 7;  // å•ä¸ªè§’è‰²å®½åº¦
        this.height = this.width * 1.2;  // è§’è‰²é«˜åº¦
        this.x = canvasWidth / 2;  // Xåæ ‡ï¼ˆä¸­å¿ƒç‚¹ï¼‰
        this.y = canvasHeight - this.height;  // Yåæ ‡ï¼ˆåº•éƒ¨ï¼‰
        this.characterCount = 1;  // è§’è‰²æ•°é‡ï¼ˆç”Ÿå‘½æ•°ï¼‰
        this.animFrame = 0;  // åŠ¨ç”»å¸§è®¡æ•°å™¨
        this.isDead = false;  // æ­»äº¡çŠ¶æ€
        this.defeatCharacters = [];  // å¤„äºdefeatçŠ¶æ€çš„è§’è‰²
        this.characters = [1];  // å­˜å‚¨æ¯ä¸ªè§’è‰²çš„ç±»å‹ç¼–å·
        this.deadCharacterType = 1;  // æœ€åä¸€ä¸ªæ­»äº¡è§’è‰²çš„ç±»å‹
      }

      // ç»˜åˆ¶ç©å®¶è§’è‰²
      draw() {
        this.animFrame++;

        if (this.isDead) {
          // å¦‚æœæ˜¯æ­»äº¡çŠ¶æ€ï¼ŒæŒ‰defeatå›¾ç‰‡çš„çœŸå®å®½é«˜æ¯”è¿›è¡Œç»˜åˆ¶
          const currentImage = assetImages[`defeat${this.deadCharacterType}`];
          const aspectRatio = currentImage.naturalWidth / currentImage.naturalHeight;
          const defeatWidth = this.height * 1.2;
          const defeatHeight = defeatWidth / aspectRatio;
          const drawX = this.x - defeatWidth / 2;
          const drawY = this.y + this.height - defeatHeight;

          // ç»˜åˆ¶é˜´å½±
          // ctx.fillStyle = 'rgba(0,0,0,0.3)';
          // ctx.beginPath();
          // ctx.ellipse(this.x, this.y + this.height, defeatWidth * 0.3, defeatWidth * 0.15, 0, 0, Math.PI * 2);
          // ctx.fill();

          ctx.drawImage(currentImage, drawX, drawY, defeatWidth, defeatHeight);
        } else {
          // ç»˜åˆ¶å­˜æ´»çš„è§’è‰²
          const totalWidth = this.width * this.characterCount;
          const startX = this.x - totalWidth / 2;
          for (let i = 0; i < this.characterCount; i++) {
            // ç»˜åˆ¶é˜´å½±
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(startX + i * this.width + this.width / 2, this.y + this.height, this.width * 0.3, this.width * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();

            // æ ¹æ®è§’è‰²ç±»å‹é€‰æ‹©ä¸åŒå½¢è±¡
            let characterImage;
            const characterType = this.characters[i];
            const isFrame2 = Math.floor(this.animFrame / 30) % 2 === 1;

            if (characterType === 2) {
              characterImage = isFrame2 ? assetImages.player4 : assetImages.player3;
            } else if (characterType === 3) {
              characterImage = isFrame2 ? assetImages.player6 : assetImages.player5;
            } else {
              characterImage = isFrame2 ? assetImages.player2 : assetImages.player1;
            }

            ctx.drawImage(characterImage, startX + i * this.width, this.y, this.width, this.height);
          }

          // ç»˜åˆ¶defeatçŠ¶æ€çš„è§’è‰²
          this.defeatCharacters.forEach(defeatChar => {
            const defeatImage = assetImages[`defeat${defeatChar.characterIndex}`];
            const aspectRatio = defeatImage.naturalWidth / defeatImage.naturalHeight;
            const defeatWidth = this.height * 1.2;
            const defeatHeight = defeatWidth / aspectRatio;
            const drawX = defeatChar.x - defeatWidth / 2;
            const drawY = this.y + this.height - defeatHeight;

            // ç»˜åˆ¶é˜´å½±
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(defeatChar.x, this.y + this.height, defeatWidth * 0.3, defeatWidth * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.drawImage(defeatImage, drawX, drawY, defeatWidth, defeatHeight);
          });
        }
      }

      // å‘å°„å­å¼¹
      shoot() {
        const totalWidth = this.width * this.characterCount;
        const startX = this.x - totalWidth / 2;
        for (let i = 0; i < this.characterCount; i++) {
          const bulletX = startX + i * this.width + this.width / 2;
          const bulletType = this.characters[i]; // æ ¹æ®è§’è‰²ç±»å‹é€‰æ‹©å­å¼¹
          bullets.push(new Bullet(bulletX, this.y, bulletType));
        }
      }

      // æ ¹æ®å‡»æ€æ•°æ›´æ–°è§’è‰²æ•°é‡
      updateCharacterCount() {
        // æ¯å‡»æ€5ä¸ªå°ç†Šå¢åŠ 1è¡€
        if (killsSinceLastLife >= 5 && this.characterCount < 5) {
          player.characterCount++;
          // æ·»åŠ æ–°è§’è‰²éšæœº1,2,3
          // const nextType = (this.characters.length % 3) + 1;
          const nextType = Math.floor(Math.random() * 3) + 1;
          this.characters.push(nextType);
          killsSinceLastLife = 0;
        }
      }

      // æ›´æ–°defeatè§’è‰²çŠ¶æ€
      updateDefeatCharacters(deltaTime) {
        this.defeatCharacters = this.defeatCharacters.filter(defeatChar => {
          defeatChar.timer -= deltaTime;
          return defeatChar.timer > 0;
        });
      }
    }

    // å­å¼¹ç±»
    class Bullet {
      constructor(x, y, bulletType = 1) {
        this.width = canvasWidth / 18; // å­å¼¹å®½åº¦
        this.height = this.width * 1.6; // å­å¼¹é«˜åº¦
        this.x = x - this.width / 2; // Xåæ ‡ï¼ˆä¸­å¿ƒå¯¹é½ï¼‰
        this.y = y; // Yåæ ‡
        // ã€ä¼˜åŒ–ã€‘é€Ÿåº¦å•ä½æ”¹ä¸ºâ€œåƒç´ /ç§’â€ï¼Œå¹¶ä¸å±å¹•é«˜åº¦å…³è”
        this.speed = canvasHeight * 1.5; // æ¯ç§’ç§»åŠ¨1.5å€ç”»å¸ƒé«˜åº¦
        this.image = assetImages[`bullet${bulletType}`]; // æ ¹æ®ç±»å‹é€‰æ‹©å­å¼¹å›¾åƒ
        this.markedForDeletion = false; // ã€æ–°å¢ã€‘ç”¨äºæ ‡è®°å¾…åˆ é™¤çš„å¯¹è±¡ï¼Œæ›¿ä»£splice
      }

      // æ›´æ–°å­å¼¹ä½ç½®ï¼ˆå‘ä¸Šç§»åŠ¨ï¼‰
      update(deltaTime) { // ã€ä¼˜åŒ–ã€‘æ¥æ”¶deltaTimeå‚æ•°
        // ã€ä¼˜åŒ–ã€‘ç§»åŠ¨è·ç¦» = é€Ÿåº¦ * æ—¶é—´ï¼ˆç§’ï¼‰
        this.y -= this.speed * (deltaTime / 1000);
        // ã€ä¼˜åŒ–ã€‘å¦‚æœå­å¼¹å‡ºç•Œï¼Œæ ‡è®°å®ƒ
        if (this.y < -this.height) this.markedForDeletion = true;
      }

      // ç»˜åˆ¶å­å¼¹
      draw() {
        ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
      }
    }

    // ç²‰è‰²å°ç†Šç±»
    class Bear {
      constructor(x, y) {
        this.width = canvasWidth / 6; // å°ç†Šå®½åº¦
        this.height = this.width; // å°ç†Šé«˜åº¦
        this.x = x; // Xåæ ‡
        this.y = y; // Yåæ ‡
        // ã€ä¼˜åŒ–ã€‘é€Ÿåº¦å•ä½æ”¹ä¸ºâ€œåƒç´ /ç§’â€ï¼Œå¹¶ä¸å±å¹•é«˜åº¦å…³è”
        this.speed = canvasHeight * 0.3; // æ¯ç§’ç§»åŠ¨0.3å€ç”»å¸ƒé«˜åº¦
        this.health = 5; // å°ç†Šè¡€é‡
        this.animFrame = 0; // åŠ¨ç”»å¸§è®¡æ•°å™¨
        this.flashTimer = 0; // å—å‡»é—ªå…‰è®¡æ—¶å™¨
        this.markedForDeletion = false; // ã€æ–°å¢ã€‘ç”¨äºæ ‡è®°å¾…åˆ é™¤çš„å¯¹è±¡
      }

      // æ›´æ–°å°ç†Šä½ç½®ï¼ˆå‘ä¸‹ç§»åŠ¨ï¼‰
      update(deltaTime) { // ã€ä¼˜åŒ–ã€‘æ¥æ”¶deltaTimeå‚æ•°
        // ã€ä¼˜åŒ–ã€‘ç§»åŠ¨è·ç¦» = é€Ÿåº¦ * æ—¶é—´ï¼ˆç§’ï¼‰
        this.y += this.speed * (deltaTime / 1000);
        this.animFrame++;
        if (this.flashTimer > 0) this.flashTimer--;
        // ã€ä¼˜åŒ–ã€‘å¦‚æœå°ç†Šå‡ºç•Œï¼Œæ ‡è®°å®ƒå¹¶é‡ç½®combo
        if (this.y > canvasHeight) {
          this.markedForDeletion = true;
          comboCount = 0; // å°ç†Šé€ƒèµ°æ—¶é‡ç½®combo
          escapedBearCount++; // å¢åŠ é€ƒèµ°å°ç†Šæ•°
        }
      }

      // ç»˜åˆ¶å°ç†Š
      draw() {
        // ç»˜åˆ¶é˜´å½±
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(this.x + this.width / 2, this.y + this.height, this.width * 0.3, this.width * 0.15, 0, 0, Math.PI * 2);
        ctx.fill();

        if (this.flashTimer > 0) {
          ctx.filter = 'brightness(200%) saturate(0%)';
        }
        const currentImage = Math.floor(this.animFrame / 30) % 2 === 0 ? assetImages.bear1 : assetImages.bear2;
        ctx.drawImage(currentImage, this.x, this.y, this.width, this.height);
        ctx.filter = 'none';
      }
    }

    // BOSSç±»
    class Boss {
      constructor() {
        this.width = canvasWidth / 3; // BOSSå®½åº¦
        this.height = this.width * 1.1; // BOSSé«˜åº¦
        this.x = canvasWidth / 2 - this.width / 2; // Xåæ ‡ï¼ˆå±…ä¸­ï¼‰
        this.y = -this.height; // Yåæ ‡ï¼ˆä»å±å¹•ä¸Šæ–¹å¼€å§‹ï¼‰
        // ã€ä¼˜åŒ–ã€‘é€Ÿåº¦å•ä½æ”¹ä¸ºâ€œåƒç´ /ç§’â€
        this.speed = canvasHeight * 0.15; // åŸºç¡€ç§»åŠ¨é€Ÿåº¦
        // æ ¹æ®éš¾åº¦è®¾ç½®è¡€é‡
        let bossHealth;
        if (currentDifficulty === 'easy') {
          bossHealth = 800;
        } else if (currentDifficulty === 'hard') {
          bossHealth = 2800;
        } else {
          bossHealth = 1400;
        }
        this.health = bossHealth; // å½“å‰è¡€é‡
        this.maxHealth = bossHealth; // BOSSåˆå§‹è¡€é‡
        this.targetY = canvasHeight * 0.1; // ç¬¬ä¸€é˜¶æ®µç›®æ ‡Yåæ ‡
        // ã€ä¼˜åŒ–ã€‘æ°´å¹³ç§»åŠ¨é€Ÿåº¦
        this.dx = canvasWidth * 0.1; // Xè½´ç§»åŠ¨é€Ÿåº¦
        this.directionX = 1; // Xè½´ç§»åŠ¨æ–¹å‘
        this.phase = 1; // BOSSé˜¶æ®µï¼ˆ1æˆ–2ï¼‰
        this.vy = 0; // Yè½´æ–¹å‘çš„é€Ÿåº¦ï¼ˆåƒç´ /ç§’ï¼‰
        this.gravity = canvasHeight * 0.1; // ã€æ–°å¢ã€‘é‡åŠ›åŠ é€Ÿåº¦ï¼ˆåƒç´ /ç§’^2ï¼‰
        this.bounceTargetY = canvasHeight * 0.3; // å¼¹è·³ç›®æ ‡Yåæ ‡
        this.animFrame = 0; // åŠ¨ç”»å¸§è®¡æ•°å™¨
        this.attackState = 'normal'; // æ”»å‡»çŠ¶æ€ï¼šnormal, raising, punching
        this.attackTimer = 0; // æ”»å‡»è®¡æ—¶å™¨
      }

      // æ›´æ–°BOSSçŠ¶æ€å’Œä½ç½®
      update(deltaTime, gameTime) { // ã€ä¼˜åŒ–ã€‘æ¥æ”¶deltaTimeå’ŒgameTimeå‚æ•°
        const deltaSeconds = deltaTime / 1000; // ã€ä¼˜åŒ–ã€‘å°†æ—¶é—´è½¬æ¢ä¸ºç§’
        this.animFrame++;
        // BOSSè¡€é‡75%ä»¥ä¸‹æˆ–æ¸¸æˆæ—¶é—´è¶…è¿‡15ç§’ è¿›å…¥ç¬¬äºŒé˜¶æ®µ
        if ((this.health <= this.maxHealth * 0.75 || gameTime > 15000) && this.phase === 1) {
          this.phase = 2;
        }
        //ç¬¬ä¸€é˜¶æ®µ BOSSæ°´å¹³å·¡èˆª
        if (this.phase === 1) {
          if (this.y < this.targetY) this.y += this.speed * deltaSeconds;
          else {
            this.x += this.dx * this.directionX * deltaSeconds;
            if (this.x <= 0) {
              this.x = 0;
              this.directionX = 1;
            }
            if (this.x + this.width >= canvasWidth) {
              this.x = canvasWidth - this.width;
              this.directionX = -1;
            }
          }
        } else {
          const targetX = player.x - this.width / 2;
          if (Math.abs(this.x - targetX) > 2) {
            this.x += (targetX - this.x) * 0.02;
          }
          // æ¥è¿‘ç©å®¶æ—¶ï¼ˆç©å®¶åœ¨BOSSçš„ä¸‹æ–¹ï¼Œä¸”è·ç¦»å°äºç©å®¶çš„èº«é«˜ï¼‰å˜æˆä¸¾èµ·æ‹³å¤´çŠ¶æ€æŒç»­0.3ç§’
          const distanceToPlayer = player.y - (this.y + this.height);
          if (distanceToPlayer >= 0 && distanceToPlayer <= player.height &&
            this.attackState === 'normal' && this.vy >= 0) {
            this.attackState = 'raising';
            this.attackTimer = 300;
          }
          // å¤„ç†æ”»å‡»çŠ¶æ€
          if (this.attackState === 'raising') {
            this.attackTimer -= deltaTime;
            //ç ¸æ‹³å¤´
            if (this.attackTimer <= 0) {
              this.attackState = 'punching';
              this.attackTimer = 300; // ç ¸æ‹³å¤´æŒç»­æ—¶é—´
            }
          } else if (this.attackState === 'punching') {
            this.attackTimer -= deltaTime;
            if (this.attackTimer <= 0) {
              this.attackState = 'normal';
            }
          }
          let factor = 1;
          let bounceFactor = 0.8;
          if (currentDifficulty === 'hard') {
            factor = 1.3;
            bounceFactor = 1
          } else if (currentDifficulty === 'easy') {
            factor = 0.7;
            bounceFactor = 0.6;
          }
          // BOSSä¸‹é™é€Ÿåº¦ éš¾åº¦è¶Šå¤§ä¸‹é™è¶Šå¿«
          this.vy += this.gravity * deltaSeconds * factor;
          this.y += this.vy * deltaSeconds;
          // BOSSè§¦åº•ååå¼¹
          if (this.y + this.height >= canvasHeight) {
            this.y = canvasHeight - this.height;
            // ã€ä¼˜åŒ–ã€‘å¼¹è·³é€Ÿåº¦ä¸å±å¹•é«˜åº¦å…³è”
            this.vy = -(Math.random() * canvasHeight * 0.8 + canvasHeight * 0.5);
            // bounceTargetYè¶Šå°ä»£è¡¨BOSSåå¼¹åçš„é«˜åº¦è¶Šæ¥è¿‘ç”»é¢é¡¶éƒ¨ï¼Œ
            this.bounceTargetY = Math.random() * canvasHeight * bounceFactor - canvasHeight * 0.1;
            if (this.bounceTargetY < 0) {
              this.bounceTargetY = 0;
            }
          }
          if (this.vy < 0 && this.y <= this.bounceTargetY) {
            this.vy = 0;
          }
        }
      }

      // ç»˜åˆ¶BOSSå’Œè¡€é‡æ¡
      draw() {
        // ç»˜åˆ¶é˜´å½±
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(this.x + this.width / 2, this.y + this.height, this.width * 0.4, this.width * 0.2, 0, 0, Math.PI * 2);
        ctx.fill();
        // BOSSå—å‡»æ—¶çš„é—ªå…‰æ•ˆæœï¼ˆæš‚æ—¶å»æ‰ï¼‰
        if (bossFlashTimer > 0 && this.health > 0) {
          //ctx.filter = 'brightness(200%) saturate(0%)';
        }
        // æ ¹æ®æ”»å‡»çŠ¶æ€é€‰æ‹©å›¾ç‰‡
        let currentImage;
        if (this.attackState === 'raising') {
          currentImage = assetImages.boss3; // ä¸¾èµ·æ‹³å¤´
        } else if (this.attackState === 'punching') {
          currentImage = assetImages.boss4; // ç ¸ä¸‹æ‹³å¤´
        } else {
          // æ­£å¸¸çŠ¶æ€ä¸‹çš„åŠ¨ç”»åˆ‡æ¢
          currentImage = Math.floor(this.animFrame / 30) % 2 === 0 ? assetImages.boss1 : assetImages.boss2;
        }

        ctx.drawImage(currentImage, this.x, this.y, this.width, this.height);
        ctx.filter = 'none';

        // ç»˜åˆ¶BOSSè¡€é‡æ¡ï¼ˆæ— å°½æ¨¡å¼ä¸‹ä¸æ˜¾ç¤ºï¼‰
        if (isEndlessMode) {
          return;
        }
        const barWidth = canvasWidth * 0.6, barHeight = 20, barX = canvasWidth / 2 - barWidth / 2, barY = 10;
        ctx.fillStyle = '#555';
        ctx.fillRect(barX, barY, barWidth, barHeight);  // èƒŒæ™¯æ¡

        const hpPercent = this.health / this.maxHealth;
        // æ ¹æ®è¡€é‡ç™¾åˆ†æ¯”è®¾ç½®é¢œè‰²
        ctx.fillStyle = hpPercent > 0.5 ? 'green' : (hpPercent > 0.2 ? 'orange' : 'red');
        ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);  // è¡€é‡æ¡

        ctx.strokeStyle = 'white';
        ctx.strokeRect(barX, barY, barWidth, barHeight);  // è¾¹æ¡†

        // åœ¨è¡€æ¡ä¸­é—´æ˜¾ç¤ºè¡€é‡æ•°å­—
        ctx.font = 'bold 16px "Arial", sans-serif';
        ctx.fillStyle = '#ffffff';
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.textAlign = 'center';
        //ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
        // ctx.shadowOffsetX = 1;
        // ctx.shadowOffsetY = 1;
        // ctx.shadowBlur = 4;

        const healthText = `${this.health} / ${this.maxHealth}`;
        ctx.strokeText(healthText, canvasWidth / 2, barY + 15);
        ctx.fillText(healthText, canvasWidth / 2, barY + 15);
        // æ¸…é™¤é˜´å½±æ•ˆæœ
        //ctx.shadowColor = 'transparent';
        // ctx.shadowOffsetX = 0;
        // ctx.shadowOffsetY = 0;
        // ctx.shadowBlur = 0;
      }
    }

    // çˆ†ç‚¸æ•ˆæœç±»
    class Explosion {
      constructor(x, y) {
        this.x = x;  // çˆ†ç‚¸ä¸­å¿ƒXåæ ‡
        this.y = y;  // çˆ†ç‚¸ä¸­å¿ƒYåæ ‡
        this.particles = [];  // ç²’å­æ•°ç»„
        this.init();
      }

      // åˆå§‹åŒ–çˆ†ç‚¸ç²’å­
      init() {
        const particleCount = 8;  // ç²’å­æ•°é‡
        for (let i = 0; i < particleCount; i++) {
          const angle = Math.random() * Math.PI * 2;  // éšæœºè§’åº¦
          const speed = Math.random() * 3 + 1;  // éšæœºé€Ÿåº¦
          this.particles.push({
            x: this.x, y: this.y,  // åˆå§‹ä½ç½®
            vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,  // é€Ÿåº¦åˆ†é‡
            size: Math.random() * 8 + 4,  // ç²’å­å¤§å°
            life: Math.random() * 20 + 20,  // ç”Ÿå‘½å‘¨æœŸ
            opacity: 1,  // é€æ˜åº¦
            color: '#ff69b4'  // ç²’å­é¢œè‰²
          });
        }
      }

      // æ›´æ–°ç²’å­çŠ¶æ€
      update() {
        this.particles.forEach((p, index) => {
          p.x += p.vx;
          p.y += p.vy;  // æ›´æ–°ä½ç½®
          p.life--;  // å‡å°‘ç”Ÿå‘½å€¼
          p.opacity = p.life / 30;  // æ›´æ–°é€æ˜åº¦
          if (p.life <= 0) this.particles.splice(index, 1);  // ç§»é™¤æ­»äº¡ç²’å­
        });
      }

      // ç»˜åˆ¶çˆ†ç‚¸æ•ˆæœ
      draw() {
        this.particles.forEach(p => {
          ctx.save();
          ctx.globalAlpha = p.opacity;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
      }

      // æ£€æŸ¥çˆ†ç‚¸æ˜¯å¦ç»“æŸ
      isFinished() {
        return this.particles.length === 0;
      }
    }

    // é—ªå…‰æ•ˆæœç±»
    class FlashEffect {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.life = 15;
        this.maxLife = 15;
        this.images = [];
        this.angles = [];

        // éšæœºæ˜¾ç¤º1-2å¼ é—ªå…‰å›¾ç‰‡
        const count = Math.random() < 0.5 ? 1 : 2;
        for (let i = 0; i < count; i++) {
          this.images.push(Math.random() < 0.5 ? assetImages.flash1 : assetImages.flash2);
          this.angles.push(Math.random() * Math.PI * 2);
        }
      }

      update() {
        this.life--;
      }

      draw() {
        const alpha = this.life / this.maxLife;
        ctx.save();
        ctx.globalAlpha = alpha;

        for (let i = 0; i < this.images.length; i++) {
          ctx.save();
          const offsetX = i * 20 - 10;
          const offsetY = i * 15 - 7;
          ctx.translate(this.x + offsetX, this.y + offsetY);
          ctx.rotate(this.angles[i]);
          ctx.drawImage(this.images[i], -25, -25, 50, 50);
          ctx.restore();
        }

        ctx.restore();
      }

      isFinished() {
        return this.life <= 0;
      }
    }

    // åˆå§‹åŒ–æ¸¸æˆ
    function init() {
      resizeCanvas();  // è°ƒæ•´ç”»å¸ƒå°ºå¯¸
      player = new Player();  // åˆ›å»ºç©å®¶
      bullets = [];  // æ¸…ç©ºå­å¼¹æ•°ç»„
      bears = [];  // æ¸…ç©ºå°ç†Šæ•°ç»„
      explosions = [];  // æ¸…ç©ºçˆ†ç‚¸æ•°ç»„
      flashEffects = [];  // æ¸…ç©ºé—ªå…‰æ•ˆæœæ•°ç»„
      boss = null;  // é‡ç½®BOSS
      killCount = 0;  // é‡ç½®æ€»å‡»æ€æ•°
      killsSinceLastLife = 0;  // é‡ç½®å›è¡€è®¡æ•°å™¨
      comboCount = 0;  // é‡ç½®è¿å‡»æ•°
      maxComboCount = 0;  // é‡ç½®æœ€å¤§è¿å‡»æ•°
      escapedBearCount = 0;  // é‡ç½®é€ƒèµ°å°ç†Šæ•°
      deathCount = 0;  // é‡ç½®é˜µäº¡æ¬¡æ•°
      bearSpawnTimer = 0;  // é‡ç½®å°ç†Šç”Ÿæˆè®¡æ—¶å™¨
      bossSpawned = false;  // é‡ç½®BOSSç”Ÿæˆæ ‡å¿—
      playerInvulnerable = false;  // é‡ç½®æ— æ•ŒçŠ¶æ€
      invulnerabilityTimer = 0;  // é‡ç½®æ— æ•Œè®¡æ—¶å™¨
      gameState = 'playing';  // è®¾ç½®æ¸¸æˆçŠ¶æ€ä¸ºæ¸¸æˆä¸­
      gameStartTime = performance.now();  // è®°å½•æ¸¸æˆå¼€å§‹æ—¶é—´

      // æ ¹æ®éš¾åº¦è®¾ç½®å°ç†Šç”Ÿæˆé—´éš”ï¼Œé»˜è®¤ä¸­ç­‰ä¸º700
      if (currentDifficulty === 'easy') {
        bearSpawnInterval = 800;
      } else if (currentDifficulty === 'hard') {
        bearSpawnInterval = 600;
      }

      if (player) {
        player.defeatCharacters = [];  // æ¸…ç©ºdefeatè§’è‰²
        player.characters = [1];  // é‡ç½®è§’è‰²ç±»å‹æ•°ç»„
        player.deadCharacterType = 1;  // é‡ç½®æ­»äº¡è§’è‰²ç±»å‹
      }
    }

    // ç”Ÿæˆå°ç†Š
    function spawnBears() {
      const numColumns = 6;  // åˆ—æ•°
      const bearWidth = canvasWidth / 6;  // æ¯åˆ—å®½åº¦

      // æ ¹æ®éš¾åº¦è®¾ç½®å°ç†Šæ¯åˆ—ç”Ÿæˆæ¦‚ç‡ï¼Œé»˜è®¤65%æ¦‚ç‡ç”Ÿæˆï¼Œä¹Ÿå°±æ˜¯æ¯è¡Œ6*0.65=3.9ä¸ªç†Š
      let spawnProbability = 0.65;
      if (currentDifficulty === 'easy') {
        spawnProbability = 0.6;
      } else if (currentDifficulty === 'hard') {
        spawnProbability = 0.7;
      }

      for (let i = 0; i < numColumns; i++) {
        if (Math.random() < spawnProbability) {
          const x = i * bearWidth;  // è®¡ç®—Xåæ ‡
          const y = -bearWidth;  // ä»å±å¹•ä¸Šæ–¹å¼€å§‹
          let canSpawn = true;

          // æ£€æŸ¥æ˜¯å¦ä¸BOSSé‡å 
          if (boss && boss.y > -boss.height) {
            const bossLeft = boss.x;
            const bossRight = boss.x + boss.width;
            const bearLeft = x;
            const bearRight = x + bearWidth;
            if (!(bearRight <= bossLeft || bearLeft >= bossRight)) {
              canSpawn = false;  // ä¸BOSSé‡å ï¼Œä¸ç”Ÿæˆ
            }
          }

          if (canSpawn) {
            bears.push(new Bear(x, y));
          }
        }
      }
    }

    // å¤„ç†æ‰€æœ‰ç¢°æ’æ£€æµ‹
    function handleCollisions() {
      // å­å¼¹ä¸å°ç†Šçš„ç¢°æ’
      bullets.forEach(bullet => {
        if (bullet.markedForDeletion) return; // è·³è¿‡å·²æ ‡è®°çš„å­å¼¹
        bears.forEach(bear => {
          if (bear.markedForDeletion) return; // è·³è¿‡å·²æ ‡è®°çš„å°ç†Š
          if (isColliding(bullet, bear)) {
            flashEffects.push(new FlashEffect(bullet.x + bullet.width / 2, bullet.y + bullet.height / 2));
            bullet.markedForDeletion = true; // ã€ä¼˜åŒ–ã€‘æ ‡è®°å­å¼¹å¾…åˆ é™¤
            bear.health--;
            bear.flashTimer = 3;
            if (bear.health <= 0) {
              bear.markedForDeletion = true; // ã€ä¼˜åŒ–ã€‘æ ‡è®°å°ç†Šå¾…åˆ é™¤
              killCount++;
              killsSinceLastLife++;
              comboCount++;
              if (comboCount > maxComboCount) maxComboCount = comboCount;
              player.updateCharacterCount();
            }
          }
        });
      });

      // å­å¼¹ä¸BOSSçš„ç¢°æ’
      if (boss) {
        bullets.forEach(bullet => {
          if (bullet.markedForDeletion) return; // è·³è¿‡å·²æ ‡è®°çš„å­å¼¹
          if (isColliding(bullet, boss)) {
            flashEffects.push(new FlashEffect(bullet.x + bullet.width / 2, bullet.y + bullet.height / 2));
            bullet.markedForDeletion = true; // æ ‡è®°å­å¼¹å¾…åˆ é™¤
            //æ— å°½æ¨¡å¼ä¸‹BOSSä¸æ‰è¡€ ä¸èƒ½æ‰æˆè´Ÿæ•°
            if (!isEndlessMode && boss.health > 0) {
              boss.health--;
            }
            bossFlashTimer = 3;
            if (boss.health <= 0 && gameState === 'playing') {
              gameState = 'bossDying';
              bossDeathPosition = {x: boss.x, y: boss.y, width: boss.width, height: boss.height};
              screenFlashAlpha = 0.7;
              triggerScreenShake(15);
              setTimeout(() => gameOver(true), 400); // BOSSæ­»äº¡400æ¯«ç§’åæ¸¸æˆç»“æŸ
            }
          }
        });
      }

      // å°ç†Šä¸ç©å®¶çš„ç¢°æ’
      bears.forEach(bear => {
        if (bear.markedForDeletion) return;
        const totalWidth = player.width * player.characterCount;
        const startX = player.x - totalWidth / 2;

        for (let i = 0; i < player.characterCount; i++) {
          const charHitbox = {
            x: startX + i * player.width,
            y: player.y,
            width: player.width,
            height: player.height
          };

          if (isColliding(bear, charHitbox)) {
            bear.markedForDeletion = true;
            triggerScreenShake(5);
            checkDead(i);
            return;
          }
        }
      });

      // BOSSä¸ç©å®¶çš„ç¢°æ’ï¼ˆåœ¨æ— æ•Œæ—¶é—´å¤–ï¼‰
      if (boss && !playerInvulnerable) {
        const totalWidth = player.width * player.characterCount;
        const startX = player.x - totalWidth / 2;

        for (let i = 0; i < player.characterCount; i++) {
          const charHitbox = {
            x: startX + i * player.width,
            y: player.y,
            width: player.width,
            height: player.height
          };

          if (isColliding(boss, charHitbox)) {
            playerInvulnerable = true;
            // ç©å®¶æ— æ•Œæ—¶é—´1.8ç§’ï¼Œé¿å…é‡å¤å—åˆ°ä¼¤å®³
            invulnerabilityTimer = 1800;
            triggerScreenShake(8);
            checkDead(i);
            return;
          }
        }
      }
    }

    function checkDead(hitCharacterIndex) {
      deathCount++; // å¢åŠ é˜µäº¡æ¬¡æ•°
      if (player.characterCount > 1) {
        // è®¡ç®—è¢«å‡»ä¸­è§’è‰²çš„ä½ç½®
        const totalWidth = player.width * player.characterCount;
        const startX = player.x - totalWidth / 2;
        const hitCharacterX = startX + hitCharacterIndex * player.width + player.width / 2;
        const hitCharacterType = player.characters[hitCharacterIndex];

        // æ·»åŠ defeatè§’è‰²
        player.defeatCharacters.push({
          x: hitCharacterX,
          characterIndex: hitCharacterType,
          timer: 1200 // è§’è‰²è¢«å‡»è´¥1200æ¯«ç§’åæ¶ˆå¤±
        });

        // ä»è§’è‰²æ•°ç»„ä¸­ç§»é™¤è¢«å‡»ä¸­çš„è§’è‰²
        player.characters.splice(hitCharacterIndex, 1);
        player.characterCount--;  // å‡å°‘è§’è‰²æ•°é‡ï¼ˆç”Ÿå‘½ï¼‰
        killsSinceLastLife = 0;
      } else {
        // è®°å½•æœ€åä¸€ä¸ªè§’è‰²çš„ç±»å‹
        player.deadCharacterType = player.characters[hitCharacterIndex];
        player.isDead = true;  // è®¾ç½®ç©å®¶æ­»äº¡çŠ¶æ€
        setTimeout(() => gameOver(false), 400);  // ç©å®¶æ­»äº¡400æ¯«ç§’åæ¸¸æˆç»“æŸ
      }
    }

    // ç¢°æ’æ£€æµ‹å‡½æ•°ï¼ˆçŸ©å½¢ç¢°æ’ï¼‰
    function isColliding(rect1, rect2) {
      return rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.y + rect1.height > rect2.y;
    }

    // ç»˜åˆ¶é“è·¯ä¸­é—´çº¿
    function drawRoad(deltaTime) { // ã€ä¼˜åŒ–ã€‘æ¥æ”¶deltaTimeå‚æ•°
      ctx.fillStyle = '#fff';
      const lineWidth = 15, lineHeight = 80, lineGap = 60;
      // ã€ä¼˜åŒ–ã€‘é“è·¯æ»šåŠ¨é€Ÿåº¦ä¸å±å¹•é«˜åº¦å’Œæ—¶é—´å…³è”
      const roadSpeed = canvasHeight * 0.6;
      if (gameState === 'playing') {
        roadLineY += roadSpeed * (deltaTime / 1000);
      }
      if (roadLineY > lineHeight + lineGap) roadLineY = 0;

      for (let y = roadLineY - (lineHeight + lineGap); y < canvasHeight; y += lineHeight + lineGap) {
        ctx.fillRect(canvasWidth / 2 - lineWidth / 2, y, lineWidth, lineHeight);
      }
    }

    let lastTime = 0;  // ä¸Šä¸€å¸§æ—¶é—´

    // æ¸¸æˆä¸»å¾ªç¯
    function gameLoop(timestamp) {
      updateFPS(); // æ›´æ–° FPS æ˜¾ç¤º
      const deltaTime = timestamp - lastTime;  // è®¡ç®—å¸§é—´éš”
      lastTime = timestamp;

      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      drawRoad(deltaTime); // ç»˜åˆ¶é“è·¯

      // å°†æ‰€æœ‰â€œæ¸¸æˆè¿›è¡Œä¸­â€çš„é€»è¾‘ï¼ˆåŒ…æ‹¬å¯¹è±¡æ›´æ–°å’Œæ¸…ç†ï¼‰éƒ½æ”¾åœ¨è¿™ä¸ªä»£ç å—é‡Œ
      if (gameState === 'playing') {
        const gameTime = timestamp - gameStartTime; // è®¡ç®—æ¸¸æˆæ—¶é—´
        // æ›´æ–°æ‰€æœ‰æ¸¸æˆå¯¹è±¡
        bullets.forEach(bullet => bullet.update(deltaTime));
        bears.forEach(bear => bear.update(deltaTime));
        if (boss) {
          boss.update(deltaTime, gameTime);
        }
        if (player) {
          // æ›´æ–°ç©å®¶è§’è‰²æ‰€åœ¨ä½ç½®
          updatePlayerPosition(deltaTime);
          player.updateDefeatCharacters(deltaTime);
        }
        // æŒç»­å°„å‡»é€»è¾‘
        if (isShooting) {
          shootTimer += deltaTime;
          if (shootTimer >= shootInterval) {
            player.shoot();
            shootTimer = 0;
          }
        }
        // å°ç†Šç”Ÿæˆè®¡æ—¶å™¨
        bearSpawnTimer += deltaTime;
        if (bearSpawnTimer > bearSpawnInterval) {
          spawnBears();
          bearSpawnTimer = 0;
        }
        // æ¸¸æˆå¼€å§‹5ç§’åç”ŸæˆBOSS
        let bossBegan = 2500;
        if (currentDifficulty === 'easy') {
          bossBegan = 1000;
        } else if (currentDifficulty === 'hard') {
          bossBegan = 5000;
        }
        if (!bossSpawned && gameTime > bossBegan) {
          boss = new Boss();
          bossSpawned = true;
        }
        if (bossFlashTimer > 0) bossFlashTimer--;
        // æ›´æ–°ç©å®¶æ— æ•ŒçŠ¶æ€
        if (playerInvulnerable) {
          invulnerabilityTimer -= deltaTime;
          if (invulnerabilityTimer <= 0) {
            playerInvulnerable = false;
          }
        }

        handleCollisions(); // å¤„ç†ç¢°æ’
        // å°†å­å¼¹å’Œå°ç†Šæ•°ç»„çš„æ¸…ç†æ“ä½œç§»åˆ°è¿™é‡Œ
        // è¿™æ ·å½“æ¸¸æˆä¸å†æ˜¯'playing'çŠ¶æ€æ—¶ï¼Œå®ƒä»¬å°±ä¸ä¼šè¢«ç§»é™¤ï¼Œä»è€Œè¢«å®šæ ¼åœ¨å±å¹•ä¸Š
        bullets = bullets.filter(b => !b.markedForDeletion);
        bears = bears.filter(b => !b.markedForDeletion);
      }

      // BOSSæ­»äº¡æ—¶çš„è¿ç»­çˆ†ç‚¸æ•ˆæœ (è¿™ä¸ªé€»è¾‘ä¿æŒåœ¨å¤–ï¼Œå› ä¸ºå®ƒåœ¨ 'bossDying' çŠ¶æ€ä¸‹è¿è¡Œ)
      if (gameState === 'bossDying' && Math.random() < 0.8) {
        const x = bossDeathPosition.x + Math.random() * bossDeathPosition.width;
        const y = bossDeathPosition.y + Math.random() * bossDeathPosition.height;
        explosions.push(new Explosion(x, y));
        flashEffects.push(new FlashEffect(x, y));
      }

      // æ›´æ–°å¹¶è¿‡æ»¤ç‰¹æ•ˆ (ç‰¹æ•ˆçš„ç”Ÿå‘½å‘¨æœŸç‹¬ç«‹äºæ¸¸æˆçŠ¶æ€)
      flashEffects.forEach(flash => flash.update());
      explosions.forEach(exp => exp.update());
      flashEffects = flashEffects.filter(f => !f.isFinished());
      explosions = explosions.filter(e => !e.isFinished());

      // ç»˜åˆ¶æ‰€æœ‰æ¸¸æˆå¯¹è±¡ (ç»˜åˆ¶é€»è¾‘æ°¸è¿œåœ¨ä¸»å¹²ä¸Šï¼Œç¡®ä¿æ‰€æœ‰çŠ¶æ€éƒ½èƒ½æ­£ç¡®æ˜¾ç¤º)
      bullets.forEach(b => b.draw());
      bears.forEach(b => b.draw());
      if (boss) boss.draw();

      // æ— æ•ŒçŠ¶æ€ä¸‹ç©å®¶è§’è‰²é—ªçƒï¼Œæ³¨é‡Šæ‰ä¸‹é¢è¿™ä¸€è¡Œå°±ä»£è¡¨ä¸é—ªçƒ
      //if (!playerInvulnerable || Math.floor(invulnerabilityTimer / 100) % 2 === 0) {
      player.draw();
      // }

      explosions.forEach(e => e.draw());
      flashEffects.forEach(f => f.draw());

      // å±å¹•é—ªå…‰æ•ˆæœ
      if (screenFlashAlpha > 0) {
        ctx.fillStyle = `rgba(255, 255, 255, ${screenFlashAlpha})`;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        screenFlashAlpha -= 0.05;  // é€æ¸æ·¡åŒ–
      }
      // ç»˜åˆ¶UIä¿¡æ¯
      drawGameUI();
      // ç»§ç»­ä¸‹ä¸€å¸§ï¼ˆå¦‚æœæ¸¸æˆæœªç»“æŸï¼‰
      if (gameState !== 'over') gameLoopId = requestAnimationFrame(gameLoop);
    }

    // å¼€å§‹æ¸¸æˆ
    function startGame() {
      init();  // åˆå§‹åŒ–æ¸¸æˆ
      startScreen.classList.add('hidden');  // éšè—å¼€å§‹ç•Œé¢
      defeatScreen.classList.add('hidden');  // éšè—å¤±è´¥ç•Œé¢
      winScreen.classList.add('hidden');  // éšè—èƒœåˆ©ç•Œé¢

      // æ˜¾ç¤ºæ¸¸æˆä¸­çš„éŸ³ä¹æ§åˆ¶æŒ‰é’®
      document.getElementById('game-music-control').style.display = 'flex';

      // åˆ‡æ¢åˆ°æˆ˜æ–—éŸ³ä¹
      playMusic('battle');

      lastTime = performance.now();  // è®°å½•å¼€å§‹æ—¶é—´
      if (gameLoopId) cancelAnimationFrame(gameLoopId);  // å–æ¶ˆä¸Šä¸€ä¸ªæ¸¸æˆå¾ªç¯
      gameLoop(lastTime);  // å¼€å§‹æ¸¸æˆå¾ªç¯
    }

    // å›åˆ°é¦–é¡µ
    function backToHome() {
      init();
      gameState = 'over';  // è®¾ç½®æ¸¸æˆçŠ¶æ€ä¸ºç»“æŸ
      if (gameLoopId) cancelAnimationFrame(gameLoopId);  // åœæ­¢æ¸¸æˆå¾ªç¯

      // éšè—æ¸¸æˆä¸­çš„éŸ³ä¹æ§åˆ¶æŒ‰é’®
      document.getElementById('game-music-control').style.display = 'none';

      // åˆ‡æ¢åˆ°èœå•éŸ³ä¹
      playMusic('menu');

      startScreen.classList.remove('hidden');  // æ˜¾ç¤ºå¼€å§‹ç•Œé¢
      defeatScreen.classList.add('hidden');  // éšè—å¤±è´¥ç•Œé¢
      winScreen.classList.add('hidden');  // éšè—èƒœåˆ©ç•Œé¢
    }

    // ç»˜åˆ¶æ¸¸æˆUI
    function drawGameUI() {
      // è®¾ç½®å­—ä½“æ ·å¼
      ctx.font = 'bold ' + uiFont + 'px "Arial Black", "Helvetica", sans-serif';
      ctx.fillStyle = '#ffffff';
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 2;
      //è®¾ç½®é˜´å½±
      // ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
      // ctx.shadowOffsetX = 1;
      // ctx.shadowOffsetY = 1;
      // ctx.shadowBlur = 4;

      // ç»˜åˆ¶å·¦ä¸Šè§’ç”Ÿå‘½å€¼å’Œé˜µäº¡æ¬¡æ•°
      const iconSize = 24;
      ctx.textAlign = 'left';

      // ç¬¬ä¸€è¡Œï¼šç”Ÿå‘½å€¼ï¼ˆçº¢å¿ƒå›¾æ ‡ï¼‰
      ctx.fillStyle = '#ff69b4'; // ç²‰è‰²ï¼ˆä¸å¿ƒç¢å›¾æ ‡ä¿æŒä¸€è‡´ï¼‰
      ctx.strokeText('â¤ï¸', 10, 62); // çº¢å¿ƒemojiå›¾æ ‡
      ctx.fillText('â¤ï¸', 10, 62);
      ctx.fillStyle = '#ffffff'; // æ¢å¤ç™½è‰²
      ctx.strokeText(player.characterCount.toString(), 36 - uiAdjust, 62);
      ctx.fillText(player.characterCount.toString(), 36 - uiAdjust, 62);

      // ç¬¬äºŒè¡Œï¼šé˜µäº¡æ¬¡æ•°ï¼ˆå¿ƒç¢å›¾æ ‡ï¼‰
      ctx.fillStyle = '#ff69b4'; // ç²‰è‰²
      ctx.strokeText('ğŸ’”', 10, 92); // å¿ƒç¢å›¾æ ‡
      ctx.fillText('ğŸ’”', 10, 92);
      ctx.fillStyle = '#ffffff'; // æ¢å¤ç™½è‰²
      ctx.strokeText(deathCount.toString(), 36 - uiAdjust, 92);
      ctx.fillText(deathCount.toString(), 36 - uiAdjust, 92);

      // ç»˜åˆ¶å³ä¸Šè§’ç§¯åˆ†å›¾æ ‡å’Œæ•°å­—
      if (assetImages.scoreIcon) {
        ctx.drawImage(assetImages.scoreIcon, canvasWidth - 40, 45, iconSize, iconSize);

        ctx.textAlign = 'right';
        // æ˜¾ç¤ºæ ¼å¼ï¼šå‡»æ€æ•°-é€ƒèµ°æ•°ï¼ˆå¦‚æœæœ‰é€ƒèµ°å°ç†Šï¼‰
        const scoreText = escapedBearCount > 0 ? `${killCount}-${escapedBearCount}` : killCount.toString();
        ctx.strokeText(scoreText, canvasWidth - 55, 62);
        ctx.fillText(scoreText, canvasWidth - 55, 62);

        // ç»˜åˆ¶comboæ•°ï¼ˆç¬¬äºŒè¡Œï¼‰
        ctx.drawImage(assetImages.comboIcon, canvasWidth - 52, 75, 50, 22);
        ctx.strokeText(comboCount.toString(), canvasWidth - 55, 92);
        ctx.fillText(comboCount.toString(), canvasWidth - 55, 92);
      }

      // ç»˜åˆ¶æ¸¸æˆæ—¶é—´å’Œéš¾åº¦æ¨¡å¼ï¼ˆæ¸¸æˆä¸­å’Œç»“æŸæ—¶éƒ½æ˜¾ç¤ºï¼‰
      if (gameState === 'playing' || gameState === 'bossDying') {
        const barWidth = canvasWidth * 0.6;
        const barX = canvasWidth / 2 - barWidth / 2;
        ctx.font = 'bold ' + uiFont + ' "Arial", sans-serif';
        // æ¸¸æˆæ—¶é—´ï¼ˆè¡€æ¡ä½ç½®å·¦ä¾§ï¼‰
        const gameTime = performance.now() - gameStartTime;
        const timeText = formatGameTime(gameTime);
        ctx.textAlign = 'right';
        ctx.strokeText(timeText, barX - 15, 25);
        ctx.fillText(timeText, barX - 15, 25);

        // éš¾åº¦æ¨¡å¼ï¼ˆè¡€æ¡ä½ç½®å³ä¾§ï¼‰
        const texts = languages[currentLang];
        const modeText = texts[currentDifficulty].replace(texts.mode, '');
        ctx.textAlign = 'left';
        ctx.strokeText(modeText, barX + barWidth + 15, 25);
        ctx.fillText(modeText, barX + barWidth + 15, 25);
      }

      // æ¸…é™¤é˜´å½±æ•ˆæœ
      //ctx.shadowColor = 'transparent';
      // ctx.shadowOffsetX = 0;
      // ctx.shadowOffsetY = 0;
      // ctx.shadowBlur = 0;
    }

    // æ ¼å¼åŒ–æ¸¸æˆæ—¶é—´
    function formatGameTime(milliseconds) {
      const totalSeconds = Math.floor(milliseconds / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    // æ¸¸æˆç»“æŸ
    function gameOver(isWin) {
      //é¿å…é‡å¤æ‰§è¡Œ
      if (gameState == 'over') {
        return;
      }
      gameState = 'over';  // è®¾ç½®æ¸¸æˆçŠ¶æ€ä¸ºç»“æŸ
      cancelAnimationFrame(gameLoopId);  // åœæ­¢æ¸¸æˆå¾ªç¯
      const gameTime = performance.now() - gameStartTime;
      // éšè—æ¸¸æˆä¸­çš„éŸ³ä¹æ§åˆ¶æŒ‰é’®
      document.getElementById('game-music-control').style.display = 'none';
      // åˆ‡æ¢åˆ°ç»“æŸéŸ³ä¹
      playMusic('end');

      // è®¡ç®—æœ€ç»ˆå¾—åˆ†
      const killScore = Math.max(0, (killCount - escapedBearCount) * 20);
      const comboScore = maxComboCount * 20;
      const deathPenalty = deathCount * 20;
      const fullComboScore = (isWin && (maxComboCount == killCount)) ? maxComboCount * 10 : 0;
      const bossScore = boss ? (boss.maxHealth - boss.health) * 5 : 0;
      const finalScore = Math.max(0, killScore + bossScore + comboScore - deathPenalty + fullComboScore);
      //å‘é€æ¸¸æˆç»Ÿè®¡
      try {
        gameStat(currentStage, currentDifficulty, fps, isWin ? 1 : 0, Math.floor(gameTime / 1000),
          killCount, escapedBearCount, maxComboCount, deathCount, boss ? (boss.maxHealth - boss.health) : 0, finalScore);
      } catch (e) {
        //å¿½ç•¥æŠ¥é”™
      }
      // æ˜¾ç¤ºç»“ç®—åŠ¨ç”»
      showScoreAnimation(isWin, killScore, maxComboCount, finalScore, gameTime);
    }

    // ç»“ç®—åŠ¨ç”»å‡½æ•°
    function showScoreAnimation(isWin, killScore, maxComboCount, finalScore, gameTime) {
      const targetElement = isWin ? document.getElementById('game-time-win') : document.getElementById('game-time-defeat');
      const targetScreen = isWin ? winScreen : defeatScreen;
      const texts = languages[currentLang];

      // æ˜¾ç¤ºå¯¹åº”ç•Œé¢
      targetScreen.classList.remove('hidden');


      const timeText = `${texts.gameTime}: ${formatGameTime(gameTime)}`;

      let killScoreText = '';
      let comboScoreText = '';
      let finalScoreText = '';

      const updateDisplay = () => {
        targetElement.innerHTML = `${timeText}<br>${killScoreText || '&nbsp;'}<br>${comboScoreText || '&nbsp;'}<br>${finalScoreText || '&nbsp;'}`;
      };

      const animateLine = (targetValue, label, callback) => {
        const duration = 1500;
        const frameRate = 60;
        const totalFrames = (duration / 1000) * frameRate;
        let frame = 0;

        const animate = () => {
          frame++;
          const progress = frame / totalFrames;
          const easeProgress = 1 - Math.pow(1 - progress, 3);
          const currentValue = Math.floor(targetValue * easeProgress);

          if (label === texts.killScore) {
            killScoreText = label + ':  ' + currentValue;
          } else if (label === texts.maxCombo) {
            comboScoreText = label + ':  ' + currentValue;
          } else if (label === texts.totalScore) {
            finalScoreText = label + ':  ' + currentValue;
          }

          updateDisplay();

          if (frame < totalFrames) {
            requestAnimationFrame(animate);
          } else {
            setTimeout(callback, 100);
          }
        };
        animate();
      };

      // åˆå§‹æ˜¾ç¤ºæ‰€æœ‰4è¡Œå ä½
      killScoreText = '';
      comboScoreText = '';
      finalScoreText = '';
      updateDisplay();

      setTimeout(() => {
        animateLine(killScore, texts.killScore, () => {
          animateLine(maxComboCount, texts.maxCombo, () => {
            animateLine(finalScore, texts.totalScore, () => {
            });
          });
        });
      }, 300);
    }

    // è°ƒæ•´ç”»å¸ƒå°ºå¯¸
    function resizeCanvas() {
      const rect = container.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      canvasWidth = canvas.width;
      canvasHeight = canvas.height;
      if (player) {
        player.width = canvasWidth / 7;
        player.height = player.width * 1.2;
      }
      if (canvasWidth <= 390) {
        uiFont = 12;
        uiAdjust = 5;
      } else if (canvasWidth <= 450) {
        uiFont = 14;
        uiAdjust = 2;
      }
    }

    window.addEventListener('resize', resizeCanvas);  // ç›‘å¬çª—å£å¤§å°å˜åŒ–

    // å®šä¹‰ä¸€ä¸ªç›®æ ‡ä½ç½®çš„å…¨å±€å˜é‡ï¼Œæ–¹ä¾¿ç©å®¶è§’è‰²ä½ç½®æ›´æ–°å‡½æ•°é‡Œä½¿ç”¨
    let targetPos = {x: player ? player.x : 0, y: player ? player.y : 0};

    // è·å–é¼ æ ‡ä½ç½®
    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
      return {x: evt.clientX - rect.left, y: evt.clientY - rect.top};
    }

    // è·å–è§¦æ‘¸ä½ç½®
    function getTouchPos(evt) {
      const rect = canvas.getBoundingClientRect();
      return {x: evt.touches[0].clientX - rect.left, y: evt.touches[0].clientY - rect.top};
    }

    // é¼ æ ‡æŒ‰ä¸‹æˆ–è§¦æ‘¸å¼€å§‹ å¼€å§‹å°„å‡»
    function handleInputStart(x, y) {
      isShooting = true;
      shootTimer = shootInterval; // ç«‹å³å°„å‡»ç¬¬ä¸€å‘

    }

    // é¼ æ ‡ç§»åŠ¨æˆ–è§¦æ‘¸æ»‘åŠ¨ è§’è‰²ç›®æ ‡ä½ç½®æ›´æ–°
    function handleInputMove(x, y) {
      targetPos.x = x;
      targetPos.y = y;
    }

    // é¼ æ ‡æ¾å¼€/ç¦»å¼€æˆ–è§¦æ‘¸ç»“æŸ åœæ­¢å°„å‡»
    function handleInputEnd() {
      isShooting = false;
      shootTimer = 0;
    }

    // ç©å®¶ä½ç½®æ›´æ–°å‡½æ•°
    function updatePlayerPosition(deltaTime) {
      // ä¸‹é¢ä»£ç çš„ä½œç”¨æ˜¯è®©ç©å®¶è§’è‰²å¹³æ»‘ç§»åŠ¨ï¼Œä»è€Œä¿®å¤ç§»åŠ¨ç«¯ç‚¹å‡»ä»»æ„ä½ç½®ä¼šç¬ç§»è¿‡å»ï¼Œä¸ä¼šæ¥è§¦åˆ°ç§»åŠ¨è·¯çº¿ä¸Šä»»ä½•ç‰©ä½“çš„bug
      // speedæ•°å€¼è¶Šå¤§ï¼Œè§’è‰²ç§»åŠ¨è¶Šæ¥è¿‘çœŸå®çš„éšé¼ æ ‡ç§»åŠ¨/ç§»åŠ¨ç«¯ç¬ç§»ï¼Œspeedæ•°å€¼è¶Šå°ï¼Œè§’è‰²ç§»åŠ¨çš„æ»åæ€§è¶Šå¤§
      const speed = 2400;
      const dx = targetPos.x - player.x;
      const dy = targetPos.y - player.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance > 1) {
        const moveDist = Math.min(speed * deltaTime / 1000, distance); // æ³¨æ„ deltaTime å•ä½ ms
        player.x += dx / distance * moveDist;
        player.y += dy / distance * moveDist;
      }

      // ä¸‹é¢ä¸‰è¡Œä»£ç ä½œç”¨æ˜¯é¿å…è§’è‰²ç§»åŠ¨ä½ç½®è¶…å‡ºè¾¹ç•Œ
      const totalWidth = player.width * player.characterCount;
      player.x = Math.max(totalWidth / 2, Math.min(canvasWidth - totalWidth / 2, player.x));
      player.y = Math.max(0, Math.min(canvasHeight - player.height, player.y));
    }

    // é¼ æ ‡æŒ‰ä¸‹
    container.addEventListener('mousedown', e => {
      const pos = getMousePos(e);
      handleInputStart(pos.x, pos.y);
    });

    //é¼ æ ‡ç§»åŠ¨
    container.addEventListener('mousemove', e => {
      const pos = getMousePos(e);
      handleInputMove(pos.x, pos.y);
    });

    //é¼ æ ‡æ¾å¼€æŒ‰é’®
    container.addEventListener('mouseup', handleInputEnd);

    // å¦‚æœå¸Œæœ›é¼ æ ‡ç§»åˆ°ç”»å¸ƒèŒƒå›´ä»¥å¤–ä¾ç„¶ä¿æŒå°„å‡»ï¼Œå°±æ³¨é‡Šä¸‹é¢è¿™è¡Œ
    // container.addEventListener('mouseleave', handleInputEnd);

    // è§¦æ‘¸å¼€å§‹ ï¼ˆæ‰‹æŒ‡é¦–æ¬¡è§¦ç¢°å±å¹•ï¼‰
    container.addEventListener('touchstart', e => {
      // é˜»æ­¢åœ¨æŒ‰é’®ç­‰UIå…ƒç´ ä¸Šçš„é»˜è®¤è¡Œä¸º
      if (e.target.tagName !== 'CANVAS') return;
      e.preventDefault();
      const pos = getTouchPos(e);
      handleInputStart(pos.x, pos.y);
    }, {passive: false});

    // è§¦æ‘¸ç§»åŠ¨ ï¼ˆæ‰‹æŒ‡åœ¨å±å¹•ä¸Šæ»‘åŠ¨æ—¶è¿ç»­è§¦å‘ï¼‰
    container.addEventListener('touchmove', e => {
      if (e.target.tagName !== 'CANVAS') return;
      e.preventDefault();
      const pos = getTouchPos(e);
      handleInputMove(pos.x, pos.y);
    }, {passive: false});

    // è§¦æ‘¸ç»“æŸ (æ‰‹æŒ‡ç¦»å¼€å±å¹•æ—¶è§¦å‘)
    container.addEventListener('touchend', e => {
      if (e.target.tagName !== 'CANVAS') return;
      e.preventDefault();
      handleInputEnd();
    }, {passive: false});

    // è§¦æ‘¸å–æ¶ˆ (ç³»ç»Ÿå–æ¶ˆè§¦æ§ï¼Œä¾‹å¦‚æ¥ç”µå¼¹çª—å‡ºç°)
    container.addEventListener('touchcancel', e => {
      if (e.target.tagName !== 'CANVAS') return;
      e.preventDefault();
      handleInputEnd();
    }, {passive: false});


    // å±å¹•éœ‡åŠ¨æ•ˆæœå‡½æ•°
    function triggerScreenShake(intensity) {
      container.style.animation = `shake ${0.3}s`;  // è®¾ç½®éœ‡åŠ¨åŠ¨ç”»

      // å®šä¹‰éœ‡åŠ¨å…³é”®å¸§
      const keyframes = `@keyframes shake {
            10%, 90% { transform: translate3d(${-intensity / 4}px, 0, 0); }
            20%, 80% { transform: translate3d(${intensity / 2}px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(${-intensity}px, 0, 0); }
            40%, 60% { transform: translate3d(${intensity}px, 0, 0); }
        }`;

      // ä½¿ç”¨åŠ¨æ€æ ·å¼è¡¨é¿å…é‡å¤æ·»åŠ å…³é”®å¸§
      if (!document.getElementById('shake-style')) {
        const style = document.createElement('style');
        style.id = 'shake-style';
        document.head.appendChild(style);
      }
      document.getElementById('shake-style').innerHTML = keyframes;

      // 0.2ç§’åæ¸…é™¤éœ‡åŠ¨æ•ˆæœ
      setTimeout(() => container.style.animation = '', 200);
    }

    document.addEventListener('DOMContentLoaded', () => {
      // è®¾ç½®éšæœºå¤´å›¾
      setRandomHeaderImage();
      // åˆ›å»ºéŸ³ä¹
      createMusic();
      // åˆå§‹åŒ–è¯­è¨€
      setLanguage();
      initFPS();
      // å›¾ç‰‡èµ„æº
      loadData();
      // ç”»å¸ƒå°ºå¯¸
      resizeCanvas();
      sendStat();
    });
  })();
</script>

</body>
</html>
