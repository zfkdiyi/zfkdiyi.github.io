<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>音符射手 元祖Bang Dram</title>
  <style>
    :root {
      --primary-color: #ff69b4; /* Hot Pink */
      --secondary-color: #9370db; /* Medium Purple */
      --text-color: #ffffff;
      --shadow-color: rgba(0, 0, 0, 0.5);
    }

    body {
      margin: 0;
      padding: 0;
      background-color: #333;
      color: var(--text-color);
      font-family: "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100dvh;
      overflow: hidden;
    }

    #game-container {
      position: relative;
      background-color: #6c757d;

      /* 保持 9:16 比例，最大化铺满 */
      width: 100vw;
      height: 100dvh;
      aspect-ratio: 9 / 16;

      /* 限制缩放，保证不会超出屏幕 */
      max-width: 500px;
      max-height: 100dvh;

      /* 居中显示，超出部分自动裁切 */
      object-fit: contain;
      overflow: hidden;

      box-shadow: 0 0 20px var(--shadow-color);
    }

    #game-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #707070; /* Road color */
    }

    .start-adjust {
      justify-content: flex-start !important;
    }

    .game-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background-color: rgba(0, 0, 0, 0.3);
      text-align: center;
      z-index: 10;
      transition: opacity 0.5s ease;
      padding-top: 0;
    }

    .game-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .overlay-title {
      margin: 15px 0px;
      font-size: 2rem;
      font-weight: bold;
      text-shadow: 0 0 10px var(--primary-color), 0 0 20px var(--primary-color);
      animation: pulse 1.5s infinite;
      @media (max-width: 500px) {
        font-size: 1.8rem;
      }
      @media (max-width: 375px) {
        font-size: 1.6rem;
        margin: 10px 0px;
      }
    }

    .overlay-text {
      font-size: 22px; /* 略大一点 */
      font-weight: 600; /* 稍微加粗 */
      color: #ffffff; /* 白色 */
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5), 0 0 6px rgba(255, 105, 180, 0.6); /* 阴影 + 粉色光晕 */
      margin: 10px 0;
      line-height: 1.4;
      @media (max-width: 450px) {
        font-size: 18px;
        margin: 8px 0;
      }
    }

    .start-button {
      margin: 15px 0px;
      padding: 10px 20px;
      font-size: 1.3rem;
      font-weight: bold;
      color: var(--secondary-color);
      background-color: var(--text-color);
      border: none;
      border-radius: 20px;
      cursor: pointer;
      box-shadow: 0 5px 15px var(--shadow-color);
      transition: transform 0.2s, box-shadow 0.2s;
      @media (max-width: 400px) {
        padding: 8px 16px;
        font-size: 1.2rem;
        margin: 12px 0px;
      }
    }

    .start-button:hover {
      transform: scale(1.1);
      box-shadow: 0 8px 25px var(--shadow-color);
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.05);
      }
      100% {
        transform: scale(1);
      }
    }

    .difficulty-selector,
    .language-selector {
      display: flex;
      gap: 10px;
      margin: 10px 0;
      transition: opacity 0.3s ease;
      @media (max-width: 450px) {
        margin: 5px 0;
      }
    }

    .difficulty-selector.hidden,
    .language-selector.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .contact-btn,
    .difficulty-btn,
    .lang-btn {
      padding: 8px 12px;
      font-size: 16px;
      color: var(--text-color);
      background-color: rgba(0, 0, 0, 0.5);
      border: 2px solid transparent;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.2s;
      @media (max-width: 450px) {
        padding: 4px 8px;
        font-size: 14px;
      }
    }

    .contact-btn:hover,
    .difficulty-btn:hover,
    .lang-btn:hover {
      background-color: rgba(255, 105, 180, 0.3);
    }

    .contact-btn.active,
    .difficulty-btn.active,
    .lang-btn.active {
      border-color: var(--primary-color);
      background-color: rgba(255, 105, 180, 0.5);
    }

    .version-info {
      margin-top: 40px;
      font-size: 16px;
      color: rgba(255, 255, 255, 0.7);
      text-align: center;
      line-height: 1.8;
      @media (max-width: 500px) {
        margin-top: 30px;
      }
      @media (max-width: 400px) {
        margin-top: 20px;
        font-size: 14px;
      }
    }

    .github-btn {
      margin-top: 10px;
      color: rgba(255, 255, 255, 0.7);
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 5px;
      transition: color 0.2s;
      position: relative;
      z-index: 1000;
      cursor: pointer;
    }

    .github-btn:hover {
      color: #ff69b4;
    }

    #fps-display {
      position: absolute;
      bottom: 5px;
      left: 5px;
      color: #0f0;
      font-size: 15px;
      font-weight: bold;
      text-shadow: 0 0 3px #000;
      z-index: 20;
      line-height: 1.2;
    }

    /* 联系作者部分 */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.4);
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background-color: #fff;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
      width: 90%;
      max-width: 400px;
      text-align: left;
    }

    .modal-content h3 {
      margin-top: 0;
      font-size: 1.1rem;
      color: #333;
    }

    .modal-content textarea {
      width: 100%;
      height: 100px;
      margin: 10px 0;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #ccc;
      resize: none;
      font-size: 0.95rem;
      box-sizing: border-box;
    }

    .modal-actions {
      text-align: right;
    }

    .modal-actions button {
      margin-left: 10px;
      padding: 6px 12px;
      border: none;
      border-radius: 6px;
      background-color: #4caf50;
      color: #fff;
      cursor: pointer;
      font-size: 0.95rem;
      transition: background-color 0.3s ease;
    }

    .modal-actions button:hover {
      background-color: #45a049;
    }

    .modal-actions button#cancel-btn {
      background-color: #aaa;
    }

    .modal-actions button#cancel-btn:hover {
      background-color: #888;
    }

    .close {
      float: right;
      font-size: 1.3rem;
      cursor: pointer;
    }
  </style>
</head>
<body>

<div id="game-container">
  <canvas id="game-canvas"></canvas>
  <div id="fps-display">
    <div id="mode-display"></div>
    <div>FPS: 0</div>
  </div>

  <div id="start-screen" class="game-overlay start-adjust">
    <img
      src="https://anime.bang-dream.com/bandorichan/wordpress/wp-content/uploads/2025/09/25171503/2025_BGDC_header_01-1024x341.jpg"
      alt="Header" style="width: 100%; position: absolute; top: 0; left: 0; z-index: -1;">
    <div style="display: flex; flex-direction: column; align-items: center; margin-top: 20vh;">
      <h1 class="overlay-title" data-text="title">音符射手</h1>
      <p class="overlay-text" data-text="instructions">移动鼠标或手指来控制角色<br>按住屏幕持续发射音符！</p>
      <div class="difficulty-selector">
        <button class="difficulty-btn" data-difficulty="easy" data-text="easy">简单</button>
        <button class="difficulty-btn" data-difficulty="normal" data-text="normal">普通</button>
        <button class="difficulty-btn" data-difficulty="hard" data-text="hard">困难</button>
        <button class="difficulty-btn" data-difficulty="endless" data-text="endless">无尽模式</button>
      </div>
      <button id="start-button" class="start-button" data-text="startGame">开始游戏</button>
      <div id="language-selector" class="language-selector">
        <button class="lang-btn" data-lang="zh">中文</button>
        <button class="lang-btn" data-lang="en">English</button>
        <button class="lang-btn" data-lang="ja">日本語</button>
        <button class="contact-btn" data-text="contact" id="contact-btn">联系作者</button>
      </div>
    </div>
    <div id="contact-modal" class="modal">
      <div class="modal-content">
        <span class="close">&times;</span>
        <h3 data-text="contact">联系作者</h3>
        <textarea id="contact-text" data-placeholder="contactHolder"
                  placeholder="请输入内容（不超过100字 如果你希望收到作者回复，记得留下邮箱地址）"
                  maxlength="100"></textarea>
        <div class="modal-actions">
          <button id="send-btn" data-text="submit">提交</button>
          <button id="cancel-btn" data-text="close">关闭</button>
        </div>
      </div>
    </div>
    <div class="version-info">
      <div><span data-text="version">版本</span>：0.3</div>
      <div><span data-text="updateTime">更新时间</span>：2025-10-05</div>
      <div>
        <a href="https://github.com/zfkdiyi/bangdream" id="github-button" class="github-btn">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path
              d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
          </svg>
          GitHub
        </a>
      </div>
      <div id="online-count"></div>
    </div>
  </div>

  <div id="defeat-screen" class="game-overlay hidden">
    <div style="display: flex; flex-direction: column; align-items: center;">
      <p id="game-time-defeat" class="overlay-text"></p>
      <img id="defeat-image" src="img/defeat.png" alt="DEFEAT"
           style="max-width: 80%; max-height: 60%; object-fit: contain;">
      <p class="overlay-text" data-text="defeatMessage">不要灰心，再来一次！</p>
      <button id="restart-button-defeat" class="start-button" data-text="retry">重试</button>
      <button id="home-button-defeat" class="start-button" data-text="backToHome">回到首页</button>
    </div>
  </div>

  <div id="win-screen" class="game-overlay hidden">
    <div style="display: flex; flex-direction: column; align-items: center;">
      <p id="game-time-win" class="overlay-text"></p>
      <img id="win-image" src="img/win.png" alt="YOU WIN" style="max-width: 80%; max-height: 60%; object-fit: contain;">
      <p class="overlay-text" data-text="winMessage">闪闪发光，心动不已！</p>
      <button id="restart-button-win" class="start-button" data-text="playAgain">再玩一次</button>
      <button id="home-button-win" class="start-button" data-text="backToHome">回到首页</button>
    </div>
  </div>
</div>

<script>
  (function () {
    let currentLang = 'zh';
    const languages = {
      zh: {
        title: '元祖！BanG Dream酱<br>音符射手',
        instructions: '移动鼠标或手指来控制角色<br>按住屏幕持续发射音符！',
        startGame: '开始游戏',
        defeatMessage: '不要灰心，再来一次！',
        retry: '重试一次',
        winMessage: '闪闪发光 心动不已！',
        playAgain: '再玩一次',
        backToHome: '回到首页',
        lives: '生命数',
        score: '积分',
        version: '版本',
        updateTime: '更新时间',
        contact: '联系作者',
        submit: '提交',
        close: '关闭',
        contactHolder: '请输入内容（不超过100字 如果你希望收到作者回复，记得留下邮箱地址）',
        easy: '容易',
        normal: '中等',
        hard: '困难',
        endless: '无尽模式',
        gameTime: '游戏时间',
        mode: '模式'
      },
      en: {
        title: 'GANSO! BanG Dream Chan<br>Note Shooter',
        instructions: 'Move mouse or finger to control character<br>Hold screen to shoot notes continuously!',
        startGame: 'Start Game',
        defeatMessage: 'Don\'t give up, try again!',
        retry: 'Retry',
        winMessage: 'KIRAKIRA DOKIDOKI!',
        playAgain: 'Play Again',
        backToHome: 'Back to Home',
        lives: 'Lives',
        score: 'Score',
        version: 'Version',
        updateTime: 'Update time',
        contact: 'Contact Me',
        submit: 'Submit',
        close: 'Close',
        contactHolder: "Please enter your message (up to 100 characters). If you’d like a reply, don’t forget to leave your email address.",
        easy: 'Easy',
        normal: 'Normal',
        hard: 'Hard',
        endless: 'Endless',
        gameTime: 'Game Time',
        mode: 'Mode',
        },
      ja: {
        title: '「元祖！バンドリちゃん」<br>ノートシューター',
        instructions: 'マウスや指で キャラクターを操作<br>画面を押し続けて ノートを連射！',
        startGame: 'ゲーム開始',
        defeatMessage: '諦めないで、もう一度！',
        retry: 'リトライ',
        winMessage: 'キラキラドキドキ！',
        playAgain: 'もう一度',
        backToHome: 'ホームに戻る',
        lives: 'ライフ',
        score: 'ポイント',
        version: 'バージョン',
        updateTime: '更新日時',
        contact: 'お問い合わせ',
        submit: '送信',
        close: '閉じる',
        contactHolder: "内容を入力してください（100文字以内）。返信をご希望の方は、メールアドレスを忘れずにご記入ください。",
        easy: '簡単',
        normal: '普通',
        hard: '難しい',
        endless: '無限モード',
        gameTime: 'ゲーム時間',
        mode: 'モード'
      }
    };
    // 自动检测浏览器语言
    const detectLanguage = () => {
      const lang = (navigator.language || navigator.userLanguage || 'en').toLowerCase();
      if (lang.startsWith('zh')) return 'zh';
      if (lang.startsWith('ja')) return 'ja';
      return 'en';
    };
    // 更新语言内容
    const updateLanguage = (lang) => {
      const texts = languages[lang] || languages.en;
      // 更新文字内容
      document.querySelectorAll('[data-text]').forEach(el => {
        const key = el.dataset.text;
        if (texts[key]) el.innerHTML = texts[key];
      });
      // 更新 placeholder
      document.querySelectorAll('[data-placeholder]').forEach(el => {
        const key = el.dataset.placeholder;
        if (texts[key]) el.placeholder = texts[key];
      });
      // 更新页面标题 (用正则替换掉所有<br>换行符）
      document.title = texts.title.replace(/<br\s*\/?>/g, ' ');
      // 更新语言按钮状态
      document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.lang === lang);
      });
    };
    // 初始化
    document.addEventListener('DOMContentLoaded', () => {
      currentLang = detectLanguage();
      updateLanguage(currentLang);
      updateModeDisplay();
      // 语言切换按钮监听
      document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          currentLang = btn.dataset.lang;
          updateLanguage(currentLang);
          updateModeDisplay();
        });
      });
    });
    // 联系作者弹窗逻辑
    const contactBtn = document.getElementById('contact-btn');
    const modal = document.getElementById('contact-modal');
    const closeBtn = modal.querySelector('.close');
    const cancelBtn = document.getElementById('cancel-btn');
    const sendBtn = document.getElementById('send-btn');
    const textarea = document.getElementById('contact-text');
    contactBtn.onclick = () => {
      modal.style.display = 'flex';
    };
    closeBtn.onclick = cancelBtn.onclick = () => {
      modal.style.display = 'none';
      textarea.value = '';
    };
    sendBtn.onclick = async () => {
      const text = textarea.value.trim();
      if (!text) {
        alert('请输入内容');
        return;
      }
      try {
        const response = await fetch('https://badmintonranks.com/prod-api/bilibiliContact', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: text
        });
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        const data = await response.json();
        if (data.code == 427) {
          alert('请勿频繁提交');
          return;
        }
        alert('已成功提交！');
        modal.style.display = 'none';
        textarea.value = '';
      } catch (error) {
        console.error(error);
        alert('提交失败，请稍后重试');
      }
    };
    // FPS和模式显示
    const fpsDisplay = document.getElementById('fps-display');
    const modeDisplay = document.getElementById('mode-display');
    let lastTimes = performance.now();
    let frames = 0;
    let fps = 0;
    function updateFPS() {
      const now = performance.now();
      frames++;
      if (now - lastTimes >= 1000) { // 每秒更新一次
        fps = frames;
        frames = 0;
        lastTimes = now;
        fpsDisplay.children[1].textContent = 'FPS: ' + fps;
      }
    }
    function updateModeDisplay() {
      const texts = languages[currentLang] || languages.en;
      modeDisplay.textContent = texts.mode + ': ' + texts[currentDifficulty].replace(texts.mode, '');
    }
    //获取在线人数
    async function sendStat() {
      let from = document.referrer;
      let width = window.outerWidth;
      let height = window.window.outerHeight;
      const res = await fetch('https://badmintonranks.com/prod-api/openStat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'from': from,
          'width': width,
          'height': height
        },
      });
      const data = await res.json();
      if (data.online !== undefined) {
        document.getElementById('online-count').textContent = `Online: ${data.online}`;
      }
    }
    //游戏难度和模式选择
    let currentDifficulty = 'normal';
    let gameStartTime = 0;
    let isEndlessMode = false;
    // 更新难度按钮被选中的状态
    function updateDifficultyButtons() {
      document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.classList.toggle('active', btn.getAttribute('data-difficulty') === currentDifficulty);
      });
    }
    // 初始化难度按钮状态
    updateDifficultyButtons();
    // 难度按钮点击事件
    document.querySelectorAll('.difficulty-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        currentDifficulty = btn.getAttribute('data-difficulty');
        isEndlessMode = currentDifficulty === 'endless';
        updateDifficultyButtons();
        updateModeDisplay();
      });
    });

    // 获取画布和容器元素
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('game-container');

    // 获取游戏界面元素
    const startScreen = document.getElementById('start-screen');
    const defeatScreen = document.getElementById('defeat-screen');
    const winScreen = document.getElementById('win-screen');

    const startButton = document.getElementById('start-button');
    const restartButtonDefeat = document.getElementById('restart-button-defeat');
    const restartButtonWin = document.getElementById('restart-button-win');
    const homeButtonDefeat = document.getElementById('home-button-defeat');
    const homeButtonWin = document.getElementById('home-button-win');
    startButton.addEventListener('click', startGame);// 开始游戏按钮
    restartButtonDefeat.addEventListener('click', startGame);// 失败重试按钮
    restartButtonWin.addEventListener('click', startGame);// 胜利重玩按钮
    homeButtonDefeat.addEventListener('click', backToHome);// 失败回到首页按钮
    homeButtonWin.addEventListener('click', backToHome);// 胜利回到首页按钮


    // 游戏基础变量
    let canvasWidth, canvasHeight;  // 画布尺寸
    let player, bullets, bears, boss, explosions;  // 游戏对象
    let bearSpawnTimer = 0;  // 小熊生成计时器
    let bearSpawnInterval = 700;  // 小熊生成间隔（毫秒）
    let killCount = 0;  // 总击杀数
    let killsSinceLastLife = 0;  // 自上次获得生命以来的击杀数
    let bossSpawned = false;  // BOSS是否已生成
    let gameLoopId;  // 游戏循环ID
    let roadLineY = -100;  // 道路线条Y坐标
    let gameState;  // 游戏状态
    let bossDeathPosition;  // BOSS死亡位置
    let screenFlashAlpha = 0;  // 屏幕闪光透明度
    let bossFlashTimer = 0;  // BOSS受击闪光计时器
    let playerInvulnerable = false;  // 玩家无敌状态
    let invulnerabilityTimer = 0;  // 无敌时间计时器
    let flashEffects = [];  // 闪光效果数组
    let isShooting = false;  // 是否正在射击
    let shootTimer = 0;  // 射击计时器
    let shootInterval = 80;  // 射击间隔（毫秒）越小子弹发射越密集，火力更强

    // 游戏资源定义
    const assets = {
      player1: 'img/player1.png',
      player2: 'img/player2.png',
      player3: 'img/player3.png',
      player4: 'img/player4.png',
      player5: 'img/player5.png',
      player6: 'img/player6.png',
      bear1: 'img/kuma1.png',
      bear2: 'img/kuma2.png',
      boss1: 'img/kkr1.png',
      boss2: 'img/kkr2.png',
      boss3: 'img/kkr3.png',
      boss4: 'img/kkr4.png',
      bullet1: 'img/bullet1.png',
      bullet2: 'img/bullet2.png',
      bullet3: 'img/bullet3.png',
      flash1: 'img/flash1.png',
      flash2: 'img/flash2.png',
      defeat1: 'img/defeat1.png',
      defeat2: 'img/defeat2.png',
      defeat3: 'img/defeat3.png'
    };

    const assetImages = {};  // 存储加载后的图像对象
    // 加载游戏资源
    function loadAssets(callback) {
      let loadedCount = 0;
      const assetKeys = Object.keys(assets);
      assetKeys.forEach(key => {
        assetImages[key] = new Image();
        assetImages[key].src = assets[key];
        assetImages[key].onload = () => {
          if (++loadedCount === assetKeys.length) callback();
        };
      });
    }
    // 玩家类
    class Player {
      constructor() {
        this.width = canvasWidth / 7;  // 单个角色宽度
        this.height = this.width * 1.2;  // 角色高度
        this.x = canvasWidth / 2;  // X坐标（中心点）
        this.y = canvasHeight - this.height;  // Y坐标（底部）
        this.characterCount = 1;  // 角色数量（生命数）
        this.animFrame = 0;  // 动画帧计数器
        this.isDead = false;  // 死亡状态
        this.defeatCharacters = [];  // 处于defeat状态的角色
        this.characters = [1];  // 存储每个角色的类型编号
        this.deadCharacterType = 1;  // 最后一个死亡角色的类型
      }

      // 绘制玩家角色
      draw() {
        this.animFrame++;

        if (this.isDead) {
          // 如果是死亡状态，按defeat图片的真实宽高比进行绘制
          const currentImage = assetImages[`defeat${this.deadCharacterType}`];
          const aspectRatio = currentImage.naturalWidth / currentImage.naturalHeight;
          const defeatWidth = this.height * 1.2;
          const defeatHeight = defeatWidth / aspectRatio;
          const drawX = this.x - defeatWidth / 2;
          const drawY = this.y + this.height - defeatHeight;

          // 绘制阴影
          // ctx.fillStyle = 'rgba(0,0,0,0.3)';
          // ctx.beginPath();
          // ctx.ellipse(this.x, this.y + this.height, defeatWidth * 0.3, defeatWidth * 0.15, 0, 0, Math.PI * 2);
          // ctx.fill();

          ctx.drawImage(currentImage, drawX, drawY, defeatWidth, defeatHeight);
        } else {
          // 绘制存活的角色
          const totalWidth = this.width * this.characterCount;
          const startX = this.x - totalWidth / 2;
          for (let i = 0; i < this.characterCount; i++) {
            // 绘制阴影
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(startX + i * this.width + this.width / 2, this.y + this.height, this.width * 0.3, this.width * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();

            // 根据角色类型选择不同形象
            let characterImage;
            const characterType = this.characters[i];
            const isFrame2 = Math.floor(this.animFrame / 30) % 2 === 1;

            if (characterType === 2) {
              characterImage = isFrame2 ? assetImages.player4 : assetImages.player3;
            } else if (characterType === 3) {
              characterImage = isFrame2 ? assetImages.player6 : assetImages.player5;
            } else {
              characterImage = isFrame2 ? assetImages.player2 : assetImages.player1;
            }

            ctx.drawImage(characterImage, startX + i * this.width, this.y, this.width, this.height);
          }

          // 绘制defeat状态的角色
          this.defeatCharacters.forEach(defeatChar => {
            const defeatImage = assetImages[`defeat${defeatChar.characterIndex}`];
            const aspectRatio = defeatImage.naturalWidth / defeatImage.naturalHeight;
            const defeatWidth = this.height * 1.2;
            const defeatHeight = defeatWidth / aspectRatio;
            const drawX = defeatChar.x - defeatWidth / 2;
            const drawY = this.y + this.height - defeatHeight;

            // 绘制阴影
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(defeatChar.x, this.y + this.height, defeatWidth * 0.3, defeatWidth * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.drawImage(defeatImage, drawX, drawY, defeatWidth, defeatHeight);
          });
        }
      }

      // 发射子弹
      shoot() {
        const totalWidth = this.width * this.characterCount;
        const startX = this.x - totalWidth / 2;
        for (let i = 0; i < this.characterCount; i++) {
          const bulletX = startX + i * this.width + this.width / 2;
          const bulletType = this.characters[i]; // 根据角色类型选择子弹
          bullets.push(new Bullet(bulletX, this.y, bulletType));
        }
      }

      // 根据击杀数更新角色数量
      updateCharacterCount() {
        // 每击杀5个小熊增加1血
        if (killsSinceLastLife >= 5 && this.characterCount < 5) {
          player.characterCount++;
          // 添加新角色随机1,2,3
          // const nextType = (this.characters.length % 3) + 1;
          const nextType = Math.floor(Math.random() * 3) + 1;
          this.characters.push(nextType);
          killsSinceLastLife = 0;
        }
      }

      // 更新defeat角色状态
      updateDefeatCharacters(deltaTime) {
        this.defeatCharacters = this.defeatCharacters.filter(defeatChar => {
          defeatChar.timer -= deltaTime;
          return defeatChar.timer > 0;
        });
      }
    }

    // 子弹类
    class Bullet {
      constructor(x, y, bulletType = 1) {
        this.width = canvasWidth / 18; // 子弹宽度
        this.height = this.width * 1.6; // 子弹高度
        this.x = x - this.width / 2; // X坐标（中心对齐）
        this.y = y; // Y坐标
        // 【优化】速度单位改为“像素/秒”，并与屏幕高度关联
        this.speed = canvasHeight * 1.5; // 每秒移动1.5倍画布高度
        this.image = assetImages[`bullet${bulletType}`]; // 根据类型选择子弹图像
        this.markedForDeletion = false; // 【新增】用于标记待删除的对象，替代splice
      }

      // 更新子弹位置（向上移动）
      update(deltaTime) { // 【优化】接收deltaTime参数
        // 【优化】移动距离 = 速度 * 时间（秒）
        this.y -= this.speed * (deltaTime / 1000);
        // 【优化】如果子弹出界，标记它
        if (this.y < -this.height) this.markedForDeletion = true;
      }

      // 绘制子弹
      draw() {
        ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
      }
    }

    // 粉色小熊类
    class Bear {
      constructor(x, y) {
        this.width = canvasWidth / 6; // 小熊宽度
        this.height = this.width; // 小熊高度
        this.x = x; // X坐标
        this.y = y; // Y坐标
        // 【优化】速度单位改为“像素/秒”，并与屏幕高度关联
        this.speed = canvasHeight * 0.3; // 每秒移动0.3倍画布高度
        this.health = 5; // 小熊血量
        this.animFrame = 0; // 动画帧计数器
        this.flashTimer = 0; // 受击闪光计时器
        this.markedForDeletion = false; // 【新增】用于标记待删除的对象
      }

      // 更新小熊位置（向下移动）
      update(deltaTime) { // 【优化】接收deltaTime参数
        // 【优化】移动距离 = 速度 * 时间（秒）
        this.y += this.speed * (deltaTime / 1000);
        this.animFrame++;
        if (this.flashTimer > 0) this.flashTimer--;
        // 【优化】如果小熊出界，标记它
        if (this.y > canvasHeight) this.markedForDeletion = true;
      }

      // 绘制小熊
      draw() {
        // 绘制阴影
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(this.x + this.width / 2, this.y + this.height, this.width * 0.3, this.width * 0.15, 0, 0, Math.PI * 2);
        ctx.fill();

        if (this.flashTimer > 0) {
          ctx.filter = 'brightness(200%) saturate(0%)';
        }
        const currentImage = Math.floor(this.animFrame / 30) % 2 === 0 ? assetImages.bear1 : assetImages.bear2;
        ctx.drawImage(currentImage, this.x, this.y, this.width, this.height);
        ctx.filter = 'none';
      }
    }

    // BOSS类
    class Boss {
      constructor() {
        this.width = canvasWidth / 3; // BOSS宽度
        this.height = this.width * 1.1; // BOSS高度
        this.x = canvasWidth / 2 - this.width / 2; // X坐标（居中）
        this.y = -this.height; // Y坐标（从屏幕上方开始）
        // 【优化】速度单位改为“像素/秒”
        this.speed = canvasHeight * 0.15; // 基础移动速度
        // 根据难度设置血量
        let bossHealth;
        if (currentDifficulty === 'hard') {
          bossHealth = 2800;
        } else if (currentDifficulty === 'easy') {
          bossHealth = 800;
        } else {
          bossHealth = 1400;
        }
        this.health = bossHealth; // 当前血量
        this.maxHealth = bossHealth; // BOSS初始血量
        this.targetY = canvasHeight * 0.1; // 第一阶段目标Y坐标
        // 【优化】水平移动速度
        this.dx = canvasWidth * 0.1; // X轴移动速度
        this.directionX = 1; // X轴移动方向
        this.phase = 1; // BOSS阶段（1或2）
        this.vy = 0; // Y轴方向的速度（像素/秒）
        this.gravity = canvasHeight * 0.1; // 【新增】重力加速度（像素/秒^2）
        this.bounceTargetY = canvasHeight * 0.3; // 弹跳目标Y坐标
        this.animFrame = 0; // 动画帧计数器
        this.attackState = 'normal'; // 攻击状态：normal, raising, punching
        this.attackTimer = 0; // 攻击计时器
      }

      // 更新BOSS状态和位置
      update(deltaTime, gameTime) { // 【优化】接收deltaTime和gameTime参数
        const deltaSeconds = deltaTime / 1000; // 【优化】将时间转换为秒
        this.animFrame++;
        // BOSS血量75%以下或游戏时间超过15秒 进入第二阶段
        if ((this.health <= this.maxHealth * 0.75 || gameTime > 15000) && this.phase === 1) {
          this.phase = 2;
        }
        //第一阶段 BOSS水平巡航
        if (this.phase === 1) {
          if (this.y < this.targetY) this.y += this.speed * deltaSeconds;
          else {
            this.x += this.dx * this.directionX * deltaSeconds;
            if (this.x <= 0) {
              this.x = 0;
              this.directionX = 1;
            }
            if (this.x + this.width >= canvasWidth) {
              this.x = canvasWidth - this.width;
              this.directionX = -1;
            }
          }
        } else {
          const targetX = player.x - this.width / 2;
          if (Math.abs(this.x - targetX) > 2) {
            this.x += (targetX - this.x) * 0.02;
          }
          // 接近玩家时（玩家在BOSS的下方，且距离小于玩家的身高）变成举起拳头状态持续0.3秒
          const distanceToPlayer = player.y - (this.y + this.height);
          if (distanceToPlayer >=0 && distanceToPlayer <= player.height &&
            this.attackState === 'normal' && this.vy >= 0) {
            this.attackState = 'raising';
            this.attackTimer = 300;
          }
          // 处理攻击状态
          if (this.attackState === 'raising') {
            this.attackTimer -= deltaTime;
            //砸拳头
            if (this.attackTimer <= 0) {
              this.attackState = 'punching';
              this.attackTimer = 300; // 砸拳头持续时间
            }
          } else if (this.attackState === 'punching') {
            this.attackTimer -= deltaTime;
            if (this.attackTimer <= 0) {
              this.attackState = 'normal';
            }
          }
          let factor = 1;
          let bounceFactor = 0.8;
          if (currentDifficulty === 'hard') {
            factor = 1.3;
            bounceFactor = 1
          } else if (currentDifficulty === 'easy') {
            factor = 0.7;
            bounceFactor = 0.6;
          }
          // BOSS下降速度 难度越大下降越快
          this.vy += this.gravity * deltaSeconds * factor;
          this.y += this.vy * deltaSeconds;
          // BOSS触底后反弹
          if (this.y + this.height >= canvasHeight) {
            this.y = canvasHeight - this.height;
            // 【优化】弹跳速度与屏幕高度关联
            this.vy = -(Math.random() * canvasHeight * 0.8 + canvasHeight * 0.5);
            // bounceTargetY越小代表BOSS反弹后的高度越接近画面顶部，
            this.bounceTargetY = Math.random() * canvasHeight * bounceFactor - canvasHeight * 0.1;
            if(this.bounceTargetY < 0){
              this.bounceTargetY = 0;
            }
          }
          if (this.vy < 0 && this.y <= this.bounceTargetY) {
            this.vy = 0;
          }
        }
      }
      // 绘制BOSS和血量条
      draw() {
        // 绘制阴影
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(this.x + this.width / 2, this.y + this.height, this.width * 0.4, this.width * 0.2, 0, 0, Math.PI * 2);
        ctx.fill();
        // BOSS受击时的闪光效果（暂时注释）
        if (bossFlashTimer > 0 && this.health > 0) {
          //ctx.filter = 'brightness(200%) saturate(0%)';
        }
        // 根据攻击状态选择图片
        let currentImage;
        if (this.attackState === 'raising') {
          currentImage = assetImages.boss3; // 举起拳头
        } else if (this.attackState === 'punching') {
          currentImage = assetImages.boss4; // 砸下拳头
        } else {
          // 正常状态下的动画切换
          currentImage = Math.floor(this.animFrame / 30) % 2 === 0 ? assetImages.boss1 : assetImages.boss2;
        }

        ctx.drawImage(currentImage, this.x, this.y, this.width, this.height);
        ctx.filter = 'none';

        // 绘制BOSS血量条（无尽模式下不显示）
        if (isEndlessMode) { return; }
        const barWidth = canvasWidth * 0.8, barHeight = 20, barX = canvasWidth / 2 - barWidth / 2, barY = 10;
        ctx.fillStyle = '#555';
        ctx.fillRect(barX, barY, barWidth, barHeight);  // 背景条

        const hpPercent = this.health / this.maxHealth;
        // 根据血量百分比设置颜色
        ctx.fillStyle = hpPercent > 0.5 ? 'green' : (hpPercent > 0.2 ? 'orange' : 'red');
        ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);  // 血量条

        ctx.strokeStyle = 'white';
        ctx.strokeRect(barX, barY, barWidth, barHeight);  // 边框
      }
    }

    // 爆炸效果类
    class Explosion {
      constructor(x, y) {
        this.x = x;  // 爆炸中心X坐标
        this.y = y;  // 爆炸中心Y坐标
        this.particles = [];  // 粒子数组
        this.init();
      }

      // 初始化爆炸粒子
      init() {
        const particleCount = 8;  // 粒子数量
        for (let i = 0; i < particleCount; i++) {
          const angle = Math.random() * Math.PI * 2;  // 随机角度
          const speed = Math.random() * 3 + 1;  // 随机速度
          this.particles.push({
            x: this.x, y: this.y,  // 初始位置
            vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,  // 速度分量
            size: Math.random() * 8 + 4,  // 粒子大小
            life: Math.random() * 20 + 20,  // 生命周期
            opacity: 1,  // 透明度
            color: '#ff69b4'  // 粒子颜色
          });
        }
      }

      // 更新粒子状态
      update() {
        this.particles.forEach((p, index) => {
          p.x += p.vx;
          p.y += p.vy;  // 更新位置
          p.life--;  // 减少生命值
          p.opacity = p.life / 30;  // 更新透明度
          if (p.life <= 0) this.particles.splice(index, 1);  // 移除死亡粒子
        });
      }

      // 绘制爆炸效果
      draw() {
        this.particles.forEach(p => {
          ctx.save();
          ctx.globalAlpha = p.opacity;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
      }

      // 检查爆炸是否结束
      isFinished() {
        return this.particles.length === 0;
      }
    }

    // 闪光效果类
    class FlashEffect {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.life = 15;
        this.maxLife = 15;
        this.images = [];
        this.angles = [];

        // 随机显示1-2张闪光图片
        const count = Math.random() < 0.5 ? 1 : 2;
        for (let i = 0; i < count; i++) {
          this.images.push(Math.random() < 0.5 ? assetImages.flash1 : assetImages.flash2);
          this.angles.push(Math.random() * Math.PI * 2);
        }
      }

      update() {
        this.life--;
      }

      draw() {
        const alpha = this.life / this.maxLife;
        ctx.save();
        ctx.globalAlpha = alpha;

        for (let i = 0; i < this.images.length; i++) {
          ctx.save();
          const offsetX = i * 20 - 10;
          const offsetY = i * 15 - 7;
          ctx.translate(this.x + offsetX, this.y + offsetY);
          ctx.rotate(this.angles[i]);
          ctx.drawImage(this.images[i], -25, -25, 50, 50);
          ctx.restore();
        }

        ctx.restore();
      }

      isFinished() {
        return this.life <= 0;
      }
    }

    // 初始化游戏
    function init() {
      resizeCanvas();  // 调整画布尺寸
      player = new Player();  // 创建玩家
      bullets = [];  // 清空子弹数组
      bears = [];  // 清空小熊数组
      explosions = [];  // 清空爆炸数组
      flashEffects = [];  // 清空闪光效果数组
      boss = null;  // 重置BOSS
      killCount = 0;  // 重置总击杀数
      killsSinceLastLife = 0;  // 重置回血计数器
      bearSpawnTimer = 0;  // 重置小熊生成计时器
      bossSpawned = false;  // 重置BOSS生成标志
      playerInvulnerable = false;  // 重置无敌状态
      invulnerabilityTimer = 0;  // 重置无敌计时器
      gameState = 'playing';  // 设置游戏状态为游戏中
      gameStartTime = performance.now();  // 记录游戏开始时间
      if (player) {
        player.defeatCharacters = [];  // 清空defeat角色
        player.characters = [1];  // 重置角色类型数组
        player.deadCharacterType = 1;  // 重置死亡角色类型
      }
    }

    // 生成小熊
    function spawnBears() {
      const numColumns = 6;  // 列数
      const bearWidth = canvasWidth / 6;  // 每列宽度
      for (let i = 0; i < numColumns; i++) {
        if (Math.random() > 0.3) {  // 70%概率生成小熊
          const x = i * bearWidth;  // 计算X坐标
          const y = -bearWidth;  // 从屏幕上方开始
          let canSpawn = true;

          // 检查是否与BOSS重叠
          if (boss && boss.y > -boss.height) {
            const bossLeft = boss.x;
            const bossRight = boss.x + boss.width;
            const bearLeft = x;
            const bearRight = x + bearWidth;
            if (!(bearRight <= bossLeft || bearLeft >= bossRight)) {
              canSpawn = false;  // 与BOSS重叠，不生成
            }
          }

          if (canSpawn) {
            bears.push(new Bear(x, y));
          }
        }
      }
    }

    // 处理所有碰撞检测
    function handleCollisions() {
      // 子弹与小熊的碰撞
      bullets.forEach(bullet => {
        if (bullet.markedForDeletion) return; // 跳过已标记的子弹
        bears.forEach(bear => {
          if (bear.markedForDeletion) return; // 跳过已标记的小熊
          if (isColliding(bullet, bear)) {
            flashEffects.push(new FlashEffect(bullet.x + bullet.width / 2, bullet.y + bullet.height / 2));
            bullet.markedForDeletion = true; // 【优化】标记子弹待删除
            bear.health--;
            bear.flashTimer = 3;
            if (bear.health <= 0) {
              bear.markedForDeletion = true; // 【优化】标记小熊待删除
              killCount++;
              killsSinceLastLife++;
              player.updateCharacterCount();
            }
          }
        });
      });

      // 子弹与BOSS的碰撞
      if (boss) {
        bullets.forEach(bullet => {
          if (bullet.markedForDeletion) return; // 跳过已标记的子弹
          if (isColliding(bullet, boss)) {
            flashEffects.push(new FlashEffect(bullet.x + bullet.width / 2, bullet.y + bullet.height / 2));
            bullet.markedForDeletion = true; // 标记子弹待删除
            //无尽模式下BOSS不掉血
            if (!isEndlessMode) {
              boss.health--;
            }
            bossFlashTimer = 3;
            if (boss.health <= 0 && gameState === 'playing') {
              gameState = 'bossDying';
              bossDeathPosition = {x: boss.x, y: boss.y, width: boss.width, height: boss.height};
              screenFlashAlpha = 0.7;
              triggerScreenShake(15);
              setTimeout(() => gameOver(true), 400); // BOSS死亡400毫秒后游戏结束
            }
          }
        });
      }

      // 小熊与玩家的碰撞
      bears.forEach(bear => {
        if (bear.markedForDeletion) return;
        const totalWidth = player.width * player.characterCount;
        const startX = player.x - totalWidth / 2;

        for (let i = 0; i < player.characterCount; i++) {
          const charHitbox = {
            x: startX + i * player.width,
            y: player.y,
            width: player.width,
            height: player.height
          };

          if (isColliding(bear, charHitbox)) {
            bear.markedForDeletion = true;
            triggerScreenShake(5);
            checkDead(i);
            return;
          }
        }
      });

      // BOSS与玩家的碰撞（在无敌时间外）
      if (boss && !playerInvulnerable) {
        const totalWidth = player.width * player.characterCount;
        const startX = player.x - totalWidth / 2;

        for (let i = 0; i < player.characterCount; i++) {
          const charHitbox = {
            x: startX + i * player.width,
            y: player.y,
            width: player.width,
            height: player.height
          };

          if (isColliding(boss, charHitbox)) {
            playerInvulnerable = true;
            // 玩家无敌时间1.8秒，避免重复受到伤害
            invulnerabilityTimer = 1800;
            triggerScreenShake(8);
            checkDead(i);
            return;
          }
        }
      }
    }

    function checkDead(hitCharacterIndex) {
      if (player.characterCount > 1) {
        // 计算被击中角色的位置
        const totalWidth = player.width * player.characterCount;
        const startX = player.x - totalWidth / 2;
        const hitCharacterX = startX + hitCharacterIndex * player.width + player.width / 2;
        const hitCharacterType = player.characters[hitCharacterIndex];

        // 添加defeat角色
        player.defeatCharacters.push({
          x: hitCharacterX,
          characterIndex: hitCharacterType,
          timer: 1200 // 角色被击败1200毫秒后消失
        });

        // 从角色数组中移除被击中的角色
        player.characters.splice(hitCharacterIndex, 1);
        player.characterCount--;  // 减少角色数量（生命）
        killsSinceLastLife = 0;
      } else {
        // 记录最后一个角色的类型
        player.deadCharacterType = player.characters[hitCharacterIndex];
        player.isDead = true;  // 设置玩家死亡状态
        setTimeout(() => gameOver(false), 400);  // 玩家死亡400毫秒后游戏结束
      }
    }

    // 碰撞检测函数（矩形碰撞）
    function isColliding(rect1, rect2) {
      return rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.y + rect1.height > rect2.y;
    }

    // 绘制道路中间线
    function drawRoad(deltaTime) { // 【优化】接收deltaTime参数
      ctx.fillStyle = '#fff';
      const lineWidth = 15, lineHeight = 80, lineGap = 60;
      // 【优化】道路滚动速度与屏幕高度和时间关联
      const roadSpeed = canvasHeight * 0.6;
      if (gameState === 'playing') {
        roadLineY += roadSpeed * (deltaTime / 1000);
      }
      if (roadLineY > lineHeight + lineGap) roadLineY = 0;

      for (let y = roadLineY - (lineHeight + lineGap); y < canvasHeight; y += lineHeight + lineGap) {
        ctx.fillRect(canvasWidth / 2 - lineWidth / 2, y, lineWidth, lineHeight);
      }
    }

    let lastTime = 0;  // 上一帧时间

    // 游戏主循环
    function gameLoop(timestamp) {
      updateFPS(); // 更新 FPS 显示
      const deltaTime = timestamp - lastTime;  // 计算帧间隔
      lastTime = timestamp;

      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      drawRoad(deltaTime); // 绘制道路

      // 将所有“游戏进行中”的逻辑（包括对象更新和清理）都放在这个代码块里
      if (gameState === 'playing') {
        const gameTime = timestamp - gameStartTime; // 计算游戏时间
        // 更新所有游戏对象
        bullets.forEach(bullet => bullet.update(deltaTime));
        bears.forEach(bear => bear.update(deltaTime));
        if (boss) {
          boss.update(deltaTime, gameTime);
        }
        if(player){
          // 更新玩家角色所在位置
          updatePlayerPosition(deltaTime);
          player.updateDefeatCharacters(deltaTime);
        }
        // 持续射击逻辑
        if (isShooting) {
          shootTimer += deltaTime;
          if (shootTimer >= shootInterval) {
            player.shoot();
            shootTimer = 0;
          }
        }
        // 小熊生成计时器
        bearSpawnTimer += deltaTime;
        if (bearSpawnTimer > bearSpawnInterval) {
          spawnBears();
          bearSpawnTimer = 0;
        }
        // 5秒后生成BOSS
        if (!bossSpawned && timestamp > 5000) {
          boss = new Boss();
          bossSpawned = true;
        }
        if (bossFlashTimer > 0) bossFlashTimer--;
        // 更新玩家无敌状态
        if (playerInvulnerable) {
          invulnerabilityTimer -= deltaTime;
          if (invulnerabilityTimer <= 0) {
            playerInvulnerable = false;
          }
        }

        handleCollisions(); // 处理碰撞
        // 将子弹和小熊数组的清理操作移到这里
        // 这样当游戏不再是'playing'状态时，它们就不会被移除，从而被定格在屏幕上
        bullets = bullets.filter(b => !b.markedForDeletion);
        bears = bears.filter(b => !b.markedForDeletion);
      }

      // BOSS死亡时的连续爆炸效果 (这个逻辑保持在外，因为它在 'bossDying' 状态下运行)
      if (gameState === 'bossDying' && Math.random() < 0.8) {
        const x = bossDeathPosition.x + Math.random() * bossDeathPosition.width;
        const y = bossDeathPosition.y + Math.random() * bossDeathPosition.height;
        explosions.push(new Explosion(x, y));
        flashEffects.push(new FlashEffect(x, y));
      }

      // 更新并过滤特效 (特效的生命周期独立于游戏状态)
      flashEffects.forEach(flash => flash.update());
      explosions.forEach(exp => exp.update());
      flashEffects = flashEffects.filter(f => !f.isFinished());
      explosions = explosions.filter(e => !e.isFinished());

      // 绘制所有游戏对象 (绘制逻辑永远在主干上，确保所有状态都能正确显示)
      bullets.forEach(b => b.draw());
      bears.forEach(b => b.draw());
      if (boss) boss.draw();

      // 无敌状态下玩家角色闪烁，注释掉下面这一行就代表不闪烁
      //if (!playerInvulnerable || Math.floor(invulnerabilityTimer / 100) % 2 === 0) {
        player.draw();
     // }

      explosions.forEach(e => e.draw());
      flashEffects.forEach(f => f.draw());

      // 屏幕闪光效果
      if (screenFlashAlpha > 0) {
        ctx.fillStyle = `rgba(255, 255, 255, ${screenFlashAlpha})`;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        screenFlashAlpha -= 0.05;  // 逐渐淡化
      }
      // 绘制UI信息
      ctx.fillStyle = 'white';
      ctx.font = '24px "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif';
      ctx.shadowColor = 'rgba(0,0,0,0.6)';  // 阴影颜色
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 2;
      ctx.shadowBlur = 4;
      // 描边效果（更立体）
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(0,0,0,0.6)';

      ctx.textAlign = 'left';
      ctx.fillText(`${languages[currentLang].lives}: ${player.characterCount}`, 20, 60);  // 左上角显示生命数
      ctx.textAlign = 'right';
      ctx.fillText(`${languages[currentLang].score}: ${killCount}`, canvasWidth - 20, 60);  // 右上角显示击杀数
      // 清除阴影，避免影响其他绘制
      ctx.shadowColor = 'transparent';
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
      ctx.shadowBlur = 0;
      // 继续下一帧（如果游戏未结束）
      if (gameState !== 'over') gameLoopId = requestAnimationFrame(gameLoop);
    }

    // 开始游戏
    function startGame() {
      init();  // 初始化游戏
      startScreen.classList.add('hidden');  // 隐藏开始界面
      defeatScreen.classList.add('hidden');  // 隐藏失败界面
      winScreen.classList.add('hidden');  // 隐藏胜利界面
      lastTime = performance.now();  // 记录开始时间
      if (gameLoopId) cancelAnimationFrame(gameLoopId);  // 取消上一个游戏循环
      gameLoop(lastTime);  // 开始游戏循环
    }

    // 回到首页
    function backToHome() {
      init();
      gameState = 'over';  // 设置游戏状态为结束
      if (gameLoopId) cancelAnimationFrame(gameLoopId);  // 停止游戏循环
      startScreen.classList.remove('hidden');  // 显示开始界面
      defeatScreen.classList.add('hidden');  // 隐藏失败界面
      winScreen.classList.add('hidden');  // 隐藏胜利界面
    }

    // 格式化游戏时间
    function formatGameTime(milliseconds) {
      const totalSeconds = Math.floor(milliseconds / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    // 游戏结束
    function gameOver(isWin) {
      gameState = 'over';  // 设置游戏状态为结束
      cancelAnimationFrame(gameLoopId);  // 停止游戏循环

      // 计算游戏时间并显示
      const gameTime = performance.now() - gameStartTime;
      const timeText = `${languages[currentLang].gameTime}: ${formatGameTime(gameTime)}`;

      if (isWin) {
        document.getElementById('game-time-win').textContent = timeText;
        winScreen.classList.remove('hidden');  // 显示胜利界面
      } else {
        document.getElementById('game-time-defeat').textContent = timeText;
        defeatScreen.classList.remove('hidden');  // 显示失败界面
      }
    }

    // 调整画布尺寸
    function resizeCanvas() {
      const rect = container.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      canvasWidth = canvas.width;
      canvasHeight = canvas.height;
      if (player) {
        player.width = canvasWidth / 7;
        player.height = player.width * 1.2;
      }
    }
    window.addEventListener('resize', resizeCanvas);  // 监听窗口大小变化

    // 定义一个目标位置的全局变量，方便玩家角色位置更新函数里使用
    let targetPos = { x: player ? player.x : 0, y: player ? player.y : 0 };
    // 获取鼠标位置
    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
      return {x: evt.clientX - rect.left, y: evt.clientY - rect.top};
    }

    // 获取触摸位置
    function getTouchPos(evt) {
      const rect = canvas.getBoundingClientRect();
      return {x: evt.touches[0].clientX - rect.left, y: evt.touches[0].clientY - rect.top};
    }

    // 鼠标按下或触摸开始 开始射击
    function handleInputStart(x, y) {
      isShooting = true;
      shootTimer = shootInterval; // 立即射击第一发

    }

    // 鼠标移动或触摸滑动 角色目标位置更新
    function handleInputMove(x, y) {
      targetPos.x = x;
      targetPos.y = y;
    }

    // 鼠标松开/离开或触摸结束 停止射击
    function handleInputEnd() {
      isShooting = false;
      shootTimer = 0;
    }

    // 玩家位置更新函数
    function updatePlayerPosition(deltaTime) {
      // 下面代码的作用是让玩家角色平滑移动，从而修复移动端点击任意位置会瞬移过去，不会接触到移动路线上任何物体的bug
      // speed数值越大，角色移动越接近真实的随鼠标移动/移动端瞬移，speed数值越小，角色移动的滞后性越大
      const speed = 2400;
      const dx = targetPos.x - player.x;
      const dy = targetPos.y - player.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance > 1) {
        const moveDist = Math.min(speed * deltaTime / 1000, distance); // 注意 deltaTime 单位 ms
        player.x += dx / distance * moveDist;
        player.y += dy / distance * moveDist;
      }

      // 下面三行代码作用是避免角色移动位置超出边界
      const totalWidth = player.width * player.characterCount;
      player.x = Math.max(totalWidth / 2, Math.min(canvasWidth - totalWidth / 2, player.x));
      player.y = Math.max(0, Math.min(canvasHeight - player.height, player.y));
    }

    // 鼠标按下
    container.addEventListener('mousedown', e => {
      const pos = getMousePos(e);
      handleInputStart(pos.x, pos.y);
    });

    //鼠标移动
    container.addEventListener('mousemove', e => {
      const pos = getMousePos(e);
      handleInputMove(pos.x, pos.y);
    });

    //鼠标松开按钮
    container.addEventListener('mouseup', handleInputEnd);

    // 如果希望鼠标移到画布范围以外依然保持射击，就注释下面这行
    // container.addEventListener('mouseleave', handleInputEnd);

    // 触摸开始 （手指首次触碰屏幕）
    container.addEventListener('touchstart', e => {
      // 阻止在按钮等UI元素上的默认行为
      if (e.target.tagName !== 'CANVAS') return;
      e.preventDefault();
      const pos = getTouchPos(e);
      handleInputStart(pos.x, pos.y);
    }, {passive: false});

    // 触摸移动 （手指在屏幕上滑动时连续触发）
    container.addEventListener('touchmove', e => {
      if (e.target.tagName !== 'CANVAS') return;
      e.preventDefault();
      const pos = getTouchPos(e);
      handleInputMove(pos.x, pos.y);
    }, {passive: false});

    // 触摸结束 (手指离开屏幕时触发)
    container.addEventListener('touchend', e => {
      if (e.target.tagName !== 'CANVAS') return;
      e.preventDefault();
      handleInputEnd();
    }, {passive: false});

    // 触摸取消 (系统取消触控，例如来电弹窗出现)
    container.addEventListener('touchcancel', e => {
      if (e.target.tagName !== 'CANVAS') return;
      e.preventDefault();
      handleInputEnd();
    }, {passive: false});


    // 屏幕震动效果函数
    function triggerScreenShake(intensity) {
      container.style.animation = `shake ${0.3}s`;  // 设置震动动画

      // 定义震动关键帧
      const keyframes = `@keyframes shake {
            10%, 90% { transform: translate3d(${-intensity / 4}px, 0, 0); }
            20%, 80% { transform: translate3d(${intensity / 2}px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(${-intensity}px, 0, 0); }
            40%, 60% { transform: translate3d(${intensity}px, 0, 0); }
        }`;

      // 使用动态样式表避免重复添加关键帧
      if (!document.getElementById('shake-style')) {
        const style = document.createElement('style');
        style.id = 'shake-style';
        document.head.appendChild(style);
      }
      document.getElementById('shake-style').innerHTML = keyframes;

      // 0.2秒后清除震动效果
      setTimeout(() => container.style.animation = '', 200);
    }

    // 加载资源并初始化画布
    loadAssets(() => {
      resizeCanvas();
      sendStat();
    });
  })();
</script>

</body>
</html>
