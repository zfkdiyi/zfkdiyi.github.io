<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>音符射手 元祖BanG Dream</title>
  <style>
    :root {
      --primary-color: #ff69b4; /* Hot Pink */
      --secondary-color: #9370db; /* Medium Purple */
      --text-color: #ffffff;
      --shadow-color: rgba(0, 0, 0, 0.5);
    }

    body {
      margin: 0;
      padding: 0;
      background-color: #333;
      color: var(--text-color);
      font-family: "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100dvh;
      overflow: hidden;
    }

    #game-container {
      position: relative;
      background-color: #6c757d;

      /* 保持 9:16 比例，最大化铺满 */
      width: 100vw;
      height: 100dvh;
      aspect-ratio: 9 / 16;

      /* 限制缩放，保证不会超出屏幕 */
      max-width: 500px;
      max-height: 100dvh;

      /* 居中显示，超出部分自动裁切 */
      object-fit: contain;
      overflow: hidden;

      box-shadow: 0 0 20px var(--shadow-color);
    }

    #game-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #707070; /* Road color */
    }

    .start-adjust {
      justify-content: flex-start !important;
    }

    .game-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background-color: rgba(0, 0, 0, 0.3);
      text-align: center;
      z-index: 10;
      transition: opacity 0.5s ease;
      padding-top: 0;
    }

    .game-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .overlay-title {
      margin: 15px 0px;
      font-size: 2rem;
      font-weight: bold;
      text-shadow: 0 0 10px var(--primary-color), 0 0 20px var(--primary-color);
      animation: pulse 1.5s infinite;
      @media (max-width: 500px) {
        font-size: 1.8rem;
      }
      @media (max-width: 375px) {
        font-size: 1.6rem;
        margin: 10px 0px;
      }
    }

    .result-text,
    .overlay-text {
      font-size: 22px;
      font-weight: 600; /* 稍微加粗 */
      color: #ffffff; /* 白色 */
      text-shadow: -2px -2px 0 #000,
      2px -2px 0 #000,
      -2px 2px 0 #000,
      2px 2px 0 #000,
      0 0 10px rgba(255, 105, 180, 0.8);
      /*text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5), 0 0 6px rgba(255, 105, 180, 0.6);  阴影 + 粉色光晕 */
      margin: 10px 0;
      line-height: 1.5;
      @media (max-width: 450px) {
        font-size: 18px;
        margin: 8px 0;
      }
    }

    .result-text {
      font-size: 24px;
      line-height: 1.6;
      margin: 0;
      @media (max-width: 450px) {
        font-size: 20px;
      }
    }

    .result-text > div {
      height: 1.6em;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #result-total-text,
    #result-combo-text {
      height: 1.6em;
      display: flex;
      justify-content: center;
    }

    .result-rank,
    .result-fullcombo {
      height: 1.4em;
      margin-left: 8px;
      display: none;
    }

    .end-button,
    .start-button {
      padding: 10px 20px;
      font-size: 1.3rem;
      font-weight: bold;
      color: var(--secondary-color);
      background-color: var(--text-color);
      border: none;
      border-radius: 20px;
      cursor: pointer;
      box-shadow: 0 5px 15px var(--shadow-color);
      transition: transform 0.2s, box-shadow 0.2s;
      @media (max-width: 400px) {
        padding: 8px 16px;
        font-size: 1.2rem;
      }
    }

    .end-button:hover,
    .start-button:hover {
      transform: scale(1.1);
      box-shadow: 0 8px 25px var(--shadow-color);
    }

    .end-button {
      margin: 15px 0px;
      @media (max-width: 400px) {
        margin: 12px 0px;
      }
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.05);
      }
      100% {
        transform: scale(1);
      }
    }

    .difficulty-selector,
    .language-selector {
      display: flex;
      gap: 10px;
      margin: 10px 0;
      transition: opacity 0.3s ease;
      @media (max-width: 450px) {
        margin: 5px 0;
      }
    }

    .difficulty-selector.hidden,
    .language-selector.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .contact-btn,
    .difficulty-btn,
    .lang-btn {
      padding: 8px 12px;
      font-size: 16px;
      color: var(--text-color);
      background-color: rgba(0, 0, 0, 0.5);
      border: 2px solid transparent;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.2s;
      @media (max-width: 450px) {
        padding: 4px 8px;
        font-size: 14px;
      }
    }

    .contact-btn:hover,
    .difficulty-btn:hover,
    .lang-btn:hover {
      background-color: rgba(255, 105, 180, 0.3);
    }

    .contact-btn.active,
    .difficulty-btn.active,
    .lang-btn.active {
      border-color: var(--primary-color);
      background-color: rgba(255, 105, 180, 0.5);
    }

    .version-info {
      margin-top: 20px;
      font-size: 16px;
      color: rgba(255, 255, 255, 0.7);
      text-align: center;
      line-height: 1.6;
      @media (max-width: 400px) {
        font-size: 14px;
      }
    }

    .github-btn {
      margin-top: 4px;
      color: rgba(255, 255, 255, 0.7);
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 5px;
      transition: color 0.2s;
      position: relative;
      cursor: pointer;
    }

    .github-btn:hover {
      color: #ff69b4;
    }

    #fps-display {
      position: absolute;
      bottom: 10px;
      left: 45px;
      color: #0f0;
      font-size: 15px;
      font-weight: bold;
      text-shadow: 0 0 3px #000;
      z-index: 20;
      line-height: 1.2;
      cursor: pointer;
    }


    /* 联系作者部分 */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.4);
      justify-content: center;
      align-items: center;
    }

    .leaderboard-content,
    .modal-content {
      background-color: #fff;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
      width: 90%;
      max-width: 400px;
      text-align: left;
    }

    .modal-content h3 {
      margin-top: 0;
      font-size: 1.1rem;
      color: #333;
    }

    .leaderboard-modal {
      background-color: #333;
      color: #fff;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .leaderboard-modal h3 {
      color: #fff;
    }

    .modal-content textarea {
      width: 100%;
      height: 100px;
      margin: 10px 0;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #ccc;
      resize: none;
      font-size: 0.95rem;
      box-sizing: border-box;
    }

    .modal-actions {
      text-align: right;
    }

    .modal-actions button {
      margin-left: 10px;
      padding: 6px 12px;
      border: none;
      border-radius: 6px;
      background-color: #4caf50;
      color: #fff;
      cursor: pointer;
      font-size: 0.95rem;
      transition: background-color 0.3s ease;
    }

    .modal-actions button:hover {
      background-color: #45a049;
    }

    .modal-actions button#cancel-btn {
      background-color: #aaa;
    }

    .modal-actions button#cancel-btn:hover {
      background-color: #888;
    }

    .close {
      float: right;
      font-size: 1.3rem;
      cursor: pointer;
    }

    /* 排行榜样式 */
    .leaderboard-modal {
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .leaderboard-desc {
      font-size: 14px;
      margin: 0 8px;
      @media (max-width: 450px) {
        font-size: 12px;
        margin: 0 4px;
      }
    }

    .leaderboard-filters {
      display: flex;
      gap: 12px;
      margin: 15px 0;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap; /*允许换行*/
    }

    .leaderboard-filters select {
      padding: 8px 12px;
      border-radius: 20px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      background: rgba(0, 0, 0, 0.5);
      font-size: 14px;
      color: #fff;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 80px;
      max-width: 120px;
      flex-shrink: 1;
    }

    .leaderboard-filters select:hover {
      border-color: var(--primary-color);
    }

    .leaderboard-list {
      max-height: 400px;
      overflow-y: auto;
    }

    .leaderboard-item {
      display: flex;
      align-items: center;
      padding: 12px;
      margin: 8px 0;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      transition: transform 0.2s;
    }

    .leaderboard-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .leaderboard-item.highlight {
      background: rgba(255, 105, 180, 0.3);
      border: 2px solid var(--primary-color);
      box-shadow: 0 0 15px rgba(255, 105, 180, 0.5);
    }

    .leaderboard-rank {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 24px;
      margin-right: 15px;
      color: #fff;
    }

    .leaderboard-rank.rank-1 {
      background: linear-gradient(135deg, #ffd700, #ffed4e);
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
    }

    .leaderboard-rank.rank-2 {
      background: linear-gradient(135deg, #c0c0c0, #e8e8e8);
      box-shadow: 0 0 15px rgba(192, 192, 192, 0.5);
    }

    .leaderboard-rank.rank-3 {
      background: linear-gradient(135deg, #cd7f32, #daa520);
      box-shadow: 0 0 15px rgba(205, 127, 50, 0.5);
    }

    .leaderboard-rank.rank-other {
      background: linear-gradient(135deg, #6c757d, #868e96);
    }

    .leaderboard-info {
      flex: 1;
      color: #fff;
    }

    .leaderboard-name {
      font-weight: bold;
      font-size: 16px;
      margin-bottom: 4px;
      color: #fff;
    }

    .leaderboard-details {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.8);
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .leaderboard-score {
      font-size: 22px;
      font-weight: bold;
      color: #fff;
      text-align: right;
      width: 130px;
      text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 0 0 8px rgba(255, 105, 180, 0.8);
      display: flex;
      align-items: center;
      justify-content: flex-end;
    }

    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid var(--primary-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .empty-leaderboard {
      text-align: center;
      padding: 40px 20px;
      color: rgba(255, 255, 255, 0.7);
      font-size: 16px;
    }

    @media (max-width: 450px) {
      .leaderboard-content {
        padding: 8px;
      }
      .leaderboard-filters {
        gap: 10px;
      }

      .leaderboard-item {
        padding: 10px;
      }

      .leaderboard-rank {
        width: 35px;
        height: 35px;
        font-size: 18px;
        margin-right: 10px;
      }

      .leaderboard-details {
        font-size: 12px;
        gap: 8px;
      }

      .leaderboard-score {
        font-size: 16px;
        width: 100px;
      }
    }


    .music-control:hover {
      background: rgba(255, 105, 180, 1);
      box-shadow: 0 6px 20px rgba(255, 105, 180, 0.6);
    }

    .music-control svg {
      width: 20px;
      height: 20px;
      fill: white;
      transition: all 0.2s ease;
    }

    .level-selector {
      margin: 6px 0;
      padding: 10px 16px;
      font-size: 16px;
      color: var(--text-color);
      background-color: rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 120px;
      text-align: center;
      @media (max-width: 450px) {
        padding: 8px 14px;
        font-size: 14px;
        min-width: 100px;
      }
    }

    .level-selector:hover {
      border-color: var(--primary-color);
    }



    .button-row {
      margin: 10px 0;
      display: grid; /* 1. 使用 Grid 布局 */
      grid-template-columns: 1fr auto 1fr; /* 2. 定义三列网格 */
      align-items: center; /* 垂直居中对齐所有项 */
      width: 100%;
      gap: 20px; /* 在列之间添加一些间距 */
    }

    /* 让第一列的元素（排行榜按钮）靠左对齐，
      第三列的元素（音乐控件）靠右对齐。
    */
    .button-row > .blank_button {
      justify-self: start; /* 在网格区域内靠左 */
    }

    .button-row > .start-button {
      justify-self: center; /* 它会自动位于中间 auto 列，无需特殊样式 */
    }

    .button-row > .music-control {
      /* justify-self: end;  在网格区域内靠右 */
    }

    .blank_button {
      visibility: hidden;
    }

    .music-control {
      width: 40px;
      height: 40px;
      background: rgba(255, 105, 180, 0.8);
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(255, 105, 180, 0.4);
    }

    /* 游戏中的音乐控制按钮 */
    .game-music-control {
      position: absolute;
      bottom: 10px;
      right: 10px;
      width: 24px;
      height: 24px;
      background: rgba(255, 105, 180, 0.8);
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(255, 105, 180, 0.4);
      z-index: 15;
    }

    .pause-button {
      position: absolute;
      bottom: 10px;
      left: 10px;
      width: 24px;
      height: 24px;
      background: rgba(255, 105, 180, 0.8);
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(255, 105, 180, 0.4);
      z-index: 15;
    }

    .pause-button:hover {
      background: rgba(255, 105, 180, 1);
      box-shadow: 0 6px 20px rgba(255, 105, 180, 0.6);
    }

    .game-music-control:hover {
      background: rgba(255, 105, 180, 1);
      box-shadow: 0 6px 20px rgba(255, 105, 180, 0.6);
    }


    @media (max-width: 400px) {
      .music-control {
        width: 36px;
        height: 36px;
      }
      .music-control svg {
        width: 18px;
        height: 18px;
      }
    }

    #loading-line {
      width: 60%;
      max-width: 400px;
      height: 10px;
      margin: 5px auto;
      background: rgba(255,255,255,0.2);
      border-radius: 6px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #loading-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #00d2ff, #3a7bd5);
      transition: width 0.25s ease-out;
    }

    #loading-text {
      text-align: center;
      color: white;
      font-size: 16px;
    }
    /* 去除移动端点击按钮的高亮闪框 */
    * {
      -webkit-tap-highlight-color: transparent;
    }
  </style>
</head>
<body>

<div id="game-container">
  <canvas id="game-canvas"></canvas>
  <div id="fps-display" style="display: none;">
    <div>FPS: 0</div>
  </div>

  <!-- 游戏中的音乐控制按钮 -->
  <div id="game-music-control" class="game-music-control" style="display: none;">
    <svg id="game-music-icon-play" viewBox="0 0 24 24" fill="white">
      <path
        d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
    </svg>
    <svg id="game-music-icon-mute" viewBox="0 0 24 24" style="display: none;" fill="white">
      <path
        d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
    </svg>
  </div>

  <!-- 暂停按钮 -->
  <div id="pause-button" class="pause-button" style="display: none;">
    <svg viewBox="0 0 24 24" width="24" height="24" fill="white">
      <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
    </svg>
  </div>

  <!-- 暂停菜单 -->
  <div id="pause-menu" class="game-overlay hidden">
    <div style="display: flex; flex-direction: column; align-items: center; transform: translateY(-15%);">
      <h1 class="overlay-title" data-text="pauseTitle">游戏暂停</h1>
      <button id="resume-button" class="end-button" data-text="resumeGame">继续游戏</button>
      <button id="submit-score-button" class="end-button" data-text="submitScore">提交分数</button>
      <button id="pause-home-button" class="end-button" data-text="backToHome">回到首页</button>
    </div>
  </div>

  <!-- 背景音乐 -->
  <div id="audio-container"></div>

  <div id="start-screen" class="game-overlay start-adjust">
    <img id="header-image" style="width: 100%; position: absolute; top: 0; left: 0; z-index: -1;">
    <div style="display: flex; flex-direction: column; align-items: center; margin-top: 20vh;">
      <h1 class="overlay-title" data-text="title">音符射手</h1>
      <p class="overlay-text" data-text="instructions">移动鼠标或手指来控制角色<br>按住屏幕持续发射音符！</p>
      <div class="difficulty-selector">
        <button class="difficulty-btn" data-text="easy">简单</button>
        <button class="difficulty-btn" data-text="normal">普通</button>
        <button class="difficulty-btn" data-text="hard">困难</button>
        <button class="difficulty-btn" data-text="endless">无尽模式</button>
      </div>
      <div style="display: flex; flex-direction: column; align-items: center;">
        <div>
          <select id="level-selector" class="level-selector">
            <option value="1" data-text="level1">第1关</option>
            <option value="2" data-text="level2">第2关</option>
            <option value="3" data-text="level3">第3关</option>
          </select>
        </div>
        <div class="button-row">
          <button class="blank_button" ></button>
          <button id="start-button" class="start-button" data-text="startGame">开始游戏</button>
          <div id="music-control" class="music-control">
            <svg id="music-icon-play" viewBox="0 0 24 24">
              <path
                d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
            </svg>
            <svg id="music-icon-mute" viewBox="0 0 24 24" style="display: none;">
              <path
                d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
            </svg>
          </div>
        </div>
      </div>
      <div id="language-selector" class="language-selector">
        <button class="lang-btn" data-lang="zh">中文</button>
        <button class="lang-btn" data-lang="en">English</button>
        <button class="lang-btn" data-lang="ja">日本語</button>
        <button class="contact-btn" data-text="contact" id="contact-btn">联系作者</button>
      </div>
    </div>
    <div id="contact-modal" class="modal">
      <div class="modal-content">
        <span class="close">&times;</span>
        <h3 data-text="contact">联系作者</h3>
        <textarea id="contact-text" data-placeholder="contactHolder"
                  placeholder="请输入内容（不超过100字 如果你希望收到作者回复，记得留下邮箱地址）"
                  maxlength="100"></textarea>
        <div class="modal-actions">
          <button id="send-btn" data-text="submit">提交</button>
          <button id="cancel-btn" data-text="close">关闭</button>
        </div>
      </div>
    </div>
    <!-- 加载进度界面 -->
    <div>
      <img id="leaderboard-button" style="display: none; cursor: pointer"/>
    </div>
    <div id="loading-line">
      <div id="loading-fill"></div>
    </div>
    <div id="loading-text">Loading... 0%</div>


    <!-- 排行榜弹窗 -->
    <div id="leaderboard" class="modal">
      <div class="leaderboard-content leaderboard-modal">
        <span class="close" id="leaderboard-close">&times;</span>
        <span style="font-size: 20px; font-weight: bold" data-text="leaderboard">排行榜</span>
        <span class="leaderboard-desc" data-text="leaderboard-desc">2分钟更新一次，时间15秒以下不收录</span>
        <div class="leaderboard-filters">
          <select id="lb-level">
            <option value="1" data-text="level1">第1关</option>
            <option value="2" data-text="level2">第2关</option>
            <option value="3" data-text="level3">第3关</option>
          </select>
          <select id="lb-difficulty">
            <option value="easy" data-text="easy">简单</option>
            <option value="normal" data-text="normal">普通</option>
            <option value="hard" data-text="hard">困难</option>
            <option value="endless" data-text="endless">无尽模式</option>
          </select>
          <select id="lb-order">
            <option value="score" data-text="scoreOrder">积分顺序</option>
            <option value="rank" data-text="rankOrder">级别顺序</option>
          </select>
          <select id="lb-show">
            <option value="top" data-text="show_top">前30名</option>
            <option value="best" data-text="show_best">最好30次</option>
            <option value="recent" data-text="show_recent">最近30次</option>
            <option value="myRank" data-text="show_myRank">我的排名</option>
            <option value="myBest" data-text="show_myBest">我的最好30次</option>
            <option value="myRecent" data-text="show_myRecent">我的最近30次</option>
          </select>
        </div>


        <div id="leaderboard-list" class="leaderboard-list">
          <div class="loading-spinner"></div>
        </div>
      </div>
    </div>

    <div class="version-info">
      <div><span data-text="version">版本</span>: 0.7</div>
      <div><span data-text="updateTime">更新时间</span>: 2026-02-18</div>
      <div>
        <a href="https://github.com/zfkdiyi/bangdream" target="_blank" id="github-button" class="github-btn">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path
              d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
          </svg>
          GitHub
        </a>
      </div>
      <div id="online-count"></div>
      <div id="my-id"></div>
    </div>
  </div>

  <div id="result-screen" class="game-overlay hidden">
    <div style="display: flex; flex-direction: column; align-items: center; transform: translateY(-15%);">
      <div class="result-text">
        <div id="result-diff"></div>
        <div id="result-time"></div>
        <div id="result-kill"></div>
        <div id="result-combo">
          <span id="result-combo-text"></span>
          <img id="result-fullcombo" class="result-fullcombo">
        </div>
        <div id="result-total">
          <span id="result-total-text"></span>
          <img id="result-rank" class="result-rank">
        </div>
      </div>
      <img id="result-image" alt="RESULT"
           style="max-width: 80%; max-height: 60%; object-fit: contain;">
      <p id="result-message" class="overlay-text">不要灰心，再来一次！</p>
      <button id="restart-button" class="end-button" data-text="retry">重试</button>
      <button id="home-button" class="end-button" data-text="backToHome">回到首页</button>
    </div>
  </div>
</div>

<script>
  (function () {
    let mode = 'prod';
    // 公共前缀
    let IMG_PATH = mode == 'local' ? 'img/' : 'https://cdn.badmintonranks.com/bangdream/img/';
    let API_PATH = mode == 'local' ? 'http://localhost/dev-api/' : 'https://badmintonranks.com/prod-api/';
    let currentLang = 'zh';
    const languages = {
      zh: {
        title: '元祖！BanG Dream酱<br>音符射手',
        instructions: '移动鼠标或手指来控制角色<br>按住屏幕持续发射音符！',
        startGame: '开始游戏',
        defeatMessage: '不要灰心，再来一次！',
        retry: '重试一次',
        winMessage: '闪闪发光 心动不已！',
        playAgain: '再玩一次',
        backToHome: '回到首页',
        lives: '生命',
        score: '积分',
        version: '版本',
        updateTime: '更新时间',
        contact: '联系作者',
        submit: '提交',
        close: '关闭',
        contactHolder: '请输入内容（不超过100字 如果你希望收到作者回复，记得留下邮箱地址）',
        easy: '容易',
        normal: '中等',
        hard: '困难',
        endless: '无尽模式',
        gameTime: '用时',
        mode: '模式',
        alertEmpty: '请输入内容',
        alertFrequent: '请勿频繁提交',
        alertSuccess: '已成功提交！',
        alertError: '提交失败，请稍后重试',
        killScore: '击杀得分',
        maxCombo: '最大连击',
        totalScore: '总得分',
        level1: '第1关',
        level2: '第2关',
        level3: '第3关',
        scoreOrder: '积分顺序',
        rankOrder: '级别顺序',
        leaderboard: '排行榜',
        'leaderboard-desc': '2分钟更新一次，游戏时长15秒以下不收录',
        noData: '暂无排行数据',
        loadError: '加载失败，请稍后重试',
        show_top: '前30名',
        show_best: '最好30次',
        show_recent: '最近30次',
        show_myRank: '我的排名',
        show_myBest: '我的最好30次',
        show_myRecent: '我的最近30次',
        pauseTitle: '游戏暂停',
        resumeGame: '继续游戏',
        submitScore: '提交分数',
      },
      en: {
        title: 'GANSO! BanG Dream Chan<br>Note Shooter',
        instructions: 'Move mouse or finger to control character<br>Hold screen to shoot notes continuously!',
        startGame: 'Start Game',
        defeatMessage: 'Don\'t give up, try again!',
        retry: 'Retry',
        winMessage: 'KIRAKIRA DOKIDOKI!',
        playAgain: 'Play Again',
        backToHome: 'Back to Home',
        lives: 'Lives',
        score: 'Score',
        version: 'Version',
        updateTime: 'Update time',
        contact: 'Contact Me',
        submit: 'Submit',
        close: 'Close',
        contactHolder: "Please enter your message (up to 100 characters). If you’d like a reply, don’t forget to leave your email address.",
        easy: 'Easy',
        normal: 'Normal',
        hard: 'Hard',
        endless: 'Endless',
        gameTime: 'Duration',
        mode: 'Mode',
        alertEmpty: 'Please enter content',
        alertFrequent: 'Please do not submit frequently',
        alertSuccess: 'Successfully submitted!',
        alertError: 'Submission failed, please try again later',
        killScore: 'Kill Score',
        maxCombo: 'Max Combo',
        totalScore: 'Total Score',
        level1: 'Level 1',
        level2: 'Level 2',
        level3: 'Level 3',
        scoreOrder: 'By Score',
        rankOrder: 'By Level',
        leaderboard: 'Score Ranking',
        'leaderboard-desc': 'Updated every 2 minutes, games under 15 seconds not recorded',
        noData: 'No leaderboard data',
        loadError: 'Failed to load, please try again later',
        show_top: 'Top 30',
        show_best: 'Best 30',
        show_recent: 'Recent 30',
        show_myRank: 'My Rank',
        show_myBest: 'My Best 30',
        show_myRecent: 'My Recent 30',
        pauseTitle: 'Game Paused',
        resumeGame: 'Game Continue',
        submitScore: 'Submit Score',
      },
      ja: {
        title: '「元祖！バンドリちゃん」<br>ノートシューター',
        instructions: 'マウスや指で キャラクターを操作<br>画面を押し続けて ノートを連射！',
        startGame: 'ゲーム開始',
        defeatMessage: '諦めないで、もう一度！',
        retry: 'リトライ',
        winMessage: 'キラキラドキドキ！',
        playAgain: 'もう一度',
        backToHome: 'ホームに戻る',
        lives: 'ライフ',
        score: 'ポイント',
        version: 'バージョン',
        updateTime: '更新日時',
        contact: 'お問い合わせ',
        submit: '送信',
        close: '閉じる',
        contactHolder: "内容を入力してください（100文字以内）。返信をご希望の方は、メールアドレスを忘れずにご記入ください。",
        easy: '簡単',
        normal: '普通',
        hard: '難しい',
        endless: '無限モード',
        gameTime: 'ゲーム時間',
        mode: 'モード',
        alertEmpty: '内容を入力してください',
        alertFrequent: '頻繁に送信しないでください',
        alertSuccess: '送信が完了しました！',
        alertError: '送信に失敗しました。しばらくしてからもう一度お試しください',
        killScore: '撃破スコア',
        maxCombo: '最大コンボ',
        totalScore: '合計スコア',
        level1: 'ステージ 1',
        level2: 'ステージ 2',
        level3: 'ステージ 3',
        scoreOrder: 'スコア順',
        rankOrder: 'レベル順',
        leaderboard: 'ランキング',
        'leaderboard-desc': '2分毎に更新 (15秒未満の記録は除外)',
        noData: 'ランキングデータがありません',
        loadError: '読み込みに失敗しました。しばらくしてからもう一度お試しください',
        show_top: 'トップ 30',
        show_best: 'ベスト 30',
        show_recent: '最近30回',
        show_myRank: '自分の順位',
        show_myBest: '自分のベスト30',
        show_myRecent: '自分の最近30回',
        pauseTitle: 'ゲーム一時停止',
        resumeGame: 'ゲームを再開',
        submitScore: 'スコアを送信',
      }
    };


    // 设首页图片
    const setIndexImage = () => {
      const randomIndex = Math.floor(Math.random() * 10) + 1;
      document.getElementById('header-image').src =
      'https://cdn.badmintonranks.com/bangdream/img/head' + randomIndex +'.jpg';
      document.getElementById('leaderboard-button').src = IMG_PATH + 'score_rank.png';
    };

    // 自动检测浏览器语言
    const detectLanguage = () => {
      const lang = (navigator.language || navigator.userLanguage || 'en').toLowerCase();
      if (lang.startsWith('zh')) return 'zh';
      if (lang.startsWith('ja')) return 'ja';
      return 'en';
    };
    // 更新语言内容
    const updateLanguage = (lang) => {
      const texts = languages[lang] || languages.en;
      // 更新文字内容
      document.querySelectorAll('[data-text]').forEach(el => {
        const key = el.dataset.text;
        if (texts[key]) el.innerHTML = texts[key];
      });
      // 更新 placeholder
      document.querySelectorAll('[data-placeholder]').forEach(el => {
        const key = el.dataset.placeholder;
        if (texts[key]) el.placeholder = texts[key];
      });
      // 更新页面标题 (用正则替换掉所有<br>换行符）
      document.title = texts.title.replace(/<br\s*\/?>/g, ' ');
      // 更新语言按钮状态
      document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.lang === lang);
      });
      // 更新关卡选择下拉框
      const levelSelector = document.getElementById('level-selector');
      if (levelSelector) {
        levelSelector.options[0].text = texts.level1;
        levelSelector.options[1].text = texts.level2;
        levelSelector.options[2].text = texts.level3;
      }
      // 更新排行榜下拉框
      const leaderboardSelects = ['level-selector', 'lb-level', 'lb-difficulty', 'lb-order', 'lb-show'];
      leaderboardSelects.forEach(selectId => {
        const selectEl = document.getElementById(selectId);
        if (selectEl) {
          Array.from(selectEl.options).forEach(option => {
            const key = option.dataset.text;
            if (key && texts[key]) option.text = texts[key];
          });
        }
      });
    };
    // 音乐控制相关变量
    let menuMusic, battleMusic, endMusic;
    let isMusicEnabled = false;

    // 公共前缀
    const audioPrefix = "https://cdn.badmintonranks.com/bangdream/music/";
    // 音乐文件名数组
    const musicFiles = [
      { id: "menu-music", file: "menu.mp3", loop: true },
      { id: "battle-music", file: "battle1.mp3", loop: true },
      { id: "end-music", file: "end.mp3", loop: true }
    ];
    // 遍历生成 <audio> 标签
    function createMusic() {
      const audioContainer = document.getElementById("audio-container");
      musicFiles.forEach(music => {
        const audio = document.createElement("audio");
        audio.id = music.id;
        audio.loop = music.loop;
        // auto表示浏览器尽可能地提前加载整个音频文件，以便用户一点击播放就能立即开始。
        // none表示浏览器不下载音频，除非用户点击播放。延迟大
        audio.preload = "auto";

        const source = document.createElement("source");
        source.src = `${audioPrefix}${music.file}`;
        source.type = "audio/mpeg";

        audio.appendChild(source);
        audioContainer.appendChild(audio);
        initMusicControl();
      });
    }
    // 播放指定音乐
    const playMusic = (musicType) => {
      let currentMusic = getTargetMusic(musicType);
      if(currentMusic) {
        // 暂停其他音乐（不重置时间）
        [menuMusic, battleMusic, endMusic].forEach(music => {
          if (music && music !== currentMusic) {
            music.pause();
            music.currentTime = 0;
          }
        });
        // 播放指定音乐
        if (isMusicEnabled) {
          currentMusic.play().catch(e => console.log('音乐播放失败:', e));
        }
      }
    };
    // 获取目标音乐对象
    const getTargetMusic = (musicType) => {
      if (musicType === 'menu') return menuMusic;
      if (musicType === 'battle') return battleMusic;
      if (musicType === 'end') return endMusic;
      return null;
    };

    // 更新音乐按钮图标
    const updateMusicIcons = () => {
      const playIcons = document.querySelectorAll('[id$="-icon-play"]');
      const muteIcons = document.querySelectorAll('[id$="-icon-mute"]');

      playIcons.forEach(icon => {
        icon.style.display = isMusicEnabled ? 'none' : 'block';
      });
      muteIcons.forEach(icon => {
        icon.style.display = isMusicEnabled ? 'block' : 'none';
      });
    };

    // 切换音乐开关
    const toggleMusic = () => {
      isMusicEnabled = !isMusicEnabled;
      updateMusicIcons();

      if (!isMusicEnabled) {
        // 关闭音乐（保持当前播放位置）
        [menuMusic, battleMusic, endMusic].forEach(music => {
          if (music) music.pause();
        });
      } else {
        // 开启音乐，根据当前状态播放对应音乐（从暂停位置继续）
        if (gameState === 'playing') {
          playMusic('battle');
        } else if (gameState === 'over') {
          const isGameOverScreen = !startScreen.classList.contains('hidden') ? false : true;
          if (isGameOverScreen) {
            playMusic('end');
          } else {
            playMusic('menu');
          }
        } else {
          playMusic('menu');
        }
      }
    };
    // 初始化音乐控制
    const initMusicControl = () => {
      menuMusic = document.getElementById('menu-music');
      battleMusic = document.getElementById('battle-music');
      endMusic = document.getElementById('end-music');

      const musicControl = document.getElementById('music-control');
      const gameMusicControl = document.getElementById('game-music-control');
      // 主菜单音乐控制按钮
      musicControl.addEventListener('click', toggleMusic);
      // 游戏中音乐控制按钮
      gameMusicControl.addEventListener('click', toggleMusic);
      // Chrome不允许用户一打开网站就自动播放声音
    };

    // 初始化语言
    function setLanguage() {
      currentLang = detectLanguage();
      updateLanguage(currentLang);
      // 语言切换按钮监听
      document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          currentLang = btn.dataset.lang;
          updateLanguage(currentLang);
        });
      });
    }

    // 联系作者弹窗逻辑
    const contactBtn = document.getElementById('contact-btn');
    const modal = document.getElementById('contact-modal');
    const closeBtn = modal.querySelector('.close');
    const cancelBtn = document.getElementById('cancel-btn');
    const sendBtn = document.getElementById('send-btn');
    const textarea = document.getElementById('contact-text');
    contactBtn.onclick = () => {
      modal.style.display = 'flex';
    };
    closeBtn.onclick = cancelBtn.onclick = () => {
      modal.style.display = 'none';
      textarea.value = '';
    };
    sendBtn.onclick = async () => {
      const text = textarea.value.trim();
      if (!text) {
        alert(languages[currentLang].alertEmpty);
        return;
      }
      try {
        const response = await fetch(API_PATH + 'bilibiliContact', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: text
        });
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        const data = await response.json();
        if (data.code == 427) {
          alert(languages[currentLang].alertFrequent);
          return;
        }
        alert(languages[currentLang].alertSuccess);
        modal.style.display = 'none';
        textarea.value = '';
      } catch (error) {
        console.error(error);
        alert(languages[currentLang].alertError);
      }
    };
    // FPS显示
    const fpsDisplay = document.getElementById('fps-display');
    let lastTimes = performance.now();
    let frames = 0;
    let fps = 0;
    let fpsVisible = true;

    function updateFPS() {
      const now = performance.now();
      frames++;
      if (now - lastTimes >= 1000) { // 每秒更新一次
        fps = frames;
        frames = 0;
        lastTimes = now;
        fpsDisplay.textContent = 'FPS: ' + fps;
      }
    }
    // 初始化FPS显示状态
    function initFPS() {
      fpsDisplay.addEventListener('click', () => {
        fpsVisible = !fpsVisible;
        fpsDisplay.style.display = fpsVisible ? 'block' : 'none';
      });
    }

    //获取在线人数
    async function sendStat() {
      let from = document.referrer;
      let width = window.outerWidth;
      let height = window.window.outerHeight;
      let playerId = getPlayerId();
      const res = await fetch(API_PATH + 'openStat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({from, width, height, playerId})
      });
      const data = await res.json();
      if (data.online !== undefined) {
        document.getElementById('online-count').textContent = `Online: ${data.online}`;
      }
      if (data.playerId) {
        localStorage.setItem("playerId", data.playerId);
        playerId = data.playerId;
      }
      document.getElementById('my-id').textContent = `ID: ${playerId}`;
    }

    // 玩家ID管理
    let playerId = null;
    // 获取或生成玩家ID
    function getPlayerId() {
      if (playerId) return playerId;
      playerId = localStorage.getItem('playerId');
      if (!playerId || playerId.length < 1) {
        return "";
      }
      return playerId;
    }

    // 发送游戏结果统计
    async function gameStat(playerId, levels, difficulty, fps, win, ranks, duration, kumaKill, kumaLive,
                      maxCombo, life, lifeLost, bossRatio, bulletRatio, itemRatio, finalScore) {
      fetch(API_PATH + 'gameStat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          playerId, levels, difficulty, fps, win, ranks, duration, kumaKill, kumaLive,
          maxCombo, life, lifeLost, bossRatio, bulletRatio, itemRatio, finalScore
        })
      });
    }
    // 排行榜数据缓存
    let leaderboardData = null;
    // 排行榜功能
    async function loadLeaderboard(levels, difficulty, type, playerId) {
      const listEl = document.getElementById('leaderboard-list');
      listEl.innerHTML = '<div class="loading-spinner"></div>';
      try {
        let prefix = API_PATH + 'getRanking';
        if(type === 'myRank') {
          prefix = API_PATH + 'getMyRanking';
        }
        let url = `${prefix}?levels=${levels}&difficulty=${difficulty}&type=${type}&playerId=${playerId}`;
        const response = await fetch(url);
        const data = await response.json();
        leaderboardData = data.data;
        renderLeaderboard();
      } catch (e) {
        const texts = languages[currentLang];
        listEl.innerHTML = `<div class="empty-leaderboard">${texts.loadError}</div>`;
      }
    }

    // 渲染排行榜
    function renderLeaderboard() {
      const listEl = document.getElementById('leaderboard-list');
      const orderSelect = document.getElementById('lb-order');
      const orderType = orderSelect ? orderSelect.value : 'score';
      const currentPlayerId = getPlayerId();

      if (!leaderboardData || leaderboardData.length === 0) {
        const texts = languages[currentLang];
        listEl.innerHTML = `<div class="empty-leaderboard">${texts.noData}</div>`;
        return;
      }

      const texts = languages[currentLang];

      // 根据选择的排序方式对数据进行排序
      let sortedData = [...leaderboardData];
      if (orderType === 'rank') {
        // 按级别排序：SSS、SSP、SS、SP、S、AP、A、BP、B、CP、C、D
        const rankOrder = ['sss', 'ssp', 'ss', 'sp', 's', 'ap', 'a', 'bp', 'b', 'cp', 'c', 'd'];
        sortedData.sort((a, b) => {
          const rankA = a.ranks ? a.ranks.toLowerCase() : 'z';
          const rankB = b.ranks ? b.ranks.toLowerCase() : 'z';
          const indexA = rankOrder.indexOf(rankA);
          const indexB = rankOrder.indexOf(rankB);

          // 如果等级相同，按积分从高到低排序
          if (indexA === indexB) {
            return (b.final_score || 0) - (a.final_score || 0);
          }

          // 等级不同，按等级顺序排序（未找到的等级排在最后）
          if (indexA === -1) return 1;
          if (indexB === -1) return -1;
          return indexA - indexB;
        });
      }
      // 如果是积分排序，保持原有顺序（服务器已按积分排序）

      listEl.innerHTML = sortedData.map((item, index) => {
        const rank = item.user_rank;
        const rankClass = rank === 1 ? 'rank-1' : rank === 2 ? 'rank-2' : rank === 3 ? 'rank-3' : 'rank-other';
        const displayName = `${item.player_id || 'Unknown'}`;
        const createTime = `${item.create_time || ''}`;
        const timeStr = Math.floor(item.duration / 60) + ':' + (item.duration % 60).toString().padStart(2, '0');
        const rankIcon = item.ranks ? `<img src="${IMG_PATH}rank_${item.ranks.toLowerCase()}.png" style="height: 40px; margin-right: 8px;">` : '';
        const fullComboIcon = (item.full_combo === 1) ? `<img src="${IMG_PATH}full_combo.png" style="height: 20px;">` : '';

        // 高亮当前用户
        const isCurrentUser = currentPlayerId && item.player_id === currentPlayerId;
        const highlightClass = isCurrentUser ? ' highlight' : '';

        return `
          <div class="leaderboard-item${highlightClass}"">
            <div class="leaderboard-rank ${rankClass}">${rank}</div>
            <div class="leaderboard-info">
              <div class="leaderboard-name">${displayName}   <span style="font-size: 12px;
      color: rgba(255, 255, 255, 0.8);">${createTime}</span></div>
              <div class="leaderboard-details">
                <span>${texts.maxCombo}: ${item.max_combo}</span>
                <span>${texts.gameTime}: ${timeStr}</span>
                <span>${fullComboIcon}</span>
              </div>
            </div>
            <div class="leaderboard-score">
              ${rankIcon}${item.final_score}
            </div>
          </div>
        `;
      }).join('');
    }

    // 初始化排行榜
    function initLeaderboard() {
      const leaderboard = document.getElementById('leaderboard');
      const btn = document.getElementById('leaderboard-button');
      const closeBtn = document.getElementById('leaderboard-close');
      const levelSelect = document.getElementById('lb-level');
      const difficultySelect = document.getElementById('lb-difficulty');
      const orderSelect = document.getElementById('lb-order');
      const showSelect = document.getElementById('lb-show');

      // 打开排行榜
      btn.onclick = async () => {
        getPlayerId();
        // 设置下拉框默认值为当前选择的等级和难度
        levelSelect.value = document.getElementById('level-selector').value;
        difficultySelect.value = currentDifficulty;
        showSelect.value = 'top';
        leaderboard.style.display = 'flex';
        await loadLeaderboard(levelSelect.value, difficultySelect.value, showSelect.value, getPlayerId());
      };

      // 关闭排行榜
      closeBtn.onclick = () => {
        leaderboard.style.display = 'none';
      };

      // 筛选变化时重新加载
      levelSelect.onchange = difficultySelect.onchange = showSelect.onchange = () => {
        loadLeaderboard(levelSelect.value, difficultySelect.value, showSelect.value, getPlayerId());
      };

      // 排序方式变化时只重新渲染
      orderSelect.onchange = () => {
        renderLeaderboard();
      };

      // 点击模态框外部关闭
      leaderboard.onclick = (e) => {
        if (e.target === leaderboard) {
          leaderboard.style.display = 'none';
        }
      };
    }

    //游戏难度和模式选择
    let currentDifficulty = 'easy';
    let gameStartTime = 0;
    let currentLevel = 1;

    // 更新难度按钮被选中的状态
    function updateDifficultyButtons() {
      document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.classList.toggle('active', btn.getAttribute('data-text') === currentDifficulty);
      });
    }

    // 初始化难度按钮状态
    updateDifficultyButtons();
    // 难度按钮点击事件
    document.querySelectorAll('.difficulty-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        currentDifficulty = btn.getAttribute('data-text');
        updateDifficultyButtons();
      });
    });

    // 获取画布和容器元素
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('game-container');

    // 获取游戏界面元素
    const startScreen = document.getElementById('start-screen');
    const resultScreen = document.getElementById('result-screen');

    const startButton = document.getElementById('start-button');
    const restartButton = document.getElementById('restart-button');
    const homeButton = document.getElementById('home-button');
    const pauseButton = document.getElementById('pause-button');
    const pauseMenu = document.getElementById('pause-menu');
    const resumeButton = document.getElementById('resume-button');
    const submitScoreButton = document.getElementById('submit-score-button');
    const pauseHomeButton = document.getElementById('pause-home-button');

    startButton.addEventListener('click', startGame);// 开始游戏按钮
    restartButton.addEventListener('click', startGame);// 重试按钮
    homeButton.addEventListener('click', backToHome);// 回到首页按钮
    pauseButton.addEventListener('click', pauseGame);// 暂停按钮
    resumeButton.addEventListener('click', resumeGame);// 继续游戏按钮
    submitScoreButton.addEventListener('click', submitScore);// 提交分数按钮
    pauseHomeButton.addEventListener('click', backToHome);// 暂停菜单回到首页按钮


    // 游戏基础变量
    let canvasWidth, canvasHeight;  // 画布尺寸
    let player, bullets, bears, boss, explosions;  // 游戏对象
    let powerUps = []; //道具
    let healthPacks = []; //血包
    let bossBullets = []; //BOSS子弹
    let uiFont = 16; // UI字体大小
    let uiAdjust = 0; // UI字体距离偏移量
    let bearSpawnTimer = 0;  // 小熊生成计时器
    let bearInterval = 0;  // 小熊生成间隔（毫秒）
    let bearProbability = 0;  // 小熊生成概率
    let bossBegan = 0; // BOSS在游戏开始多久后出现
    let maxPlayerCharacter = 5;  // 第一关玩家角色数量最大值
    let bearKillCount = 0;  // 小熊击杀数
    let killsSinceLastLife = 0;  // 自上次获得生命以来的击杀数
    let comboCount = 0;  // 连击数
    let maxComboCount = 0;  // 最大连击数
    let escapedBearCount = 0;  // 逃走小熊数
    let escapedBulletCount = 0;  // 幸存BOSS子弹数
    let escapedItemCount = 0;  // 幸存道具血包数
    let destroyedBulletCount = 0;  // 玩家消灭的BOSS子弹数
    let collectedItemCount = 0;  // 玩家吃掉的道具血包数
    let buffItemCount = 0; //玩家吃掉的增益物品数
    let normalItemCount = 0; //玩家吃掉的普通物品数
    let stunCount = 0; //玩家眩晕次数
    let shieldBearKillCount = 0; //击杀护盾小熊数
    let maxPlayerAttack = 0; //玩家达到的最大攻击力
    let deathCount = 0;  // 阵亡次数
    let bossSpawned = false;  // BOSS是否已生成
    let gameLoopId;  // 游戏循环ID
    let roadLineY = -100;  // 道路线条Y坐标
    let gameState;  // 游戏状态
    let bossDeathPosition;  // BOSS死亡位置
    let playerInvulnerable = false;  // 玩家无敌状态
    let invulnerabilityTimer = 0;  // 无敌时间计时器
    let flashEffects = [];  // 闪光效果数组
    let isShooting = false;  // 是否正在射击
    let shootTimer = 0;  // 射击计时器
    let shootInterval = 80;  // 射击间隔（毫秒）越小子弹发射越密集，火力更强
    // 第二关参数
    let playerHealth = 3; //玩家生命值
    let playerBulletStreams = 1; // 玩家子弹束数量
    let maxPlayerBulletStreams = 10; // 玩家子弹束最大数量
    let itemProbability = 1; //道具出现概率
    let healthProbability = 1; //血包出现概率
    let charaItems = []; // 第三关特殊道具
    let playerBuffed = false; // 玩家是否有增益
    let playerBuffTimer = 0; // 增益计时器
    let playerStunned = false; // 玩家是否眩晕
    let playerStoned = false; // 玩家是否被石头摔倒
    let stunTimer = 0; // 眩晕计时器
    let stoneTimer = 0; // 眩晕计时器
    let playerAttackPower = 5; // 玩家攻击力（第三关）
    let sameCharaEffects = []; // 同类头像碰撞特效数组
    let attackPowerFloatTexts = []; // 攻击力增量浮动文字数组
    let playerShield = false; // 玩家是否有保护罩
    let shieldTimer = 0; // 保护罩计时器
    let damageProbability = 0; //item3（蘑菇）、item6-3（石头）的出现概率
    let protectProbability = 0; //item6-2（创可贴）的出现概率
    let maxShieldBears = 0;
    let shieldBearsProbability = 0;


    // 游戏资源定义
    const assets = {
      player1: 'player1.png',
      player2: 'player2.png',
      player3: 'player3.png',
      player4: 'player4.png',
      player5: 'player5.png',
      player6: 'player6.png',
      player7: 'player7.png',
      player8: 'player8.png',
      player9: 'player9.png',
      player10: 'player10.png',
      player11: 'player11.png',
      player12: 'player12.png',
      player13: 'player13.png',
      player14: 'player14.png',
      player15: 'player15.png',
      player16: 'player16.png',
      bear1: 'kuma1.png',
      bear2: 'kuma2.png',
      boss1: 'kkr1.png',
      boss2: 'kkr2.png',
      boss3: 'kkr3.png',
      boss4: 'kkr4.png',
      bullet1: 'bullet1.png',
      bullet2: 'bullet2.png',
      bullet3: 'bullet3.png',
      bullet4: 'bullet4.png',
      flash1: 'flash1.png',
      flash2: 'flash2.png',
      fire1: 'fire1.png',
      fire2: 'fire2.png',
      defeat1: 'defeat1.png',
      defeat2: 'defeat2.png',
      defeat3: 'defeat3.png',
      defeat4: 'defeat4.png',
      defeat5: 'defeat5.png',
      defeat6: 'defeat6.png',
      defeat7: 'defeat7.png',
      defeat8: 'defeat8.png',
      defeat9: 'defeat9.png',
      defeat10: 'defeat10.png',
      defeat11: 'defeat11.png',
      defeat12: 'defeat12.png',
      defeat13: 'defeat13.png',
      scoreIcon: 'kuma_icon.png',
      comboIcon: 'combo.png',
      win: 'win.png',
      defeat: 'defeat.png',
      chara1: 'chara1.png',
      chara2: 'chara2.png',
      chara3: 'chara3.png',
      chara4: 'chara4.png',
      chara5: 'chara5.png',
      chara6: 'chara6.png',
      chara7: 'chara7.png',
      chara8: 'chara8.png',
      chara9: 'chara9.png',
      chara10: 'chara10.png',
      chara11: 'chara11.png',
      chara12: 'chara12.png',
      chara13: 'chara13.png',
      item1: 'item1.png',
      item2: 'item2.png',
      item3: 'item3.png',
      item4: 'item4.png',
      item5_1: 'item5-1.png',
      item5_2: 'item5-2.png',
      item5_3: 'item5-3.png',
      item6_1: 'item6-1.png',
      item6_2: 'item6-2.png',
      item6_3: 'item6-3.png',
      item7: 'item7.png',
      item8: 'item8.png',
      item9_1: 'item9-1.png',
      item9_2: 'item9-2.png',
      item10: 'item10.png',
      item11_1: 'item11-1.png',
      item11_2: 'item11-2.png',
      item12: 'item12.png',
      item13: 'item13.png',
      star1: 'star1.png',
      star2: 'star2.png',
      star3: 'star3.png',
      star4: 'star4.png',
      star5: 'star5.png',
      star6: 'star6.png',
      blood: 'blood.png',
      dizzy: 'dizzy.png',
      fullcombo: 'full_combo.png',
      rank_sss: 'rank_sss.png',
      rank_ssp: 'rank_ssp.png',
      rank_ss: 'rank_ss.png',
      rank_sp: 'rank_sp.png',
      rank_s: 'rank_s.png',
      rank_ap: 'rank_ap.png',
      rank_a: 'rank_a.png',
      rank_bp: 'rank_bp.png',
      rank_b: 'rank_b.png',
      rank_cp: 'rank_cp.png',
      rank_c: 'rank_c.png',
      rank_d: 'rank_d.png',
    };
    // 存储加载后的图像对象
    const assetImages = {};

    function loadAssets(callback, onProgress, onError) {
      let loadedCount = 0;
      const totalCount = Object.keys(assets).length;

      function handleProgress() {
        loadedCount++;
        if (onProgress) onProgress(loadedCount, totalCount);
        if (loadedCount === totalCount) callback();
      }

      Object.entries(assets).forEach(([key, filename]) => {
        const img = new Image();
        img.src = IMG_PATH + filename;
        img.onload = handleProgress;
        img.onerror = () => {
          console.warn(`❌ Failed to load: ${img.src}，重试中...`);
          retryLoad(img, IMG_PATH + filename, 3, handleProgress, onError);
        };
        assetImages[key] = img;
      });
    }

    function retryLoad(img, src, retries, onSuccess, onError) {
      let attempts = 0;

      function tryAgain() {
        if (attempts >= retries) {
          console.error(`🚫 图片加载失败，已放弃: ${src}`);
          if (onError) onError();
          //即使失败，也推进进度
          //onSuccess();
          return;
        }
        attempts++;
        setTimeout(() => {
          img.src = src + '?retry=' + attempts;
        }, 30 * attempts);
      }

      img.onerror = tryAgain;
      img.onload = onSuccess;
      tryAgain();
    }

    function loadData() {
      const loadingText = document.getElementById('loading-text');
      const progressBarFill = document.getElementById('loading-fill');
      const loadingLine = document.getElementById('loading-line');
      const scoreRank = document.getElementById('leaderboard-button');
      let hasError = false;
      loadAssets(
        () => {
          if (!hasError) {
            progressBarFill.style.width = '100%';
            setTimeout(() => {
              loadingLine.style.opacity = '0';
              loadingText.style.opacity = '0';
              setTimeout(() => {
                loadingLine.style.display = 'none';
                loadingText.style.display = 'none';
                scoreRank.style.display = 'block';
              }, 0);
            }, 400);
          }
        },
        (loaded, total) => {
          const percent = Math.round((loaded / total) * 100);
          loadingText.textContent = `Loading... ${percent}%`;
          progressBarFill.style.width = `${percent}%`;
        },
        () => {
          if (!hasError) {
            hasError = true;
            loadingText.textContent += ' - Error';
          }
        }
      );
    }

    // 玩家类
    class Player {
      constructor() {
        this.width = canvasWidth / 7;  // 单个角色宽度
        this.height = this.width * 1.2;  // 角色高度
        this.x = canvasWidth / 2;  // X坐标（中心点）
        this.y = canvasHeight - this.height;  // Y坐标（底部）
        this.characterCount = 1;  // 角色数量（生命数）
        this.animTimer = 0;  // 动画计时器（毫秒）
        this.isDead = false;  // 死亡状态
        this.defeatCharacters = [];  // 处于defeat状态的角色
        this.characters = [1];  // 存储每个角色的类型编号
        this.deadCharacterType = 1;  // 最后一个死亡角色的类型
        this.currentCharacterType = 1;  // 第2关当前角色类型
        this.bulletType = 1;  // 子弹类型
        this.flashTimer = 0; // 受击闪光计时器（毫秒）
      }
      // 绘制玩家角色
      draw(deltaTime) {
        this.animTimer += deltaTime;
        if (this.flashTimer > 0) this.flashTimer -= deltaTime;
        if (this.isDead || playerStoned) {
          if(playerStoned){
            this.deadCharacterType = this.currentCharacterType;
          }
          const currentImage = assetImages[`defeat${this.deadCharacterType}`];
          const aspectRatio = currentImage.naturalWidth / currentImage.naturalHeight;
          const defeatWidth = this.height * 1.2;
          const defeatHeight = defeatWidth / aspectRatio;
          const drawX = this.x - defeatWidth / 2;
          const drawY = this.y + this.height - defeatHeight;
          ctx.drawImage(currentImage, drawX, drawY, defeatWidth, defeatHeight);
        } else if (currentLevel > 1) {
          // 第2关：绘制单个角色
          ctx.fillStyle = 'rgba(0,0,0,0.3)';
          ctx.beginPath();
          ctx.ellipse(this.x, this.y + this.height, this.width * 0.3, this.width * 0.15, 0, 0, Math.PI * 2);
          ctx.fill();
          let characterImage;
          // 第3关每个角色只用一个图片
          if(currentLevel === 3) {
            if (this.currentCharacterType === 1) {
              characterImage = assetImages.player2;
            } else if (this.currentCharacterType === 2) {
              characterImage = assetImages.player4;
            } else if (this.currentCharacterType === 3) {
              characterImage = assetImages.player6;
            } else if (this.currentCharacterType >= 4 && this.currentCharacterType <= 13) {
              // 第4-13个角色对应player7-player16
              characterImage = assetImages['player' + (this.currentCharacterType + 3)];
            }
          } else if(currentLevel === 2) {
            // 第2关每个角色有两个跑动形态图片来回切换
            const isFrame2 = Math.floor(this.animTimer / 400) % 2 === 1;
            if (this.currentCharacterType === 2) {
              characterImage = isFrame2 ? assetImages.player4 : assetImages.player3;
            } else if (this.currentCharacterType === 3) {
              characterImage = isFrame2 ? assetImages.player6 : assetImages.player5;
            } else {
              characterImage = isFrame2 ? assetImages.player2 : assetImages.player1;
            }
          }
          if (this.flashTimer > 0) {
            ctx.filter = 'brightness(200%) saturate(0%)';
          }
          ctx.drawImage(characterImage, this.x - this.width / 2, this.y, this.width, this.height);
          ctx.filter = 'none';
          // 第3关有增益时绘制闪烁星星
          if (currentLevel === 3 && playerBuffed) {
            // const time = performance.now();
            // const alpha = (Math.sin(time / 300) + 1) / 2 * 0.5 + 0.5;
            // ctx.globalAlpha = alpha;
            // const starSize = this.width * 0.4;
            // // 只保留左上位置的星星
            // ctx.drawImage(assetImages.star1, this.x - this.width * 0.5, this.y + this.height * 0.1, starSize, starSize);
            // ctx.globalAlpha = 1;
            // 绘制增益倒计时
            // const seconds = Math.ceil(playerBuffTimer / 1000);
            // ctx.font = 'bold 20px Arial';
            // ctx.fillStyle = '#FFD700';
            // ctx.strokeStyle = '#000';
            // ctx.lineWidth = 3;
            // ctx.textAlign = 'center';
            // ctx.strokeText(seconds, this.x, this.y - 15);
            // ctx.fillText(seconds, this.x, this.y - 15);
          }
          // 保护罩效果
          if (playerShield) {
            const time = performance.now();
            const radius = this.width * 0.7;
            const alpha = (Math.sin(time / 200) + 1) / 2 * 0.3 + 0.5;
            ctx.save();
            ctx.globalAlpha = alpha;
            const gradient = ctx.createRadialGradient(this.x, this.y + this.height / 2, radius * 0.5, this.x, this.y + this.height / 2, radius);
            gradient.addColorStop(0, 'rgba(150, 220, 255, 0.3)');
            gradient.addColorStop(0.7, 'rgba(180, 230, 255, 0.2)');
            gradient.addColorStop(1, 'rgba(200, 240, 255, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(this.x, this.y + this.height / 2, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'rgba(200, 240, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y + this.height / 2, radius * 0.85, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
          }
          // 眩晕时效果
          if (playerStunned) {
            const time = performance.now();
            const alpha = (Math.sin(time / 300) + 1) / 2 * 0.3 + 0.7;
            ctx.globalAlpha = alpha;
            const starSize = this.width * 0.4;
            // 只保留左上位置的星星
            ctx.drawImage(assetImages.dizzy, this.x - this.width * 0.55, this.y + this.height * 0.1, starSize, starSize);
            ctx.globalAlpha = 1;
            // const seconds = Math.ceil(stunTimer / 1000);
            // ctx.font = 'bold 20px Arial';
            // ctx.fillStyle = '#FF4444';
            // ctx.strokeStyle = '#000';
            // ctx.lineWidth = 3;
            // ctx.textAlign = 'center';
            // ctx.strokeText(seconds, this.x, this.y - 15);
            // ctx.fillText(seconds, this.x, this.y - 15);
          }
        } else {
          // 第1关：绘制多个角色
          const totalWidth = this.width * this.characterCount;
          const startX = this.x - totalWidth / 2;
          for (let i = 0; i < this.characterCount; i++) {
            // 绘制阴影
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(startX + i * this.width + this.width / 2, this.y + this.height, this.width * 0.3, this.width * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();
            // 根据角色类型选择不同形象
            let characterImage;
            const characterType = this.characters[i];
            const isFrame2 = Math.floor(this.animTimer / 400) % 2 === 1;

            if (characterType === 2) {
              characterImage = isFrame2 ? assetImages.player4 : assetImages.player3;
            } else if (characterType === 3) {
              characterImage = isFrame2 ? assetImages.player6 : assetImages.player5;
            } else {
              characterImage = isFrame2 ? assetImages.player2 : assetImages.player1;
            }

            ctx.drawImage(characterImage, startX + i * this.width, this.y, this.width, this.height);
          }

          this.defeatCharacters.forEach(defeatChar => {
            const defeatImage = assetImages[`defeat${defeatChar.characterIndex}`];
            const aspectRatio = defeatImage.naturalWidth / defeatImage.naturalHeight;
            const defeatWidth = this.height * 1.2;
            const defeatHeight = defeatWidth / aspectRatio;
            const drawX = defeatChar.x - defeatWidth / 2;
            const drawY = this.y + this.height - defeatHeight;
            // 绘制阴影
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(defeatChar.x, this.y + this.height, defeatWidth * 0.3, defeatWidth * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.drawImage(defeatImage, drawX, drawY, defeatWidth, defeatHeight);
          });
        }
      }

      // 发射子弹
      shoot() {
        if (currentLevel === 1) {
          const totalWidth = this.width * this.characterCount;
          const startX = this.x - totalWidth / 2;
          for (let i = 0; i < this.characterCount; i++) {
            const bulletX = startX + i * this.width + this.width / 2;
            this.bulletType = this.characters[i]; // 根据角色类型选择子弹
            bullets.push(new Bullet(bulletX, this.y, this.bulletType));
          }
        } else {
          // 第三关：根据攻击力调整子弹伤害
          if (currentLevel === 3) {
            this.damage = playerAttackPower;
            this.bearDamage = playerAttackPower;
            // 仓田真白和高松灯的攻击力减弱
            if(this.currentCharacterType === 3 || this.currentCharacterType === 6){
              this.damage *= 0.8;
              this.bearDamage *= 0.8;
            }
          }
          // 第2关：根据子弹束数量发射多束子弹
          const spacing = this.width / (playerBulletStreams + 1) * 1.5; // 调大子弹束间距
          var types = this.currentCharacterType;
          if(types > 3){
            types = (types - 4) % 3 + 1;
          }
          this.bulletType = types;
          // player2形态且子弹束达到4时产生溅射效果
          if (this.bulletType === 2 && playerBulletStreams >= 4) {
            const halfStreams = Math.floor(playerBulletStreams / 2);
            // 一半直射
            for (let i = 0; i < halfStreams; i++) {
              const bulletX = this.x - this.width / 2 + spacing * (i + 1);
              bullets.push(new Bullet(bulletX, this.y, this.bulletType));
            }
            // 一半左右对称斜射（以直射为对称轴）
            const remainingStreams = playerBulletStreams - halfStreams;
            for (let i = 0; i < remainingStreams; i++) {
              const angle = (i+1) * (Math.PI / 2) / (remainingStreams + 1); // 最大90度斜射
              // - angle代表左斜， + angle 代表右斜
              bullets.push(new Bullet(this.x, this.y, this.bulletType, true,  i % 2 == 0 ? (-Math.PI / 2 - angle) : (-Math.PI / 2 + angle) )); // 左斜
            }
          } else {
            // 普通直射子弹
            for (let i = 0; i < playerBulletStreams; i++) {
              const bulletX = this.x - this.width / 2 + spacing * (i + 1);
              bullets.push(new Bullet(bulletX, this.y, this.bulletType));
            }
          }
        }
      }

      // 根据击杀数更新角色数量
      updateCharacterCount() {
        if (currentLevel === 1) {
          // 第1关：每击杀5个小熊增加1血
          if (killsSinceLastLife >= 5 && this.characterCount < maxPlayerCharacter) {
            player.characterCount++;
            const nextType = Math.floor(Math.random() * 3) + 1;
            this.characters.push(nextType);
            killsSinceLastLife = 0;
          }
        }
        // 第2关不增加角色数量
      }

      // 更新defeat角色状态
      updateDefeatCharacters(deltaTime) {
        this.defeatCharacters = this.defeatCharacters.filter(defeatChar => {
          defeatChar.timer -= deltaTime;
          return defeatChar.timer > 0;
        });
      }
    }

    // 子弹类
    class Bullet {
      constructor(x, y, bulletType = 1, isSplash = false, angle = 0) {
        this.width = canvasWidth / 18; // 子弹宽度
        this.height = this.width * 1.6; // 子弹高度
        this.x = x - this.width / 2; // X坐标（中心对齐）
        this.y = y; // Y坐标
        this.speed = canvasHeight * 1.5; // 每秒移动1.5倍画布高度
        if(bulletType > 3){
          bulletType = (bulletType - 4) % 3 + 1;
        }
        this.image = assetImages[`bullet${bulletType}`]; // 根据类型选择子弹图像
        this.markedForDeletion = false; // 【新增】用于标记待删除的对象，替代splice
        this.bulletType = bulletType; // 子弹类型
        this.isSplash = isSplash; // 是否为溅射子弹
        this.angle = angle; // 溅射子弹的角度
        this.buffed = playerBuffed; // 子弹是否有增益// 第三关：使用玩家攻击力
        // 根据子弹类型设置伤害值（第3关）
        if (currentLevel === 3) {
          this.damage = playerAttackPower;
          this.bearDamage = playerAttackPower;
        }else if (currentLevel === 2) {
          if (bulletType === 1) {
            this.damage = 5; // player1形态伤害值为5
            this.bearDamage = 5;
          } else if (bulletType === 2) {
            this.damage = 3; // player2形态普通伤害4 小熊伤害8
            this.bearDamage = 10;
          } else if (bulletType === 3) {
            this.damage = 2; // player3形态伤害值为3
            this.bearDamage = 2;
          }
        } else {
          this.damage = 1; // 第1关保持原有伤害
          this.bearDamage = 1; // 第1关保持原有伤害
        }
      }

      // 更新子弹位置（向上移动）
      update(deltaTime) {
        if (this.isSplash) {
          // 溅射子弹按角度移动
          this.x += Math.cos(this.angle) * this.speed * (deltaTime / 1000);
          this.y += Math.sin(this.angle) * this.speed * (deltaTime / 1000);
        } else {
          // 移动距离 = 速度 * 时间（秒）
          this.y -= this.speed * (deltaTime / 1000);
        }
        // 如果子弹出界，标记它为待删除
        if (this.y < -this.height || this.x < -this.width || this.x > canvasWidth) this.markedForDeletion = true;
      }

      // 绘制子弹
      draw() {
        ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
      }
    }

    // 粉色小熊类
    class Bear {
      constructor(x, y, hasShield = false) {
        this.width = canvasWidth / 6; // 小熊宽度
        this.height = this.width; // 小熊高度
        this.x = x; // X坐标
        this.y = y; // Y坐标
        this.baseSpeed = canvasHeight * 0.3; // 基础移动速度
        this.speed = this.baseSpeed; // 当前移动速度
        this.health = currentLevel > 1 ? 15 : 5; // 第2关小熊血量为15，第1关为5
        this.animTimer = 0; // 动画计时器（毫秒）
        this.flashTimer = 0; // 受击闪光计时器（毫秒）
        this.markedForDeletion = false; // 用于标记待删除的对象
        this.slowEffect = false; // 是否被减速
        this.slowTimer = 0; // 减速效果计时器
        this.defence = 0;
        this.hasShield = hasShield; // 是否有防护罩
        // 防护罩小熊特殊属性
        if (hasShield) {
          if(currentDifficulty === 'easy'){
            this.health = 120;
            this.defence = 8;
          }else if (currentDifficulty === 'normal') {
            this.health = 160;
            this.defence = 12;
          }else if (currentDifficulty === 'hard' || currentDifficulty === 'endless') {
            this.health = 200;
            this.defence = 16;
          }
          this.speed = canvasHeight * 0.12; // 游走速度（大幅降低）
          this.directionX = Math.random() < 0.5 ? 1 : -1; // 随机初始横向方向
          this.directionY = Math.random() < 0.5 ? 1 : -1; // 随机初始纵向方向
        }
      }
      // 应用减速效果
      applySlow() {
        if (!this.slowEffect) {
          this.slowEffect = true;
          this.speed = this.baseSpeed * 0.25; // 降低75%移动速度
          this.slowTimer = 3000; // 减速效果持续3秒
        }
      }
      // 更新小熊位置（向下移动）
      update(deltaTime) {
        // 更新减速效果
        if (this.slowEffect) {
          this.slowTimer -= deltaTime;
          if (this.slowTimer <= 0) {
            this.slowEffect = false;
            this.speed = this.baseSpeed; // 恢复原速度
          }
        }
        this.animTimer += deltaTime;
        if (this.flashTimer > 0) this.flashTimer -= deltaTime;

        // 防护罩小熊的特殊移动逻辑
        if (this.hasShield) {
          const deltaSeconds = deltaTime / 1000;
          // 计算移动距离，确保实际移动速度等于设置的speed
          // 由于同时在X和Y方向移动，需要调整每个方向的速度分量
          const moveDistance = this.speed * deltaSeconds;
          // 计算单位向量
          const magnitude = Math.sqrt(this.directionX * this.directionX + this.directionY * this.directionY);
          const normalizedX = this.directionX / magnitude;
          const normalizedY = this.directionY / magnitude;
          // 应用移动
          this.x += moveDistance * normalizedX;
          this.y += moveDistance * normalizedY;
          // 碰到边界反向
          if (this.x <= 0) {
            this.x = 0;
            this.directionX = 1;
          }
          if (this.x + this.width >= canvasWidth) {
            this.x = canvasWidth - this.width;
            this.directionX = -1;
          }
          if (this.y <= 0) {
            this.y = 0;
            this.directionY = 1;
          }
          if (this.y + this.height >= canvasHeight * 0.6) {
            this.y = canvasHeight * 0.6 - this.height;
            this.directionY = -1;
          }
        } else {
          // 普通小熊：直接向下移动
          this.y += this.speed * (deltaTime / 1000);
          // 如果小熊出界，标记它为待删除并重置combo
          if (this.y > canvasHeight) {
            this.markedForDeletion = true;
            comboCount = 0; // 小熊逃走时重置combo
            escapedBearCount++; // 增加逃走小熊数
          }
        }
      }
      // 绘制小熊
      draw() {
        // 绘制阴影
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(this.x + this.width / 2, this.y + this.height, this.width * 0.3, this.width * 0.15, 0, 0, Math.PI * 2);
        ctx.fill();

        if (this.flashTimer > 0) {
          ctx.filter = 'brightness(200%) saturate(0%)';
        }
        const currentImage = Math.floor(this.animTimer / 400) % 2 === 0 ? assetImages.bear1 : assetImages.bear2;
        ctx.drawImage(currentImage, this.x, this.y, this.width, this.height);
        ctx.filter = 'none';

        // 绘制防护罩
        if (this.hasShield) {
          const time = performance.now();
          const radius = this.width * 0.6;
          const alpha = (Math.sin(time / 200) + 1) / 2 * 0.3 + 0.5;
          ctx.save();
          ctx.globalAlpha = alpha;
          const gradient = ctx.createRadialGradient(this.x + this.width/2, this.y + this.height/2, radius * 0.5, this.x + this.width/2, this.y + this.height/2, radius);
          gradient.addColorStop(0, 'rgba(255, 182, 193, 0.3)');
          gradient.addColorStop(0.7, 'rgba(255, 192, 203, 0.2)');
          gradient.addColorStop(1, 'rgba(255, 200, 210, 0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(this.x + this.width/2, this.y + this.height/2, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = 'rgba(255, 192, 203, 0.5)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(this.x + this.width/2, this.y + this.height/2, radius * 0.85, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }
      }
    }

    // 头像道具类
    class PowerUp {
      constructor(x, y, type) {
        this.width = canvasWidth / 8;
        this.height = this.width;
        this.x = x;
        this.y = y;
        this.speed = canvasHeight * 0.17; // 每秒移动0.16倍画布高度
        this.type = type;
        this.markedForDeletion = false;
      }

      update(deltaTime) {
        this.y += this.speed * (deltaTime / 1000);
        if (this.y > canvasHeight) {
          this.markedForDeletion = true;
          escapedItemCount++; // 道具到达边缘时计为幸存
        }
      }

      draw() {
        const image = assetImages[`chara${this.type}`];
        ctx.drawImage(image, this.x, this.y, this.width, this.height);
      }
    }

    // 第三关特殊道具类
    class CharaItem {
      constructor(x, y, itemNum, variant = 0) {
        this.width = canvasWidth / 8;
        this.height = this.width;
        this.x = x;
        this.y = y;
        this.speed = canvasHeight * 0.17;
        this.itemNum = itemNum; // 1-13
        this.variant = variant; // 变体编号
        this.markedForDeletion = false;
      }

      update(deltaTime) {
        this.y += this.speed * (deltaTime / 1000);
        if (this.y > canvasHeight) {
          this.markedForDeletion = true;
          //item6-3和item3属于阻碍物，不计入
          if(!(this.itemNum === 6 && this.variant === 3) && !(this.itemNum === 3)){
            escapedItemCount++;
          }
        }
      }

      draw() {
        let imgKey = `item${this.itemNum}`;
        if (this.variant > 0) {
          imgKey = `item${this.itemNum}_${this.variant}`;
        }
        const image = assetImages[imgKey];
        if (image) {
          ctx.drawImage(image, this.x, this.y, this.width, this.height);
        }
      }

      // 获取对应的角色编号
      getCharacterNum() {
        return this.itemNum;
      }
    }

    // 血包类
    class HealthPack {
      constructor(x, y) {
        this.width = canvasWidth / 12;
        this.height = canvasWidth / 8;
        this.x = x;
        this.y = y;
        this.speed = canvasHeight * 0.17;
        this.markedForDeletion = false;
      }

      update(deltaTime) {
        this.y += this.speed * (deltaTime / 1000);
        if (this.y > canvasHeight) {
          this.markedForDeletion = true;
          escapedItemCount++; // 血包到达边缘时计为幸存
        }
      }

      draw() {
        ctx.drawImage(assetImages.blood, this.x, this.y, this.width, this.height);
      }
    }

    // BOSS子弹类
    class BossBullet {
      constructor(x, y, targetX, targetY) {
        this.width = canvasWidth / 20;
        this.height = this.width;
        this.x = x;
        this.y = y;
        this.speedx = canvasHeight * 0.28; // BOSS子弹速度
        this.speedy = canvasHeight * 0.26; // BOSS子弹速度
        const angle = Math.atan2(targetY - y, targetX - x);
        this.vx = Math.cos(angle) * this.speedx;
        this.vy = Math.sin(angle) * this.speedy;
        this.markedForDeletion = false;
      }

      update(deltaTime) {
        this.x += this.vx * (deltaTime / 1000);
        this.y += this.vy * (deltaTime / 1000);
        if (this.x < 0 || this.x > canvasWidth || this.y < 0 || this.y > canvasHeight) {
          this.markedForDeletion = true;
          escapedBulletCount++; // BOSS子弹到达边缘时计为幸存
        }
      }

      draw() {
        ctx.drawImage(assetImages.bullet4, this.x, this.y, this.width, this.height);
      }
    }

    // BOSS类
    class Boss {
      constructor() {
        this.width = canvasWidth / 3; // BOSS宽度
        this.height = this.width * 1.1; // BOSS高度
        this.x = canvasWidth / 2 - this.width / 2; // X坐标（居中）
        this.y = -this.height; // Y坐标（从屏幕上方开始）
        this.targetY = canvasHeight * 0.1; // 第一阶段目标Y坐标
        this.baseSpeed = canvasHeight * 0.15; // 基础移动速度
        this.speedx = this.baseSpeed; // X轴方向的移动速度
        this.speedy = this.baseSpeed; // Y轴方向的移动速度
        this.directionX = 1; // X轴移动方向
        this.phase = 1; // 从阶段1开始
        this.gravity = canvasHeight * 0.1; // 【新增】重力加速度（像素/秒^2）
        this.bounceTargetY = canvasHeight * 0.3; // 弹跳目标Y坐标
        this.roamTimer = 0; // 游走计时器
        this.roamDuration = 0; // 当前游走持续时间
        this.animTimer = 0; // 动画计时器（毫秒）
        this.attackState = 'normal'; // 攻击状态：normal, raising, punching
        this.attackTimer = 0; // 攻击计时器
        this.shootTimer = 0;
        this.flashTimer = 0;
        this.bulletTimer = 0; // 子弹发射计时器
        this.isShooting = false; // 是否正在发射子弹
        this.bulletRows = 0; // 子弹束的数量
        this.shootedNumber = 0; //这一束已发射出去的子弹数
        this.bulletsNumber = 0; //这一束的子弹总数
        this.slowEffect = false; // 是否被减速
        this.slowTimer = 0; // 减速效果计时器
        this.downFactor = 0; // 下降速度因子（难度越大下降速度越快）
        this.bounceFactor = 0; // 反弹高度因子（难度越大反弹高度越低）
        this.bulletFactor = 0; // BOSS子弹数因子
        this.bloodFactor = 0; // BOSS血量因子
        this.hasShield = false; // BOSS是否有防护罩（第三关）
        this.defence = 0;
        // 根据难度设置参数
        let bossHealth = 0;
        if (currentDifficulty === 'easy') {
          if (currentLevel === 3) {
            bossHealth = 6000;
          }else if (currentLevel === 2) {
            bossHealth = 4500;
          }else{
            bossHealth = 800;
          }
          this.downFactor = 0.7;
          this.bounceFactor = 0.55;
          this.bulletFactor = 3;
          this.bloodFactor = 0.3;
          this.bulletRows = 1;
        } else if (currentDifficulty === 'normal' || currentDifficulty === 'endless') {
          if (currentLevel === 3) {
            bossHealth = 9500;
          }else if (currentLevel === 2) {
            bossHealth = 9000;
          }else{
            bossHealth = 1400;
          }
          this.downFactor = 1;
          this.bounceFactor = 0.65;
          this.bulletFactor = 5;
          this.bloodFactor = 0.5;
          this.bulletRows = 1;
        } else if (currentDifficulty === 'hard') {
          if (currentLevel === 3) {
            bossHealth = 14000;
          }else if (currentLevel === 2) {
            bossHealth = 13500;
          }else{
            bossHealth = 2800;
          }
          this.downFactor = 1.3;
          this.bounceFactor = 0.8;
          this.bulletFactor = 7;
          this.bloodFactor = 0.7;
          this.bulletRows = 1;
        }
        this.health = bossHealth; // 当前血量
        this.maxHealth = bossHealth; // BOSS初始血量
      }
      // 应用减速效果
      applySlow() {
        if (!this.slowEffect) {
          this.slowEffect = true;
          this.speedx = this.baseSpeed * 0.06;
          this.speedy = this.baseSpeed * 0.06;
          this.slowTimer = 3000; // 减速效果持续3秒
        }
      }
      // 更新BOSS状态和位置
      update(deltaTime, gameTime) {
        // 更新减速效果
        if (this.slowEffect) {
          this.slowTimer -= deltaTime;
          if (this.slowTimer <= 0) {
            this.slowEffect = false;
            this.speedx = this.baseSpeed; // 恢复原速度
            this.speedy = this.baseSpeed; // 恢复原速度
          }
        }
        const deltaSeconds = deltaTime / 1000;
        this.animTimer += deltaTime;
        if (this.flashTimer > 0) this.flashTimer -= deltaTime;

        // 第三关BOSS防护罩逻辑（BOSS血量20%以下时出现）
        if (currentLevel === 3) {
          const healthPercent = this.health / this.maxHealth;
          if (healthPercent <= 0.2 && !this.hasShield) {
            this.hasShield = true;
            // 增加创可贴出现概率
            protectProbability *= 2.4 + 0.25 * currentLevel;
            if(currentDifficulty === 'easy'){
              this.defence = 8;
            }else if (currentDifficulty === 'normal') {
              this.defence = 14;
            }else if (currentDifficulty === 'hard' || currentDifficulty === 'endless') {
              this.defence = 20;
            }
          }
        }
        // 第2、3关子弹束调整逻辑相同
        if (currentDifficulty === 'normal' || currentDifficulty === 'endless') {
          if(this.health <= this.maxHealth * 0.2) {
            this.bulletRows = 2;
          }
        } else if (currentDifficulty === 'hard') {
          if(this.health <= this.maxHealth * 0.2) {
            this.bulletRows = 3;
          }else if(this.health <= this.maxHealth * 0.4) {
            this.bulletRows = 2;
          }
        }
        const distanceToPlayer = player.y - (this.y + this.height);
        // BOSS接近玩家到距离小于玩家的身高时，变成举起拳头状态持续0.3秒
        if (distanceToPlayer >= 0 && distanceToPlayer <= player.height * 0.8 &&
          this.attackState === 'normal' && this.speedy >= 0) {
          this.attackState = 'raising';
          this.attackTimer = 300;
        }
        // 处理攻击状态
        if (this.attackState === 'raising') {
          this.attackTimer -= deltaTime;
          //砸拳头
          if (this.attackTimer <= 0) {
            this.attackState = 'punching';
            this.attackTimer = 300;// 砸拳头持续时间
          }
        } else if (this.attackState === 'punching') {
          this.attackTimer -= deltaTime;
          if (this.attackTimer <= 0) {
            this.attackState = 'normal';
          }
        }
        if (currentLevel > 1) {
          // 第2关BOSS达到一定血量以下,或无限模式下游戏时间超过15秒  进入阶段2
          if ((this.health <= this.maxHealth * this.bloodFactor || (currentDifficulty === 'endless' && gameTime > 20000))
            && this.phase === 1) {
            this.phase = 2;
          }
          if (this.phase === 1) {
            // 阶段1：左右游走
            if (this.y < this.targetY) this.y += this.speedy * deltaSeconds;
            else {
              this.x += this.speedx * this.directionX * deltaSeconds;
              if (this.x <= 0) {
                this.x = 0;
                this.directionX = 1;
              }
              if (this.x + this.width >= canvasWidth) {
                this.x = canvasWidth - this.width;
                this.directionX = -1;
              }
            }
          } else {
            // 阶段2：下降+游走
            // 检查是否在游走状态
            const isRoaming = this.roamTimer > 0 && this.roamTimer < this.roamDuration;

            if (!isRoaming) {
              // 下降（不锁定玩家）
              this.speedy += this.gravity * deltaSeconds * this.downFactor;
              this.y += this.speedy * deltaSeconds;
              // 触底反弹
              if (this.y + this.height >= canvasHeight) {
                this.y = canvasHeight - this.height;
                // 反弹到随机高度
                this.speedy = -(Math.random() * canvasHeight * 0.8 + canvasHeight * 0.2);
                this.bounceTargetY = Math.random() * canvasHeight * this.bounceFactor - canvasHeight * 0.35;
                if (this.bounceTargetY < 0) {
                  this.bounceTargetY = 0;
                }
                // 设置随机游走时间（4-6秒）
                this.roamDuration = Math.random() * 2000 + 4000;
                this.roamTimer = 0;
              }
              // 到达反弹高度后开始游走
              if (this.speedy < 0 && this.y <= this.bounceTargetY) {
                this.speedy = 0;
                this.roamTimer = 1; // 开始游走计时
              }
            } else {
              // 游走状态：只左右移动，不受重力影响
              this.roamTimer += deltaTime;
              this.x += this.speedx * this.directionX * deltaSeconds;
              if (this.x <= 0) {
                this.x = 0;
                this.directionX = 1;
              }
              if (this.x + this.width >= canvasWidth) {
                this.x = canvasWidth - this.width;
                this.directionX = -1;
              }

              // 游走时间结束，重置计时器准备下次下降
              if (this.roamTimer >= this.roamDuration) {
                this.roamTimer = 0;
                this.roamDuration = 0;
              }
            }
          }
          // 发射模式控制：BOSS每隔一段时间（4秒）发射一次子弹
          // 容易：每次发射 3~6 发（普通：5-8发，困难：7-10发）子弹，
          // 每颗子弹间隔 200ms
          this.shootTimer += deltaTime;
          if (!this.isShooting && this.shootTimer > 4000) {
            // 开始新的发射周期
            this.isShooting = true;
            this.bulletTimer = 0;
            this.shootTimer = 0;
            this.shootedNumber = 0; //这一轮已发射出去的子弹数
            this.bulletsNumber = Math.floor(Math.random() * 3) + this.bulletFactor; //子弹总数
          }
          if (this.isShooting) {
            this.bulletTimer += deltaTime;
            // 每200ms发射一个子弹
            if (this.bulletTimer >= 200) {
              // 发射多排并列子弹
              const spacing = this.width / (this.bulletRows + 1);
              for (let i = 0; i < this.bulletRows; i++) {
                const bulletX = this.x + spacing * (i + 1);
                bossBullets.push(new BossBullet(
                  bulletX,
                  this.y + this.height / 2,
                  player.x,
                  player.y
                ));
              }

              this.bulletTimer = 0;
              this.shootedNumber++;
               if (this.shootedNumber >= this.bulletsNumber) {
                // 发射完毕
                this.isShooting = false;
              }
            }
          }
        } else {
          // 第1关BOSS血量75%以下或游戏时间超过15秒 进入第二阶段
          if ((this.health <= this.maxHealth * 0.75 || gameTime > 15000) && this.phase === 1) {
            this.phase = 2;
          }
          if (this.phase === 1) {
            if (this.y < this.targetY) this.y += this.speedy * deltaSeconds;
            else {
              this.x += this.speedx * this.directionX * deltaSeconds;
              if (this.x <= 0) {
                this.x = 0;
                this.directionX = 1;
              }
              if (this.x + this.width >= canvasWidth) {
                this.x = canvasWidth - this.width;
                this.directionX = -1;
              }
            }
          } else {
            const targetX = player.x - this.width / 2;
            if (Math.abs(this.x - targetX) > 2) {
              this.x += (targetX - this.x) * 0.02;
            }
            // 难度越大，BOSS下降速度越快
            this.speedy += this.gravity * deltaSeconds * this.downFactor;
            this.y += this.speedy * deltaSeconds;
            // BOSS触底后反弹
            if (this.y + this.height >= canvasHeight) {
              this.y = canvasHeight - this.height;
              // 弹跳速度与屏幕高度关联
              this.speedy = -(Math.random() * canvasHeight * 0.8 + canvasHeight * 0.2);
              // bounceTargetY越小，代表BOSS反弹后的高度越接近画面顶部，
              this.bounceTargetY = Math.random() * canvasHeight * this.bounceFactor - canvasHeight * 0.35;
              if (this.bounceTargetY < 0) {
                this.bounceTargetY = 0;
              }
            }
            if (this.speedy < 0 && this.y <= this.bounceTargetY) {
              this.speedy = 0;
            }
          }
        }
      }

      // 绘制BOSS和血量条
      draw() {
        // 绘制阴影
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(this.x + this.width / 2, this.y + this.height, this.width * 0.4, this.width * 0.2, 0, 0, Math.PI * 2);
        ctx.fill();
        // BOSS受击时的闪光效果（暂时去掉）
        if (this.flashTimer > 0 && this.health > 0) {
          ctx.filter = 'brightness(200%) saturate(0%)';
        }
        // 根据攻击状态选择图片
        let currentImage;
        if (this.attackState === 'raising') {
          currentImage = assetImages.boss3; // 举起拳头
        } else if (this.attackState === 'punching') {
          currentImage = assetImages.boss4; // 砸下拳头
        } else {
          // 正常状态下的动画切换
          currentImage = Math.floor(this.animTimer / 400) % 2 === 0 ? assetImages.boss1 : assetImages.boss2;
        }

        ctx.drawImage(currentImage, this.x, this.y, this.width, this.height);
        ctx.filter = 'none';

        // 绘制BOSS防护罩（第三关）
        if (currentLevel === 3 && this.hasShield) {
          const time = performance.now();
          const radius = this.width * 0.6;
          const alpha = (Math.sin(time / 200) + 1) / 2 * 0.3 + 0.5;
          ctx.save();
          ctx.globalAlpha = alpha;
          const gradient = ctx.createRadialGradient(this.x + this.width/2, this.y + this.height/2, radius * 0.5, this.x + this.width/2, this.y + this.height/2, radius);
          gradient.addColorStop(0, 'rgba(255, 100, 100, 0.3)');
          gradient.addColorStop(0.7, 'rgba(255, 120, 120, 0.2)');
          gradient.addColorStop(1, 'rgba(255, 140, 140, 0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(this.x + this.width/2, this.y + this.height/2, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = 'rgba(255, 100, 100, 0.6)';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(this.x + this.width/2, this.y + this.height/2, radius * 0.85, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }

        // 绘制BOSS血量条（无尽模式下不显示）
        if (currentDifficulty === 'endless') {
          return;
        }
        const barWidth = canvasWidth * 0.6, barHeight = 20, barX = canvasWidth / 2 - barWidth / 2, barY = 10;
        ctx.fillStyle = '#555';
        ctx.fillRect(barX, barY, barWidth, barHeight);  // 背景条

        const hpPercent = this.health / this.maxHealth;
        // 根据血量百分比设置颜色
        ctx.fillStyle = hpPercent > 0.5 ? 'green' : (hpPercent > 0.2 ? 'orange' : 'red');
        ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);  // 血量条

        ctx.strokeStyle = 'white';
        ctx.strokeRect(barX, barY, barWidth, barHeight);  // 边框

        // 在血条中间显示血量数字
        ctx.font = 'bold 16px "Arial", sans-serif';
        ctx.fillStyle = '#ffffff';
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.textAlign = 'center';
        //ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
        // ctx.shadowOffsetX = 1;
        // ctx.shadowOffsetY = 1;
        // ctx.shadowBlur = 4;

        const healthText = `${Math.round(this.health)} / ${this.maxHealth}`;
        ctx.strokeText(healthText, canvasWidth / 2, barY + 15);
        ctx.fillText(healthText, canvasWidth / 2, barY + 15);
        // 清除阴影效果
        //ctx.shadowColor = 'transparent';
        // ctx.shadowOffsetX = 0;
        // ctx.shadowOffsetY = 0;
        // ctx.shadowBlur = 0;
      }
    }

    // 爆炸效果类
    class Explosion {
      constructor(x, y) {
        this.x = x;  // 爆炸中心X坐标
        this.y = y;  // 爆炸中心Y坐标
        this.particles = [];  // 粒子数组
        this.init();
      }

      // 初始化爆炸粒子
      init() {
        const particleCount = 8;  // 粒子数量
        for (let i = 0; i < particleCount; i++) {
          const angle = Math.random() * Math.PI * 2;  // 随机角度
          const speed = Math.random() * 3 + 1;  // 随机速度
          this.particles.push({
            x: this.x, y: this.y,  // 初始位置
            vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,  // 速度分量
            size: Math.random() * 8 + 4,  // 粒子大小
            life: Math.random() * 20 + 20,  // 生命周期
            opacity: 1,  // 透明度
            color: '#ff69b4'  // 粒子颜色
          });
        }
      }

      // 更新粒子状态
      update(deltaTime) {
        this.particles.forEach((p, index) => {
          p.x += p.vx * (deltaTime / 16.67);  // 基于时间的位置更新
          p.y += p.vy * (deltaTime / 16.67);  // 基于时间的位置更新
          p.life -= deltaTime / 16.67;  // 基于时间的生命值减少
          p.opacity = p.life / 30;  // 更新透明度
          if (p.life <= 0) this.particles.splice(index, 1);  // 移除死亡粒子
        });
      }

      // 绘制爆炸效果
      draw() {
        this.particles.forEach(p => {
          ctx.save();
          ctx.globalAlpha = p.opacity;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
      }

      // 检查爆炸是否结束
      isFinished() {
        return this.particles.length === 0;
      }
    }

    // 同类头像碰撞特效类（金色光芒向外扩散）
    class SameCharaEffect {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.life = 60; // 1秒（60帧）
        this.maxLife = 60;
        this.particles = [];
        // 创建多个金色粒子
        for (let i = 0; i < 12; i++) {
          const angle = (Math.PI * 2 * i) / 12;
          this.particles.push({
            angle: angle,
            distance: 0,
            speed: 2
          });
        }
      }

      update(deltaTime) {
        this.life -= deltaTime / 16.67;
        this.particles.forEach(p => {
          p.distance += p.speed;
        });
      }

      draw() {
        const alpha = this.life / this.maxLife;
        ctx.save();
        ctx.globalAlpha = alpha;

        this.particles.forEach(p => {
          const x = this.x + Math.cos(p.angle) * p.distance;
          const y = this.y + Math.sin(p.angle) * p.distance;

          // 绘制金色光芒
          ctx.fillStyle = '#FFD700';
          ctx.beginPath();
          ctx.arc(x, y, 6, 0, Math.PI * 2);
          ctx.fill();

          // 绘制外圈光晕
          const gradient = ctx.createRadialGradient(x, y, 0, x, y, 10);
          gradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
          gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(x, y, 10, 0, Math.PI * 2);
          ctx.fill();
        });

        ctx.restore();
      }

      isFinished() {
        return this.life <= 0;
      }
    }

    // 增益物品特效类（彩色光环扩散）
    class PowerUpEffect {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.life = 60; // 1秒
        this.maxLife = 60;
        this.radius = 0;
      }

      update(deltaTime) {
        this.life -= deltaTime / 16.67;
        this.radius += 3;
      }

      draw() {
        const alpha = this.life / this.maxLife;
        ctx.save();
        ctx.globalAlpha = alpha;

        // 绘制彩色光环
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
        gradient.addColorStop(0, 'rgba(255, 105, 180, 0.8)');
        gradient.addColorStop(0.5, 'rgba(147, 112, 219, 0.6)');
        gradient.addColorStop(1, 'rgba(255, 105, 180, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();

        // 绘制内圈闪光
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius * 0.3, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      isFinished() {
        return this.life <= 0;
      }
    }

    // 攻击力增量浮动文字类
    class AttackPowerFloatText {
      constructor(value) {
        this.value = value;
        this.x = 45 - uiAdjust + Math.trunc(playerAttackPower).toString().length * (uiFont * 0.6);
        this.y = 122;
        this.life = 1300; // 1.3秒
        this.maxLife = 1300;
      }

      update(deltaTime) {
        this.life -= deltaTime;
        this.y -= 0.1 * (deltaTime / 16.67); // 向上移动
      }

      draw() {
        const alpha = this.life / this.maxLife;
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.font = 'bold ' + (uiFont - 2) + 'px "Arial Black", "Helvetica", sans-serif';
        const isNegative = this.value < 0;
        ctx.fillStyle = isNegative ? '#FFFFFF' : '#FFD700';
        ctx.strokeStyle = isNegative ? '#FF0000' : '#000000';
        ctx.lineWidth = 2;
        ctx.textAlign = 'left';
        const absValue = Math.abs(this.value);
        const text = absValue >= 1 ? `${this.value > 0 ? '+' : ''}${Math.floor(this.value)}` : `${this.value > 0 ? '+' : ''}${this.value.toFixed(1)}`;
        ctx.strokeText(text, this.x, this.y);
        ctx.fillText(text, this.x, this.y);
        ctx.restore();
      }

      isFinished() {
        return this.life <= 0;
      }
    }

    // 闪光效果类
    class FlashEffect {
      constructor(x, y, isPlayer) {
        this.x = x;
        this.y = y;
        this.life = 15;
        this.maxLife = 15;
        this.images = [];
        this.angles = [];
        this.isPlayer = isPlayer;

        // 玩家碰撞只随机显示1张闪光图
        if(isPlayer){
          this.images.push(Math.random() < 0.5 ? assetImages.fire1 : assetImages.fire2);
        }else{
          // BOSS、小熊碰撞随机显示1-2张闪光图片
          const count = Math.random() < 0.5 ? 1 : 2;
          for (let i = 0; i < count; i++) {
            this.images.push(Math.random() < 0.5 ? assetImages.flash1 : assetImages.flash2);
            this.angles.push(Math.random() * Math.PI * 2);
          }
        }
      }

      update(deltaTime) {
        this.life -= deltaTime / 16.67;  // 基于时间的生命值减少
      }

      draw() {
        const alpha = this.life / this.maxLife;
        ctx.save();
        ctx.globalAlpha = alpha;

        for (let i = 0; i < this.images.length; i++) {
          ctx.save();
          if(!this.isPlayer){
            const offsetX = i * 20 - 10;
            const offsetY = i * 15 - 7;
            ctx.translate(this.x + offsetX, this.y + offsetY);
            ctx.rotate(this.angles[i]);
            ctx.drawImage(this.images[i], -25, -25, 50, 50);
          }else{
            ctx.translate(this.x, this.y);
            ctx.drawImage(this.images[i], -5, -25, 50, 50);
          }
          ctx.restore();
        }
        ctx.restore();
      }

      isFinished() {
        return this.life <= 0;
      }
    }



    // 初始化游戏
    function init() {
      currentLevel = parseInt(document.getElementById('level-selector').value);
      resizeCanvas();  // 调整画布尺寸
      player = new Player();  // 创建玩家
      bullets = [];  // 清空子弹数组
      bears = [];  // 清空小熊数组
      powerUps = [];  // 清空道具数组
      healthPacks = [];  // 清空血包数组
      bossBullets = [];  // 清空BOSS子弹数组
      charaItems = []; // 清空第三关道具
      playerBuffed = false;
      playerStunned = false;
      stunTimer = 0;
      stoneTimer = 0;
      playerAttackPower = 5; // 重置攻击力
      sameCharaEffects = []; // 清空同类头像特效
      attackPowerFloatTexts = []; // 清空攻击力增量文字
      playerShield = false; // 重置保护罩
      shieldTimer = 0;
      explosions = [];  // 清空爆炸数组
      flashEffects = [];  // 清空闪光效果数组
      boss = null;  // 重置BOSS
      bearKillCount = 0;  // 重置小熊击杀数
      killsSinceLastLife = 0;  // 重置回血计数器
      comboCount = 0;  // 重置连击数
      maxComboCount = 0;  // 重置最大连击数
      escapedBearCount = 0;  // 重置逃走小熊数
      escapedBulletCount = 0;  // 重置幸存BOSS子弹数
      escapedItemCount = 0;  // 重置幸存道具血包数
      destroyedBulletCount = 0;  // 重置玩家消灭的BOSS子弹数
      collectedItemCount = 0;  // 重置玩家吃掉的道具血包数
      buffItemCount = 0; //玩家吃掉的增益物品数
      normalItemCount = 0; //玩家吃掉的普通物品数
      stunCount = 0; //玩家眩晕次数
      shieldBearKillCount = 0; //击杀护盾小熊数
      maxPlayerAttack = 5; //玩家达到的最大攻击力
      deathCount = 0;  // 重置阵亡次数
      bearSpawnTimer = 0;  // 重置小熊生成计时器
      bossSpawned = false;  // 重置BOSS生成标志
      playerInvulnerable = false;  // 重置无敌状态
      invulnerabilityTimer = 0;  // 重置无敌计时器
      gameState = 'playing';  // 设置游戏状态为游戏中
      gameStartTime = performance.now();  // 记录游戏开始时间

      // 清空结算界面的所有字段内容
      document.getElementById('result-diff').textContent = '';
      document.getElementById('result-time').textContent = '';
      document.getElementById('result-kill').textContent = '';
      document.getElementById('result-combo-text').textContent = '';
      document.getElementById('result-total-text').textContent = '';
      // 隐藏图标
      let fullcombo = document.getElementById('result-fullcombo');
      fullcombo.style.display = 'none';
      fullcombo.src = IMG_PATH + assets.fullcombo;
      document.getElementById('result-rank').style.display = 'none';
      if (currentLevel > 1) {
        playerHealth = 3;
        playerBulletStreams = 1; // 重置子弹束数量
      }
      if (currentDifficulty === 'easy') {
        // 小熊每800毫秒出现一次
        bearInterval = 800;
        // 小熊每列生成概率，中等难度64%概率生成，也就是每行6*0.6=3.6个熊
        bearProbability = currentLevel < 3 ? 0.5 : 0.48;
        maxPlayerBulletStreams = 10;
        itemProbability = 0.3;
        healthProbability = currentLevel < 3 ? 0.3 : 0.15;
        damageProbability = 0.1;
        protectProbability = 0.04
        maxShieldBears = 1;
        shieldBearsProbability = 0.15;
        // 游戏开始多少秒后生成BOSS
        bossBegan = 1000;
      } else if (currentDifficulty === 'normal' || currentDifficulty === 'endless') {
        bearInterval = currentLevel < 3 ? 750 : 790;
        bearProbability = currentLevel < 3 ? 0.6 : 0.49;
        maxPlayerBulletStreams = 14;
        itemProbability =  0.24;
        healthProbability = currentLevel < 3 ? 0.22 : 0.13;
        damageProbability = 0.13;
        protectProbability = 0.045;
        maxShieldBears = 2;
        shieldBearsProbability = 0.1;
        bossBegan = 2000;
      } else if (currentDifficulty === 'hard') {
        bearInterval = currentLevel < 3 ? 700 : 780;
        bearProbability = currentLevel < 3 ? 0.65 : 0.5;
        maxPlayerBulletStreams = 18;
        itemProbability =  0.18;
        healthProbability = currentLevel < 3 ? 0.18 : 0.11;
        damageProbability = 0.17;
        protectProbability = 0.05
        maxShieldBears = 3;
        shieldBearsProbability = 0.05;
        bossBegan = 3000;
      }
      //第三关固定物品出现概率
      if(currentLevel >= 3) {
        itemProbability = 0.5;
      }

      if (player) {
        player.defeatCharacters = []; // 清空defeat角色
        player.characters = [1]; // 重置角色类型数组
        player.deadCharacterType = 1; // 重置死亡角色类型
        if (currentLevel > 1) {
          player.currentCharacterType = 1;
        }
      }
    }

    // 生成小熊
    function spawnBears() {
      const numColumns = 6; // 列数
      const bearWidth = canvasWidth / 6;  // 每列宽度
      for (let i = 0; i < numColumns; i++) {
        if (Math.random() < bearProbability) {
          const x = i * bearWidth;  // 计算X坐标
          const y = -bearWidth;  // 从屏幕上方开始
          let canSpawn = true;
          // 检查是否与BOSS重叠
          if (boss && boss.y > -boss.height) {
            const bossLeft = boss.x;
            const bossRight = boss.x + boss.width;
            const bearLeft = x;
            const bearRight = x + bearWidth;
            if (!(bearRight <= bossLeft || bearLeft >= bossRight)) {
              canSpawn = false;  // 与BOSS重叠，不生成
            }
          }
          if (canSpawn) {
            let hasShield = false;
            // BOSS血量小于0.5时，按概率生成带防护罩的小熊
            if (currentLevel === 3 && boss) {
              const percent = boss.health / boss.maxHealth;
              const maxBears = calculateMaxBears(percent, maxShieldBears);
              if (maxBears > 0) {
                // 统计当前存在的防护罩小熊数量
                const shieldBearCount = bears.filter(b => b.hasShield && !b.markedForDeletion).length;
                if (shieldBearCount < maxBears) {
                  hasShield = Math.random() < shieldBearsProbability;
                }
              }
            }
            bears.push(new Bear(x, y, hasShield));
          }
        }
      }
    }

    function calculateMaxBears(percent, baseMax) {
      if (percent > 0.5) return 0;
      if (percent > 0.35) return Math.max(1, baseMax - 2);
      if (percent > 0.2) return Math.max(1, baseMax - 1);
      return baseMax;
    }

    // 生成道具和血包
    function spawnPowerUps() {
      // 第1关不生成
      if (currentLevel === 1) return;

      const minDistance = canvasWidth / 10; // 最小间距
      const newItems = [];

      if (currentLevel === 3) {
        // 第3关：生成特殊道具
        if (Math.random() < itemProbability) {
          let itemNum = Math.floor(Math.random() * 13) + 1;
          let variant = 0;
          if (Math.random() < damageProbability) {
            itemNum = Math.random() < 0.5 ? 3 : 6;
            variant = itemNum === 6 ? 3 : 0;
          } else if(Math.random() < protectProbability){
              itemNum = 6; variant = 2;
          } else {
            // 处理特殊变体
            if (itemNum === 5 && Math.random() < 0.5) {
              variant = Math.floor(Math.random() * 3) + 1; // 1,2,3
            } else if (itemNum === 6 && Math.random() < 0.5) {
              variant = Math.floor(Math.random() * 3) + 1;
            } else if (itemNum === 9 && Math.random() < 0.5) {
              variant = Math.floor(Math.random() * 2) + 1; // 1,2
            } else if (itemNum === 11 && Math.random() < 0.5) {
              variant = Math.floor(Math.random() * 2) + 1;
            }
          }
          const x = findValidPosition(canvasWidth / 8, newItems, minDistance);
          if (x !== -1) {
            charaItems.push(new CharaItem(x, -canvasWidth / 12, itemNum, variant));
            newItems.push({x, width: canvasWidth / 8});
          }
        }
      }
      // 角色图标
      if (Math.random() < itemProbability) {
        let type = null;
        if (currentLevel === 3) {
          type = Math.floor(Math.random() * 13) + 1;
        }else {
          type = Math.floor(Math.random() * 3) + 1;
        }
        const x = findValidPosition(canvasWidth / 8, newItems, minDistance);
        if (x !== -1) {
          powerUps.push(new PowerUp(x, -canvasWidth / 12, type));
          newItems.push({x, width: canvasWidth / 8});
        }
      }

      // 血包生成概率
      if (Math.random() < healthProbability) {
        const x = findValidPosition(canvasWidth / 12, newItems, minDistance);
        if (x !== -1) {
          healthPacks.push(new HealthPack(x, -canvasWidth / 12));
          newItems.push({x, width: canvasWidth / 12});
        }
      }
    }

    // 查找不重叠的有效位置
    function findValidPosition(itemWidth, existingItems, minDistance) {
      const maxAttempts = 10;
      for (let i = 0; i < maxAttempts; i++) {
        const x = Math.random() * (canvasWidth - itemWidth);
        let valid = true;

        for (const item of existingItems) {
          const distance = Math.abs(x + itemWidth/2 - (item.x + item.width/2));
          if (distance < minDistance) {
            valid = false;
            break;
          }
        }

        if (valid) return x;
      }
      return -1; // 找不到有效位置
    }

    // 处理所有碰撞检测
    function handleCollisions() {
      // 子弹与小熊的碰撞
      bullets.forEach(bullet => {
        if (bullet.markedForDeletion) return; // 跳过已标记的子弹
        bears.forEach(bear => {
          if (bear.markedForDeletion) return; // 跳过已标记的小熊
          if (isColliding(bullet, bear, 0)) {
            // 第三关小熊防护罩逻辑：子弹伤害值小于等于defence时不造成伤害。如果子弹束超过1，则取子弹束的1/2
            let actualDamage = Math.max(0, bullet.bearDamage * Math.max(1, playerBulletStreams/2) - bear.defence);
            if (actualDamage > 0) {
              flashEffects.push(new FlashEffect(bullet.x + bullet.width / 2, bullet.y + bullet.height / 2, false));
              bear.health -= (actualDamage > bear.health ? bear.health : actualDamage);
              bear.flashTimer = 50; //小熊闪白50毫秒
            }
            bullet.markedForDeletion = true; // 标记子弹待删除

            // player3形态子弹击中敌人时应用减速效果
            if (currentLevel > 1 && bullet.bulletType === 3) {
              bear.applySlow();
            }
            if (bear.health <= 0) {
              bear.markedForDeletion = true; // 标记小熊待删除
              bearKillCount++;
              if(bear.hasShield){
                shieldBearKillCount++;
              }
              killsSinceLastLife++;
              comboCount++;
              if (comboCount > maxComboCount) maxComboCount = comboCount;
              player.updateCharacterCount();
            }
          }
        });
      });

      // 子弹与BOSS的碰撞
      if (boss) {
        bullets.forEach(bullet => {
          if (bullet.markedForDeletion) return; // 跳过已标记的子弹
          if (isColliding(bullet, boss, 0)) {
            // 第三关BOSS防护罩逻辑：子弹伤害值小于等于defence时不造成伤害
            let actualDamage = 0;
            if (currentDifficulty !== 'endless') {
              actualDamage = Math.max(0, bullet.damage * Math.max(1, playerBulletStreams/2) - boss.defence);
            }
            if (actualDamage > 0) {
              flashEffects.push(new FlashEffect(bullet.x + bullet.width / 2, bullet.y + bullet.height / 2, false));
              boss.health -= (actualDamage > boss.health ? boss.health : actualDamage);
              if(boss.hasShield) {
                boss.flashTimer = 50; //BOSS闪白50毫秒
              }
            }
            bullet.markedForDeletion = true; // 标记子弹待删除
            // player3形态子弹击中敌人时应用减速效果
            if (currentLevel > 1 && bullet.bulletType === 3) {
              boss.applySlow();
            }
            if (boss.health <= 0 && gameState === 'playing') {
              gameState = 'bossDying';
              bossDeathPosition = {x: boss.x, y: boss.y, width: boss.width, height: boss.height};
              triggerScreenShake(15);
              setTimeout(() => gameOver(true), 400); // BOSS死亡400毫秒后游戏结束
            }
          }
        });
      }

      // 第2关：player3子弹与BOSS子弹的碰撞（抵消效果）
      if (currentLevel > 1) {
        bullets.forEach(playerBullet => {
          if (playerBullet.markedForDeletion || playerBullet.bulletType !== 3) return;
          bossBullets.forEach(bossBullet => {
            if (bossBullet.markedForDeletion) return;
            if (isColliding(playerBullet, bossBullet, 0)) {
              // 两者一起消失并触发闪光特效
              playerBullet.markedForDeletion = true;
              bossBullet.markedForDeletion = true;
              destroyedBulletCount++; // 玩家消灭BOSS子弹
              flashEffects.push(new FlashEffect(
                (playerBullet.x + bossBullet.x) / 2 + playerBullet.width / 2,
                (playerBullet.y + bossBullet.y) / 2 + playerBullet.height / 2, false
              ));
            }
          });
        });
      }

      // 小熊与玩家的碰撞
      bears.forEach(bear => {
        if (bear.markedForDeletion) return;
        // 第三关有保护罩时免疫小熊
        if (currentLevel === 3 && playerShield) {
          const playerHitbox = {
            x: player.x - player.width / 2,
            y: player.y,
            width: player.width,
            height: player.height
          };
          if (isColliding(bear, playerHitbox)) {
            // bear.markedForDeletion = true;
            // escapedBearCount++;
            // comboCount = 0;
            return;
          }
        }
        const totalWidth = player.width * player.characterCount;
        const startX = player.x - totalWidth / 2;

        for (let i = 0; i < player.characterCount; i++) {
          const charHitbox = {
            x: startX + i * player.width,
            y: player.y,
            width: player.width,
            height: player.height
          };

          if (isColliding(bear, charHitbox)) {
            bear.markedForDeletion = true;
            // 撞到玩家的小熊视为幸存 combo中断
            escapedBearCount++;
            comboCount = 0;
            playerBulletStreams = Math.ceil(playerBulletStreams / 2);
            triggerScreenShake(5);
            flashEffects.push(new FlashEffect(charHitbox.x, charHitbox.y, true));
            player.flashTimer = 200; //玩家闪白200毫秒
            checkDead(i);
            return;
          }
        }
      });

      // BOSS与玩家的碰撞（在无敌时间外且无保护罩）
      if (boss && !playerInvulnerable && !(currentLevel === 3 && playerShield)) {
        if (currentLevel > 1) {
          // 第2关：单个角色碰撞检测
          const playerHitbox = {
            x: player.x - player.width / 2,
            y: player.y,
            width: player.width,
            height: player.height
          };

          if (isColliding(boss, playerHitbox)) {
            playerInvulnerable = true;
            // 玩家无敌时间0.8秒，避免重复受到伤害
            invulnerabilityTimer = 800;
            playerBulletStreams = Math.ceil(playerBulletStreams / 2);
            player.flashTimer = 200; //玩家闪白200毫秒
            triggerScreenShake(8);
            flashEffects.push(new FlashEffect(playerHitbox.x, playerHitbox.y, true));
            checkDead(0);
          }
        } else {
          // 第1关：原有逻辑
          const totalWidth = player.width * player.characterCount;
          const startX = player.x - totalWidth / 2;

          for (let i = 0; i < player.characterCount; i++) {
            const charHitbox = {
              x: startX + i * player.width,
              y: player.y,
              width: player.width,
              height: player.height
            };

            if (isColliding(boss, charHitbox)) {
              playerInvulnerable = true;
              invulnerabilityTimer = 1800;
              player.flashTimer = 100; //玩家闪白100毫秒
              triggerScreenShake(8);
              flashEffects.push(new FlashEffect(charHitbox.x, charHitbox.y, true));
              checkDead(i);
              return;
            }
          }
        }
      }

      // 第2关的道具碰撞检测
      if (currentLevel > 1) {
        const playerHitbox = {
          x: player.x - player.width / 2,
          y: player.y,
          width: player.width,
          height: player.height
        };

        // BOSS的子弹与玩家碰撞
        bossBullets.forEach(bullet => {
          if (bullet.markedForDeletion) return;
          // 第三关有保护罩时免疫BOSS子弹
          if (currentLevel === 3 && playerShield && isColliding(bullet, playerHitbox)) {
            bullet.markedForDeletion = true;
            escapedBulletCount++;
            return;
          }
          if (isColliding(bullet, playerHitbox) && !playerInvulnerable) {
            bullet.markedForDeletion = true;
            escapedBulletCount++;
            playerInvulnerable = true;
            invulnerabilityTimer = 500;
            playerBulletStreams = Math.ceil(playerBulletStreams / 2);
            player.flashTimer = 100; //玩家闪白100毫秒
            triggerScreenShake(5);
            flashEffects.push(new FlashEffect(playerHitbox.x, playerHitbox.y, true));
            checkDead(0);
          }
        });

        // 头像道具碰撞
        powerUps.forEach(powerUp => {
          if (powerUp.markedForDeletion) return;
          if (isColliding(powerUp, playerHitbox, 2)) {
            // 第三关眩晕状态下无法切换角色
            if (currentLevel === 3 && playerStunned) {
              return;
            }
            powerUp.markedForDeletion = true;
            collectedItemCount++; // 玩家吃掉道具
            if (currentLevel === 3) {
              // 第三关逻辑
              if (player.currentCharacterType === powerUp.type) {
                // 吃到相同头像：攻击力+1
                changePlayerAttack(1);
                // 触发同类头像特效
                sameCharaEffects.push(new SameCharaEffect(playerHitbox.x + playerHitbox.width / 2, playerHitbox.y + playerHitbox.height / 2));
              } else {
                // 吃到不同头像：攻击力+0.1
                changePlayerAttack(0.1);
                if (playerBuffed) {
                  playerBuffed = false;
                  playerBuffTimer = 0;
                }
                player.currentCharacterType = powerUp.type;
              }
            }else {
              if (playerBulletStreams < maxPlayerBulletStreams) {
                playerBulletStreams++;
              }
            }
            // 切换到非5/6/7角色时取消保护罩。BOSS斩杀阶段不取消
            if (currentLevel === 3 && playerShield && powerUp.type !== 5 && powerUp.type !== 6 && powerUp.type !== 7) {
              if(boss && !boss.hasShield) {
                playerShield = false;
                shieldTimer = 0;
              }
            }
            player.currentCharacterType = powerUp.type;
          }
        });
        // 第三关特殊道具碰撞
        charaItems.forEach(item => {
          if (item.markedForDeletion) return;
          if (isColliding(item, playerHitbox, 2)) {
            const charNum = item.getCharacterNum();
            // item3和item6-3在有保护罩时直接无视
            if (playerShield && ((item.itemNum === 3) || (item.itemNum === 6 && item.variant === 3))) {
              return;
            }
            item.markedForDeletion = true;
            //item6-3和item3属于阻碍物，不计入
            if(!(item.itemNum === 6 && item.variant === 3) && !(item.itemNum === 3)){
              collectedItemCount++;
            }
            // item6-2（创可贴）特殊效果
            if (item.itemNum === 6 && item.variant === 2) {
              normalItemCount++;
              // 加一血
              playerHealth++;
              // 根据角色类型生成不同时长的保护罩
              if (player.currentCharacterType === 6) {
                playerShield = true;
                shieldTimer = 10000; // 10秒
              } else if (player.currentCharacterType === 5 || player.currentCharacterType === 7) {
                playerShield = true;
                shieldTimer = 7000; // 7秒
              }
              const percent = boss.health / boss.maxHealth;
              if (percent <= 0.5) {
                let factor = 1;
                if(percent <= 0.25){
                  factor = 2;
                }
                // BOSS血量在0.5以下，创可贴给所有5、6、7以外的角色提供3.6秒防护罩。所有角色加2点攻击力
                if (player.currentCharacterType !== 5 && player.currentCharacterType !== 6 && player.currentCharacterType !== 7) {
                  playerShield = true;
                  shieldTimer = (1800 + 250 * currentLevel) * factor;
                }
                let addPower = (1 + 0.25 * currentLevel) * factor;
                changePlayerAttack(addPower);
              }
              // 触发增益特效
              sameCharaEffects.push(new PowerUpEffect(playerHitbox.x + playerHitbox.width / 2, playerHitbox.y + playerHitbox.height / 2));
              return;
            }
            // item6-3（石头）特殊效果
            if (item.itemNum === 6 && item.variant === 3) {
              if (player.currentCharacterType === 6) {
                normalItemCount++;
                // 角色6（高松灯）撞到石头：攻击力+0.1
                changePlayerAttack(0.1);
                // 触发增益特效
                sameCharaEffects.push(new PowerUpEffect(playerHitbox.x + playerHitbox.width / 2, playerHitbox.y + playerHitbox.height / 2));
              } else {
                // 非角色6：切换到defeat状态1.5秒，无法射击，扣1生命值，子弹束减半，攻击力-3
                if (playerBuffed) {
                  playerBuffed = false;
                  playerBuffTimer = 0;
                }
                if(playerStunned){
                  playerStunned = false;
                  stunTimer = 0;
                }
                playerStoned = true;
                playerBulletStreams = Math.ceil(playerBulletStreams / 2);
                stoneTimer = 1500;
                triggerScreenShake(5);
                flashEffects.push(new FlashEffect(playerHitbox.x, playerHitbox.y, true));
                player.flashTimer = 200;
                checkDead(0);
              }
            }
            // item3（蘑菇）特殊效果
            else if (item.itemNum === 3) {
             if (player.currentCharacterType === 3) {
                normalItemCount++;
                // 角色3（仓田真白）撞到item3：攻击力+0.1
                changePlayerAttack(0.1);
                // 触发增益特效
                sameCharaEffects.push(new PowerUpEffect(playerHitbox.x + playerHitbox.width / 2, playerHitbox.y + playerHitbox.height / 2));
              } else {
                // 非角色3：眩晕3秒，攻击力-2
                if (playerBuffed) {
                  playerBuffed = false;
                  playerBuffTimer = 0;
                }
                stunCount++;
                playerStunned = true;
                stunTimer = 3000;
                // 角色6（高松灯）撞到蘑菇：额外掉血
                if (player.currentCharacterType === 6) {
                  checkDead(0);
                }else {
                  // 其他角色撞到蘑菇：攻击力-2
                  changePlayerAttack(-2);
                }
                flashEffects.push(new FlashEffect(playerHitbox.x, playerHitbox.y, true));
                player.flashTimer = 200;
              }
            }
            // 正常增益效果：匹配角色编号 (特例：item9-2对角色9和角色6都有增益效果）
            else if (player.currentCharacterType === charNum || (item.itemNum === 9 && item.variant === 2 && player.currentCharacterType === 6)) {
              buffItemCount++;
              if (!playerStunned) {
                playerBuffed = true;
                playerBuffTimer = 5000;
                // 第三关：增加1条弹道，攻击力+2
                if (playerBulletStreams < maxPlayerBulletStreams) {
                  playerBulletStreams++;
                  changePlayerAttack(2);
                }
                // 触发增益特效
                sameCharaEffects.push(new PowerUpEffect(playerHitbox.x + playerHitbox.width / 2, playerHitbox.y + playerHitbox.height / 2));
              }
            }else{
              //没有增益的物品，攻击力+0.2
              changePlayerAttack(0.2);
              normalItemCount++;
            }
          }
        });

        // 血包碰撞
        healthPacks.forEach(healthPack => {
          if (healthPack.markedForDeletion) return;
          if (isColliding(healthPack, playerHitbox, 2)) {
            healthPack.markedForDeletion = true;
            collectedItemCount++; // 玩家吃掉血包
            playerHealth++;
          }
        });

      }
    }

    function checkDead(hitCharacterIndex) {
      if (currentLevel > 1) {
        // 第2关死亡一次：减少血量、攻击力减3
        if(playerHealth > 0) {
          playerHealth--;
          deathCount++;
          changePlayerAttack(-3)
        }
        if (playerHealth <= 0) {
          player.deadCharacterType = player.currentCharacterType;
          player.isDead = true;
          setTimeout(() => gameOver(false), 400);
        }
      } else {
        deathCount++;
        // 第1关：原有逻辑
        if (player.characterCount > 1) {
          // 计算被击中角色的位置
          const totalWidth = player.width * player.characterCount;
          const startX = player.x - totalWidth / 2;
          const hitCharacterX = startX + hitCharacterIndex * player.width + player.width / 2;
          const hitCharacterType = player.characters[hitCharacterIndex];

          player.defeatCharacters.push({
            x: hitCharacterX,
            characterIndex: hitCharacterType,
            timer: 1200 // 角色被击败1200毫秒后消失
          });
          // 从角色数组中移除被击中的角色
          player.characters.splice(hitCharacterIndex, 1);
          player.characterCount--;
          killsSinceLastLife = 0;
        } else {
          player.deadCharacterType = player.characters[hitCharacterIndex];
          player.isDead = true;
          setTimeout(() => gameOver(false), 400);// 玩家死亡400毫秒后游戏结束
        }
      }
    }

    function changePlayerAttack(change){
      playerAttackPower = Math.max(1, playerAttackPower + change);
      if(change > 0){
        if(playerAttackPower > maxPlayerAttack) maxPlayerAttack = playerAttackPower;
      }
      attackPowerFloatTexts.push(new AttackPowerFloatText(change));
    }

    // 碰撞检测函数（矩形碰撞） margin表示留出的安全空间（单位是像素）
    // margin 越大 → 判定越“宽松”
    function isColliding(rect1, rect2, margin = 7) {
      return rect1.x + margin < rect2.x + rect2.width - margin &&
        rect1.x + rect1.width - margin > rect2.x + margin &&
        rect1.y + margin < rect2.y + rect2.height - margin &&
        rect1.y + rect1.height - margin > rect2.y + margin;
    }

    // 绘制道路中间线
    function drawRoad(deltaTime) {
      ctx.fillStyle = '#fff';
      const lineWidth = 15, lineHeight = 80, lineGap = 60;
      // 道路滚动速度与屏幕高度关联
      const roadSpeed = canvasHeight * 0.6;
      if (gameState === 'playing') {
        roadLineY += roadSpeed * (deltaTime / 1000);
      }
      if (roadLineY > lineHeight + lineGap) roadLineY = 0;

      for (let y = roadLineY - (lineHeight + lineGap); y < canvasHeight; y += lineHeight + lineGap) {
        ctx.fillRect(canvasWidth / 2 - lineWidth / 2, y, lineWidth, lineHeight);
      }
    }

    let lastTime = 0;  // 上一帧时间

    // 游戏主循环
    function gameLoop(timestamp) {
      updateFPS(); // 更新 FPS 显示
      const deltaTime = timestamp - lastTime;  // 计算帧间隔
      lastTime = timestamp;

      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      drawRoad(deltaTime); // 绘制道路

      // 将所有“游戏进行中”的逻辑（包括对象更新和清理）都放在这个代码块里
      if (gameState === 'playing') {
        const gameTime = timestamp - gameStartTime; // 计算游戏时间
        // 更新所有游戏对象
        bullets.forEach(bullet => bullet.update(deltaTime));
        bears.forEach(bear => bear.update(deltaTime));
        powerUps.forEach(powerUp => powerUp.update(deltaTime));
        healthPacks.forEach(healthPack => healthPack.update(deltaTime));
        bossBullets.forEach(bullet => bullet.update(deltaTime));
        charaItems.forEach(item => item.update(deltaTime));
        sameCharaEffects.forEach(effect => effect.update(deltaTime));
        attackPowerFloatTexts.forEach(text => text.update(deltaTime));
        // 更新眩晕状态
        if (playerStunned) {
          stunTimer -= deltaTime;
          if (stunTimer <= 0) {
            playerStunned = false;
          }
        }
        // 更新增益状态
        if (playerBuffed) {
          playerBuffTimer -= deltaTime;
          if (playerBuffTimer <= 0) {
            playerBuffed = false;
          }
        }
        // 更新摔倒状态
        if (playerStoned) {
          stoneTimer -= deltaTime;
          if (stoneTimer <= 0) {
            playerStoned = false;
          }
        }
        // 更新保护罩状态
        if (playerShield) {
          shieldTimer -= deltaTime;
          if (shieldTimer <= 0) {
            playerShield = false;
          }
        }
        if (boss) {
          boss.update(deltaTime, gameTime);
        }
        if (player) {
          // 更新玩家角色所在位置
          updatePlayerPosition(deltaTime);
          player.updateDefeatCharacters(deltaTime);
        }
        // 持续射击逻辑（眩晕时、被石头摔倒无法射击）
        if (isShooting && !playerStunned && !playerStoned) {
          shootTimer += deltaTime;
          if (shootTimer >= shootInterval) {
            player.shoot();
            shootTimer = 0;
          }
        }
        // 小熊生成计时器
        bearSpawnTimer += deltaTime;
        if (bearSpawnTimer > bearInterval) {
          spawnBears();
          spawnPowerUps(); // 生成道具和血包
          bearSpawnTimer = 0;
        }
        if (!bossSpawned && gameTime > bossBegan) {
          boss = new Boss();
          bossSpawned = true;
        }
        // 更新玩家无敌状态
        if (playerInvulnerable) {
          invulnerabilityTimer -= deltaTime;
          if (invulnerabilityTimer <= 0) {
            playerInvulnerable = false;
          }
        }

        handleCollisions(); // 处理碰撞
        // 将子弹和小熊数组的清理操作移到这里
        // 这样当游戏不再是'playing'状态时，它们就不会被移除，从而被定格在屏幕上
        bullets = bullets.filter(b => !b.markedForDeletion);
        bears = bears.filter(b => !b.markedForDeletion);
        powerUps = powerUps.filter(p => !p.markedForDeletion);
        healthPacks = healthPacks.filter(h => !h.markedForDeletion);
        bossBullets = bossBullets.filter(b => !b.markedForDeletion);
        charaItems = charaItems.filter(i => !i.markedForDeletion);
      }

      // BOSS死亡时的连续爆炸效果 (这个逻辑保持在外，因为它在 'bossDying' 状态下运行)
      if (gameState === 'bossDying' && Math.random() < 0.8) {
        const x = bossDeathPosition.x + Math.random() * bossDeathPosition.width;
        const y = bossDeathPosition.y + Math.random() * bossDeathPosition.height;
        // explosions.push(new Explosion(x, y));
        // flashEffects.push(new FlashEffect(x, y, false));
      }

      // 更新并过滤特效 (特效的生命周期独立于游戏状态)
      if (gameState !== 'paused') {
        flashEffects.forEach(flash => flash.update(deltaTime));
        explosions.forEach(exp => exp.update(deltaTime));
        flashEffects = flashEffects.filter(f => !f.isFinished());
        explosions = explosions.filter(e => !e.isFinished());
        sameCharaEffects = sameCharaEffects.filter(e => !e.isFinished());
        attackPowerFloatTexts = attackPowerFloatTexts.filter(t => !t.isFinished());
      }

      // 绘制所有游戏对象 (绘制逻辑永远在主干上，确保所有状态都能正确显示)
      bullets.forEach(b => b.draw());
      bears.forEach(b => b.draw());
      powerUps.forEach(p => p.draw());
      healthPacks.forEach(h => h.draw());
      bossBullets.forEach(b => b.draw());
      charaItems.forEach(i => i.draw());
      sameCharaEffects.forEach(e => e.draw());
      if (boss) boss.draw();
      attackPowerFloatTexts.forEach(t => t.draw());

      // 无敌状态下（被BOSS击中时）玩家角色闪烁，注释掉下面这一行就代表不闪烁
      //if (gameState == 'playing' && (!playerInvulnerable || Math.floor(invulnerabilityTimer / 100) % 2 === 0)) {
        player.draw(deltaTime);
      //}

      explosions.forEach(e => e.draw());
      flashEffects.forEach(f => f.draw());
      // 绘制UI信息
      drawGameUI();
      // 继续下一帧（如果游戏未结束且未暂停）
      if (gameState !== 'over' && gameState !== 'paused') gameLoopId = requestAnimationFrame(gameLoop);
    }

    // 开始游戏
    function startGame() {
      init();  // 初始化游戏
      startScreen.classList.add('hidden');  // 隐藏开始界面
      resultScreen.classList.add('hidden');  // 隐藏结算界面
      pauseMenu.classList.add('hidden');  // 隐藏暂停菜单

      // 显示游戏中的音乐控制按钮、暂停按钮
      document.getElementById('game-music-control').style.display = 'flex';
      document.getElementById('pause-button').style.display = 'flex';
      // 切换到战斗音乐（重新开始游戏时重置播放位置）
      if (battleMusic) {
        battleMusic.currentTime = 0;
        playMusic('battle');
      }
      lastTime = performance.now();  // 记录开始时间
      if (gameLoopId) cancelAnimationFrame(gameLoopId);  // 取消上一个游戏循环
      gameLoop(lastTime);  // 开始游戏循环
    }

    // 暂停游戏
    function pauseGame() {
      gameState = 'paused';
      pauseMenu.classList.remove('hidden');
      document.getElementById('pause-button').style.display = 'none';
      // 暂停音乐
      if (battleMusic) battleMusic.pause();
    }

    // 继续游戏
    function resumeGame() {
      gameState = 'playing';
      pauseMenu.classList.add('hidden');
      document.getElementById('pause-button').style.display = 'flex';
      lastTime = performance.now();
      // 继续音乐
      if (battleMusic && isMusicEnabled) battleMusic.play();
      gameLoopId = requestAnimationFrame(gameLoop);
    }

    // 提交分数
    function submitScore() {
      pauseMenu.classList.add('hidden');
      // 结束游戏并显示结算界面
      gameOver(false);
    }

    // 回到首页
    function backToHome() {
      init();
      gameState = 'over';  // 设置游戏状态为结束
      if (gameLoopId) cancelAnimationFrame(gameLoopId);  // 停止游戏循环
      // 隐藏游戏中的音乐控制按钮
      document.getElementById('game-music-control').style.display = 'none';
      document.getElementById('pause-button').style.display = 'none';
      // 切换到菜单音乐
      playMusic('menu');
      startScreen.classList.remove('hidden');  // 显示开始界面
      resultScreen.classList.add('hidden');  // 隐藏结算界面
      pauseMenu.classList.add('hidden');
    }

    // 绘制游戏UI
    function drawGameUI() {
      // 设置字体样式
      ctx.font = 'bold ' + uiFont + 'px "Arial Black", "Helvetica", sans-serif';
      ctx.fillStyle = '#ffffff';
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 2;
      //设置阴影
      // ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
      // ctx.shadowOffsetX = 1;
      // ctx.shadowOffsetY = 1;
      // ctx.shadowBlur = 4;

      // 绘制左上角生命值和音符子弹束信息
      const iconSize = 24;
      const noteSize = 16;
      ctx.textAlign = 'left';
      // 第一行：生命值（红心图标）- 显示当前生命值和失去生命值
      ctx.fillStyle = '#ff69b4'; // 粉色
      ctx.strokeText('❤️', 10, 62); // 红心emoji图标
      ctx.fillText('❤️', 10, 62);
      ctx.fillStyle = '#ffffff';// 恢复白色

      const currentHealthValue = currentLevel > 1 ? playerHealth : player.characterCount;
      let healthText = currentHealthValue.toString();
      // 只有失去生命后才显示横杠和失去生命值
      if (deathCount > 0) {
        healthText += '-' + deathCount.toString();
      }
      ctx.strokeText(healthText, 36 - uiAdjust, 62);
      ctx.fillText(healthText, 36 - uiAdjust, 62);

      // 第二行：音符和子弹束数量
      if (currentLevel > 1) {
        // 显示当前角色对应的音符图标
        const bulletImage = assetImages[`bullet${player.bulletType}`];
        if (bulletImage) {
          ctx.drawImage(bulletImage, 10, 75, noteSize, noteSize * 1.5);
        }
        let bulletStr = playerBulletStreams.toString();
        if(playerBulletStreams == maxPlayerBulletStreams){
          bulletStr = bulletStr + " max!";
        }
        ctx.strokeText(bulletStr, 36 - uiAdjust, 92);
        ctx.fillText(bulletStr, 36 - uiAdjust, 92);
      }
      // 第三行：攻击力显示（仅第三关）
      if (currentLevel === 3) {
        // 根据攻击力选择星星图标
        let starIcon = 'star1';
        if (playerAttackPower >= 50) starIcon = 'star6';
        else if (playerAttackPower >= 40) starIcon = 'star5';
        else if (playerAttackPower >= 30) starIcon = 'star4';
        else if (playerAttackPower >= 20) starIcon = 'star3';
        else if (playerAttackPower >= 10) starIcon = 'star2';

        const starImage = assetImages[starIcon];
        if (starImage) {
          ctx.drawImage(starImage, 6, 105, iconSize, iconSize);
        }
        var attackStr = Math.trunc(playerAttackPower).toString();
        ctx.strokeText(attackStr, 36 - uiAdjust, 122);
        ctx.fillText(attackStr, 36 - uiAdjust, 122);
      }

      // 绘制右上角积分图标和数字
      if (assetImages.scoreIcon) {
        ctx.drawImage(assetImages.scoreIcon, canvasWidth - 40, 45, iconSize, iconSize);

        ctx.textAlign = 'right';
        // 显示格式：击杀数-逃走数（如果有逃走小熊）
        const scoreText = escapedBearCount > 0 ? `${bearKillCount}-${escapedBearCount}` : bearKillCount.toString();
        ctx.strokeText(scoreText, canvasWidth - 55, 62);
        ctx.fillText(scoreText, canvasWidth - 55, 62);

        // 绘制combo数（第二行）
        ctx.drawImage(assetImages.comboIcon, canvasWidth - 52, 75, 50, 22);
        ctx.strokeText(comboCount.toString(), canvasWidth - 55, 92);
        ctx.fillText(comboCount.toString(), canvasWidth - 55, 92);
      }

      // 绘制游戏时间和难度模式（游戏中和结束时都显示）
      if (gameState === 'playing' || gameState === 'bossDying') {
        const barWidth = canvasWidth * 0.6;
        const barX = canvasWidth / 2 - barWidth / 2;
        ctx.font = 'bold ' + uiFont + ' "Arial", sans-serif';
        // 游戏时间（血条位置左侧）
        const gameTime = performance.now() - gameStartTime;
        const timeText = formatGameTime(gameTime);
        ctx.textAlign = 'right';
        ctx.strokeText(timeText, barX - 30, 25);
        ctx.fillText(timeText, barX - 30, 25);

        // 等级和难度（血条位置右侧）
        const texts = languages[currentLang];
        // const modeText = 'Lv.' + currentLevel + ' ' + texts[currentDifficulty].replace(texts.mode, '');
        const modeText = texts[currentDifficulty].replace(texts.mode, '');
        ctx.textAlign = 'left';
        ctx.strokeText(modeText, barX + barWidth + 15, 25);
        ctx.fillText(modeText, barX + barWidth + 15, 25);
      }

      // 清除阴影效果
      //ctx.shadowColor = 'transparent';
      // ctx.shadowOffsetX = 0;
      // ctx.shadowOffsetY = 0;
      // ctx.shadowBlur = 0;
    }

    // 格式化游戏时间
    function formatGameTime(milliseconds) {
      const totalSeconds = Math.floor(milliseconds / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function roundTo2(num) {
      return Math.round((num * 100 + Number.EPSILON) * 100) / 100;
    }

    // 游戏结束
    function gameOver(isWin) {
      //避免重复执行
      if (gameState == 'over') {
        return;
      }
      gameState = 'over';  // 设置游戏状态为结束
      // 切换到结束音乐
      playMusic('end');
      cancelAnimationFrame(gameLoopId);  // 停止游戏循环
      const gameTime = performance.now() - gameStartTime;

      // 计算最终得分
      const killScore = Math.max(0, (bearKillCount - escapedBearCount) * 20);
      const comboScore = maxComboCount * 20;
      const deathPenalty = currentDifficulty === 'endless' ? deathCount * 10 : deathCount * 50;
      const fullComboScore = (isWin && (maxComboCount == bearKillCount)) ? maxComboCount * 10 : 0;
      const bossScore = boss ? (boss.maxHealth - boss.health) * 5 : 0;
      const bearRatio = bearKillCount > 0 ? bearKillCount / (bearKillCount + escapedBearCount) : 0;
      const bossRatio = boss ? (boss.maxHealth - boss.health) / boss.maxHealth : 0;
      const playerRatio = currentLevel == 1 ? (player.characterCount / maxPlayerCharacter) : (playerBulletStreams / maxPlayerBulletStreams);
      const playerRatioScore = isWin ? playerRatio * 50 : playerRatio * 4;
      const bulletRatio = destroyedBulletCount > 0 ? destroyedBulletCount / (destroyedBulletCount + escapedBulletCount) : 0;
      const bulletRatioScore = isWin ? bulletRatio * 1000 : bulletRatio * 20;
      const itemRatio = collectedItemCount > 0 ? collectedItemCount / (collectedItemCount + escapedItemCount) : 0;
      const itemRatioScore = isWin ? itemRatio * 1000 : itemRatio * 5;
      const bearRatioScore = isWin ? bearRatio * 1000 : bearRatio * 10;
      const gameSeconds = Math.floor(gameTime / 1000);
      const timeScore = ((currentDifficulty === 'endless' && gameSeconds > 60) ? (gameSeconds - 60) * 50 : gameSeconds);
      const resultRank = getResultRank(bearRatio, bossRatio, deathCount, gameSeconds);
      let finalScore = Math.floor(Math.max(0, killScore + bossScore + comboScore - deathPenalty + fullComboScore
        + playerRatioScore + bulletRatioScore + itemRatioScore + timeScore));
      if(currentLevel >= 3){
        let level3Score = buffItemCount * 180 + normalItemCount * 25 + (isWin ? playerHealth * 20 : playerHealth)
          + (isWin ? bossScore * 0.75 : bossScore * 0.1) + (isWin ? comboScore * 2 : 0) + fullComboScore * 5
          + shieldBearKillCount * 360 + bearKillCount * 12
          + itemRatioScore * 3 + bulletRatioScore * 6 + bearRatioScore * 4
          + (isWin ? maxPlayerAttack * 120 : (maxPlayerAttack > 6 ? maxPlayerAttack * 1 : 0))
          + (isWin ? playerAttackPower * 240 : (playerAttackPower > 6 ? playerAttackPower * 2 : 0));

        let minusScore =  (isWin ? escapedBearCount * 270 : escapedBearCount * 2) + (isWin ? deathCount * 1350 : deathCount * 2)
           + (isWin ? stunCount * 240 : stunCount * 2) + (isWin ? timeScore * 120 : 0);
        // 扣减分数不超过扣减前分数的90%，避免得分过低
        if(minusScore > (finalScore + level3Score) * 0.9) {
          minusScore = (finalScore + level3Score) * 0.9
        }
        finalScore = Math.floor(finalScore + level3Score - minusScore);
      }
      //发送游戏统计
      try {
        gameStat(getPlayerId(), currentLevel, currentDifficulty, fps, isWin ? 1 : 0, resultRank, gameSeconds, bearKillCount, escapedBearCount, maxComboCount, (currentLevel > 1 ? playerHealth : player.characterCount),
          deathCount, roundTo2(bossRatio), roundTo2(bulletRatio), roundTo2(itemRatio), finalScore);
      } catch (e) {
        //忽略报错
      }
      // 显示结算动画
      showScoreAnimation(isWin, killScore, maxComboCount, finalScore, gameTime, bearRatio, deathCount, resultRank);
    }

    // 结算动画函数
    function showScoreAnimation(isWin, killScore, maxComboCount, finalScore, gameTime, bearRatio, deathCount, resultRank) {
      const texts = languages[currentLang];
      // 显示结算界面
      resultScreen.classList.remove('hidden');
      // 获取DOM元素
      const diffEl = document.getElementById('result-diff');
      const timeEl = document.getElementById('result-time');
      const killEl = document.getElementById('result-kill');
      const comboTextEl = document.getElementById('result-combo-text');

      const totalEl = document.getElementById('result-total-text');
      const imageEl = document.getElementById('result-image');
      const messageEl = document.getElementById('result-message');
      const restartBtn = document.getElementById('restart-button');

      // 设置图片和消息
      if (isWin) {
        imageEl.src = assetImages.win.src;
        imageEl.alt = 'YOU WIN';
        messageEl.textContent = texts.winMessage;
        restartBtn.textContent = texts.playAgain;
      } else {
        imageEl.src = assetImages.defeat.src;
        imageEl.alt = 'DEFEAT';
        messageEl.textContent = texts.defeatMessage;
        restartBtn.textContent = texts.retry;
      }

      // 回到首页按钮文本不变
      document.getElementById('home-button').textContent = texts.backToHome;

      // 设置固定内容
      diffEl.textContent = `${texts['level'+currentLevel]}: ${texts[currentDifficulty]}`;
      timeEl.textContent = `${texts.gameTime}: ${formatGameTime(gameTime)}`;
      //数字动态递增动画
      const animateLine = (targetValue, label, element, callback) => {
        const duration = 1000;
        const frameRate = 60;
        const totalFrames = (duration / 1000) * frameRate;
        let frame = 0;

        const animate = () => {
          frame++;
          const progress = frame / totalFrames;
          const easeProgress = 1 - Math.pow(1 - progress, 3);
          const currentValue = Math.floor(targetValue * easeProgress);
          element.textContent = `${label}:  ${currentValue}`;

          if (frame < totalFrames) {
            requestAnimationFrame(animate);
          } else {
            setTimeout(callback, 100);
          }
        };
        animate();
      };

      setTimeout(() => {
        animateLine(killScore, texts.killScore, killEl, () => {
          animateLine(maxComboCount, texts.maxCombo, comboTextEl, () => {
            // maxCombo数值显示完毕后，根据fullComboScore决定是否显示fullcombo图片
            if (bearRatio === 1 && bearKillCount > 15) {
              document.getElementById('result-fullcombo').style.display = 'block';
            }
            animateLine(finalScore, texts.totalScore, totalEl, () => {
              if(resultRank){
                let rankImg = document.getElementById('result-rank');
                // 给HTML图片赋值src（结算界面的图片在showScoreAnimation中动态设置）
                rankImg.style.display = 'block';
                rankImg.src = IMG_PATH + assets['rank_' + resultRank];
              }
            });
          });
        });
      }, 100);
    }

    function getResultRank(bearRatio, bossRatio, deathCount, gameSeconds) {
      if(currentDifficulty === 'endless') {
        if(gameSeconds < 30){
          return "d";
        }else if(gameSeconds < 60){
          return "c";
        }else if(gameSeconds < 90){
          return "cp";
        }else if(gameSeconds < 120){
          return "b";
        }else if(gameSeconds < 180){
          return "bp";
        }else if(gameSeconds < 240){
          return "a";
        }else if(gameSeconds < 300){
          return "ap";
        }else if(gameSeconds < 450){
          return "s";
        }else if(gameSeconds < 600){
          return "sp";
        }else if(gameSeconds < 900){
          return "ss";
        }else if(gameSeconds < 1800){
          return "ssp";
        }else {
          return "sss";
        }
      }
      let rank = '';
      if(bossRatio <= 0.1){
        rank = 'd';
      }else if (bossRatio <= 0.4){
        rank = 'c';
      }else if (bossRatio <= 0.6){
        rank = 'cp';
      }else if (bossRatio <= 0.8){
        rank = 'b';
      }else if (bossRatio < 1){
        rank = 'bp'
      }else{
        if(bearRatio <= 0.6){
          rank = 'a';
        }else if(bearRatio <= 0.8){
          rank = 'ap';
        }else if(bearRatio < 1){
          rank = 's';
        }else{
          if(currentLevel === 1) {
            if (deathCount >= 9) {
              rank = 'sp';
            }else if (deathCount >= 6) {
              rank = 'ss';
            } else if (deathCount >= 3) {
              rank = 'ssp';
            } else {
              rank = 'sss';
            }
          }else {
            if (deathCount >= 8) {
              rank = 'sp';
            }else if (deathCount >= 4) {
              rank = 'ss';
            } else if (deathCount >= 1) {
              rank = 'ssp';
            } else {
              rank = 'sss';
            }
          }
        }
      }
      return rank;
    }

    // 调整画布尺寸
    function resizeCanvas() {
      const rect = container.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      canvasWidth = canvas.width;
      canvasHeight = canvas.height;
      if (player) {
        player.width = canvasWidth / 7;
        player.height = player.width * 1.2;
      }
      if (canvasWidth <= 390) {
        uiFont = 12;
        uiAdjust = 5;
      } else if (canvasWidth <= 450) {
        uiFont = 14;
        uiAdjust = 2;
      }
    }

    window.addEventListener('resize', resizeCanvas);  // 监听窗口大小变化

    // 定义一个目标位置的全局变量，方便玩家角色位置更新函数里使用
    let targetPos = {x: player ? player.x : 0, y: player ? player.y : 0};

    // 获取鼠标位置
    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
      return {x: evt.clientX - rect.left, y: evt.clientY - rect.top};
    }

    // 获取触摸位置
    function getTouchPos(evt) {
      const rect = canvas.getBoundingClientRect();
      return {x: evt.touches[0].clientX - rect.left, y: evt.touches[0].clientY - rect.top};
    }

    // 鼠标按下或触摸开始 开始射击
    function handleInputStart(x, y) {
      if (gameState === 'playing') {
        isShooting = true;
        shootTimer = shootInterval; // 立即射击第一发
        targetPos.x = x;
        targetPos.y = y;
      }
    }

    // 鼠标移动或触摸滑动 角色目标位置更新
    function handleInputMove(x, y) {
      if (gameState === 'playing') {
        targetPos.x = x;
        targetPos.y = y;
      }
    }

    // 鼠标松开/离开或触摸结束 停止射击
    function handleInputEnd() {
      if (gameState === 'playing') {
        isShooting = false;
        shootTimer = 0;
      }
    }

    // 玩家位置更新函数
    function updatePlayerPosition(deltaTime) {
      // 下面代码的作用是让玩家角色平滑移动，从而修复移动端点击任意位置会瞬移过去，不会接触到移动路线上任何物体的bug
      // speed数值越大，角色移动越接近真实的随鼠标移动/移动端瞬移，speed数值越小，角色移动的滞后性越大
      const speed = 2400;
      const dx = targetPos.x - player.x;
      const dy = targetPos.y - player.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance > 1) {
        const moveDist = Math.min(speed * deltaTime / 1000, distance); // 注意 deltaTime 单位 ms
        player.x += dx / distance * moveDist;
        player.y += dy / distance * moveDist;
      }

      // 下面三行代码作用是避免角色移动位置超出边界
      const totalWidth = player.width * player.characterCount;
      player.x = Math.max(totalWidth / 2, Math.min(canvasWidth - totalWidth / 2, player.x));
      player.y = Math.max(0, Math.min(canvasHeight - player.height, player.y));
    }

    // 鼠标按下
    container.addEventListener('mousedown', e => {
      const pos = getMousePos(e);
      handleInputStart(pos.x, pos.y);
    });

    //鼠标移动
    container.addEventListener('mousemove', e => {
      const pos = getMousePos(e);
      handleInputMove(pos.x, pos.y);
    });

    //鼠标松开按钮
    container.addEventListener('mouseup', handleInputEnd);

    // 如果希望鼠标移到画布范围以外依然保持射击，就注释下面这行
    // container.addEventListener('mouseleave', handleInputEnd);

    // 触摸开始 （手指首次触碰屏幕）
    container.addEventListener('touchstart', e => {
      // 阻止在按钮等UI元素上的默认行为
      if (e.target.tagName !== 'CANVAS') return;
      e.preventDefault();
      const pos = getTouchPos(e);
      handleInputStart(pos.x, pos.y);
    }, {passive: false});

    // 触摸移动 （手指在屏幕上滑动时连续触发）
    container.addEventListener('touchmove', e => {
      if (e.target.tagName !== 'CANVAS') return;
      e.preventDefault();
      const pos = getTouchPos(e);
      handleInputMove(pos.x, pos.y);
    }, {passive: false});

    // 触摸结束 (手指离开屏幕时触发)
    container.addEventListener('touchend', e => {
      if (e.target.tagName !== 'CANVAS') return;
      e.preventDefault();
      handleInputEnd();
    }, {passive: false});

    // 触摸取消 (系统取消触控，例如来电弹窗出现)
    container.addEventListener('touchcancel', e => {
      if (e.target.tagName !== 'CANVAS') return;
      e.preventDefault();
      handleInputEnd();
    }, {passive: false});


    // 屏幕震动效果函数
    function triggerScreenShake(intensity) {
      container.style.animation = `shake ${0.3}s`;  // 设置震动动画

      // 定义震动关键帧
      const keyframes = `@keyframes shake {
            10%, 90% { transform: translate3d(${-intensity / 4}px, 0, 0); }
            20%, 80% { transform: translate3d(${intensity / 2}px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(${-intensity}px, 0, 0); }
            40%, 60% { transform: translate3d(${intensity}px, 0, 0); }
        }`;

      // 使用动态样式表避免重复添加关键帧
      if (!document.getElementById('shake-style')) {
        const style = document.createElement('style');
        style.id = 'shake-style';
        document.head.appendChild(style);
      }
      document.getElementById('shake-style').innerHTML = keyframes;

      // 0.2秒后清除震动效果
      setTimeout(() => container.style.animation = '', 200);
    }

    document.addEventListener('DOMContentLoaded', () => {
      //发送请求
      sendStat();
      // 设置首页图片
      setIndexImage();
      // 创建音乐
      createMusic();
      // 初始化语言
      setLanguage();
      initFPS();
      // 初始化排行榜
      initLeaderboard();
      // 图片资源
      loadData();
      // 画布尺寸
      resizeCanvas();
    });
  })();
</script>

</body>
</html>
