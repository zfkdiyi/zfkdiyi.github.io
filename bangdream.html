<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>音符射手 元祖BanG Dream</title>
  <style>
    :root {
      --primary-color: #ff69b4; /* Hot Pink */
      --secondary-color: #9370db; /* Medium Purple */
      --text-color: #ffffff;
      --shadow-color: rgba(0, 0, 0, 0.5);
    }

    body {
      margin: 0;
      padding: 0;
      background-color: #333;
      color: var(--text-color);
      font-family: "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100dvh;
      overflow: hidden;
    }

    #game-container {
      position: relative;
      background-color: #6c757d;

      /* 保持 9:16 比例，最大化铺满 */
      width: 100vw;
      height: 100dvh;
      aspect-ratio: 9 / 16;

      /* 限制缩放，保证不会超出屏幕 */
      max-width: 500px;
      max-height: 100dvh;

      /* 居中显示，超出部分自动裁切 */
      object-fit: contain;
      overflow: hidden;

      box-shadow: 0 0 20px var(--shadow-color);
    }

    #game-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #707070; /* Road color */
    }

    .start-adjust {
      justify-content: flex-start !important;
    }

    .game-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background-color: rgba(0, 0, 0, 0.3);
      text-align: center;
      z-index: 10;
      transition: opacity 0.5s ease;
      padding-top: 0;
    }

    .game-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .overlay-title {
      margin: 15px 0px;
      font-size: 2rem;
      font-weight: bold;
      text-shadow: 0 0 10px var(--primary-color), 0 0 20px var(--primary-color);
      animation: pulse 1.5s infinite;
      @media (max-width: 500px) {
        font-size: 1.8rem;
      }
      @media (max-width: 375px) {
        font-size: 1.6rem;
        margin: 10px 0px;
      }
    }

    .result-text,
    .overlay-text {
      font-size: 22px;
      font-weight: 600; /* 稍微加粗 */
      color: #ffffff; /* 白色 */
      text-shadow: -2px -2px 0 #000,
      2px -2px 0 #000,
      -2px 2px 0 #000,
      2px 2px 0 #000,
      0 0 10px rgba(255, 105, 180, 0.8);
      /*text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5), 0 0 6px rgba(255, 105, 180, 0.6);  阴影 + 粉色光晕 */
      margin: 10px 0;
      line-height: 1.5;
      @media (max-width: 450px) {
        font-size: 18px;
        margin: 8px 0;
      }
    }

    .result-text {
      font-size: 24px;
      line-height: 1.6;
      margin: 0;
      @media (max-width: 450px) {
        font-size: 20px;
      }
    }

    .result-text > div {
      height: 1.6em;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #result-total-text,
    #result-combo-text {
      height: 1.6em;
      display: flex;
      justify-content: center;
    }

    .result-rank,
    .result-fullcombo {
      height: 1.4em;
      margin-left: 8px;
      display: none;
    }

    .end-button,
    .start-button {
      padding: 10px 20px;
      font-size: 1.3rem;
      font-weight: bold;
      color: var(--secondary-color);
      background-color: var(--text-color);
      border: none;
      border-radius: 20px;
      cursor: pointer;
      box-shadow: 0 5px 15px var(--shadow-color);
      transition: transform 0.2s, box-shadow 0.2s;
      @media (max-width: 400px) {
        padding: 8px 16px;
        font-size: 1.2rem;
      }
    }

    .end-button:hover,
    .start-button:hover {
      transform: scale(1.1);
      box-shadow: 0 8px 25px var(--shadow-color);
    }

    .end-button {
      margin: 15px 0px;
      @media (max-width: 400px) {
        margin: 12px 0px;
      }
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.05);
      }
      100% {
        transform: scale(1);
      }
    }

    .difficulty-selector,
    .language-selector {
      display: flex;
      gap: 10px;
      margin: 10px 0;
      transition: opacity 0.3s ease;
      @media (max-width: 450px) {
        margin: 5px 0;
      }
    }

    .difficulty-selector.hidden,
    .language-selector.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .contact-btn,
    .difficulty-btn,
    .lang-btn {
      padding: 8px 12px;
      font-size: 16px;
      color: var(--text-color);
      background-color: rgba(0, 0, 0, 0.5);
      border: 2px solid transparent;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.2s;
      @media (max-width: 450px) {
        padding: 4px 8px;
        font-size: 14px;
      }
    }

    .contact-btn:hover,
    .difficulty-btn:hover,
    .lang-btn:hover {
      background-color: rgba(255, 105, 180, 0.3);
    }

    .contact-btn.active,
    .difficulty-btn.active,
    .lang-btn.active {
      border-color: var(--primary-color);
      background-color: rgba(255, 105, 180, 0.5);
    }

    .version-info {
      margin-top: 20px;
      font-size: 16px;
      color: rgba(255, 255, 255, 0.7);
      text-align: center;
      line-height: 1.6;
      @media (max-width: 400px) {
        font-size: 14px;
      }
    }

    .github-btn {
      margin-top: 4px;
      color: rgba(255, 255, 255, 0.7);
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 5px;
      transition: color 0.2s;
      position: relative;
      cursor: pointer;
    }

    .github-btn:hover {
      color: #ff69b4;
    }

    #fps-display {
      position: absolute;
      bottom: 5px;
      left: 5px;
      color: #0f0;
      font-size: 15px;
      font-weight: bold;
      text-shadow: 0 0 3px #000;
      z-index: 20;
      line-height: 1.2;
      cursor: pointer;
    }


    /* 联系作者部分 */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.4);
      justify-content: center;
      align-items: center;
    }

    .leaderboard-content,
    .modal-content {
      background-color: #fff;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
      width: 90%;
      max-width: 400px;
      text-align: left;
    }

    .modal-content h3 {
      margin-top: 0;
      font-size: 1.1rem;
      color: #333;
    }

    .leaderboard-modal {
      background-color: #333;
      color: #fff;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .leaderboard-modal h3 {
      color: #fff;
    }

    .modal-content textarea {
      width: 100%;
      height: 100px;
      margin: 10px 0;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #ccc;
      resize: none;
      font-size: 0.95rem;
      box-sizing: border-box;
    }

    .modal-actions {
      text-align: right;
    }

    .modal-actions button {
      margin-left: 10px;
      padding: 6px 12px;
      border: none;
      border-radius: 6px;
      background-color: #4caf50;
      color: #fff;
      cursor: pointer;
      font-size: 0.95rem;
      transition: background-color 0.3s ease;
    }

    .modal-actions button:hover {
      background-color: #45a049;
    }

    .modal-actions button#cancel-btn {
      background-color: #aaa;
    }

    .modal-actions button#cancel-btn:hover {
      background-color: #888;
    }

    .close {
      float: right;
      font-size: 1.3rem;
      cursor: pointer;
    }

    /* 排行榜样式 */
    .leaderboard-modal {
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .leaderboard-filters {
      display: flex;
      gap: 12px;
      margin: 15px 0;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap; /*允许换行*/
    }

    .leaderboard-filters select {
      padding: 8px 12px;
      border-radius: 20px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      background: rgba(0, 0, 0, 0.5);
      font-size: 14px;
      color: #fff;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 80px;
      max-width: 120px;
      flex-shrink: 1;
    }

    .leaderboard-filters select:hover {
      border-color: var(--primary-color);
    }

    .leaderboard-list {
      max-height: 400px;
      overflow-y: auto;
    }

    .leaderboard-item {
      display: flex;
      align-items: center;
      padding: 12px;
      margin: 8px 0;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      transition: transform 0.2s;
    }

    .leaderboard-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .leaderboard-item.highlight {
      background: rgba(255, 105, 180, 0.3);
      border: 2px solid var(--primary-color);
      box-shadow: 0 0 15px rgba(255, 105, 180, 0.5);
    }

    .leaderboard-rank {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 24px;
      margin-right: 15px;
      color: #fff;
    }

    .leaderboard-rank.rank-1 {
      background: linear-gradient(135deg, #ffd700, #ffed4e);
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
    }

    .leaderboard-rank.rank-2 {
      background: linear-gradient(135deg, #c0c0c0, #e8e8e8);
      box-shadow: 0 0 15px rgba(192, 192, 192, 0.5);
    }

    .leaderboard-rank.rank-3 {
      background: linear-gradient(135deg, #cd7f32, #daa520);
      box-shadow: 0 0 15px rgba(205, 127, 50, 0.5);
    }

    .leaderboard-rank.rank-other {
      background: linear-gradient(135deg, #6c757d, #868e96);
    }

    .leaderboard-info {
      flex: 1;
      color: #fff;
    }

    .leaderboard-name {
      font-weight: bold;
      font-size: 16px;
      margin-bottom: 4px;
      color: #fff;
    }

    .leaderboard-details {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.8);
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .leaderboard-score {
      font-size: 22px;
      font-weight: bold;
      color: #fff;
      text-align: right;
      width: 130px;
      text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 0 0 8px rgba(255, 105, 180, 0.8);
      display: flex;
      align-items: center;
      justify-content: flex-end;
    }

    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid var(--primary-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .empty-leaderboard {
      text-align: center;
      padding: 40px 20px;
      color: rgba(255, 255, 255, 0.7);
      font-size: 16px;
    }

    @media (max-width: 450px) {
      .leaderboard-content {
        padding: 8px;
      }
      .leaderboard-filters {
        gap: 10px;
      }

      .leaderboard-item {
        padding: 10px;
      }

      .leaderboard-rank {
        width: 35px;
        height: 35px;
        font-size: 18px;
        margin-right: 10px;
      }

      .leaderboard-details {
        font-size: 12px;
        gap: 8px;
      }

      .leaderboard-score {
        font-size: 16px;
        width: 100px;
      }
    }


    .music-control:hover {
      background: rgba(255, 105, 180, 1);
      box-shadow: 0 6px 20px rgba(255, 105, 180, 0.6);
    }

    .music-control svg {
      width: 20px;
      height: 20px;
      fill: white;
      transition: all 0.2s ease;
    }

    .level-selector {
      margin: 6px 0;
      padding: 10px 16px;
      font-size: 16px;
      color: var(--text-color);
      background-color: rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 120px;
      text-align: center;
      @media (max-width: 450px) {
        padding: 8px 14px;
        font-size: 14px;
        min-width: 100px;
      }
    }

    .level-selector:hover {
      border-color: var(--primary-color);
    }



    .button-row {
      margin: 10px 0;
      display: grid; /* 1. 使用 Grid 布局 */
      grid-template-columns: 1fr auto 1fr; /* 2. 定义三列网格 */
      align-items: center; /* 垂直居中对齐所有项 */
      width: 100%;
      gap: 20px; /* 在列之间添加一些间距 */
    }

    /* 让第一列的元素（排行榜按钮）靠左对齐，
      第三列的元素（音乐控件）靠右对齐。
    */
    .button-row > .blank_button {
      justify-self: start; /* 在网格区域内靠左 */
    }

    .button-row > .start-button {
      justify-self: center; /* 它会自动位于中间 auto 列，无需特殊样式 */
    }

    .button-row > .music-control {
      /* justify-self: end;  在网格区域内靠右 */
    }

    .blank_button {
      visibility: hidden;
    }

    .music-control {
      width: 40px;
      height: 40px;
      background: rgba(255, 105, 180, 0.8);
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(255, 105, 180, 0.4);
    }

    /* 游戏中的音乐控制按钮 */
    .game-music-control {
      position: absolute;
      bottom: 15px;
      right: 15px;
      width: 32px;
      height: 32px;
      background: rgba(255, 105, 180, 0.8);
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(255, 105, 180, 0.4);
      z-index: 15;
    }

    .game-music-control:hover {
      background: rgba(255, 105, 180, 1);
      box-shadow: 0 6px 20px rgba(255, 105, 180, 0.6);
    }

    .game-music-control svg {
      width: 16px;
      height: 16px;
      fill: white;
      transition: all 0.2s ease;
    }

    @media (max-width: 400px) {
      .music-control {
        width: 36px;
        height: 36px;
      }

      .music-control svg {
        width: 18px;
        height: 18px;
      }

      .game-music-control {
        width: 28px;
        height: 28px;
        bottom: 10px;
        right: 10px;
      }

      .game-music-control svg {
        width: 14px;
        height: 14px;
      }
    }

    #loading-line {
      width: 60%;
      max-width: 400px;
      height: 10px;
      margin: 5px auto;
      background: rgba(255,255,255,0.2);
      border-radius: 6px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #loading-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #00d2ff, #3a7bd5);
      transition: width 0.25s ease-out;
    }

    #loading-text {
      text-align: center;
      color: white;
      font-size: 16px;
    }
    /* 去除移动端点击按钮的高亮闪框 */
    * {
      -webkit-tap-highlight-color: transparent;
    }
  </style>
</head>
<body>

<div id="game-container">
  <canvas id="game-canvas"></canvas>
  <div id="fps-display">
    <div>FPS: 0</div>
  </div>

  <!-- 游戏中的音乐控制按钮 -->
  <div id="game-music-control" class="game-music-control" style="display: none;">
    <svg id="game-music-icon-play" viewBox="0 0 24 24">
      <path
        d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
    </svg>
    <svg id="game-music-icon-mute" viewBox="0 0 24 24" style="display: none;">
      <path
        d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
    </svg>
  </div>

  <!-- 背景音乐 -->
  <div id="audio-container"></div>

  <div id="start-screen" class="game-overlay start-adjust">
    <img id="header-image" style="width: 100%; position: absolute; top: 0; left: 0; z-index: -1;">
    <div style="display: flex; flex-direction: column; align-items: center; margin-top: 20vh;">
      <h1 class="overlay-title" data-text="title">音符射手</h1>
      <p class="overlay-text" data-text="instructions">移动鼠标或手指来控制角色<br>按住屏幕持续发射音符！</p>
      <div class="difficulty-selector">
        <button class="difficulty-btn" data-text="easy">简单</button>
        <button class="difficulty-btn" data-text="normal">普通</button>
        <button class="difficulty-btn" data-text="hard">困难</button>
        <button class="difficulty-btn" data-text="endless">无尽模式</button>
      </div>
      <div style="display: flex; flex-direction: column; align-items: center;">
        <div>
          <select id="level-selector" class="level-selector">
            <option value="1" data-text="level1">第1关</option>
            <option value="2" data-text="level2">第2关</option>
          </select>
        </div>
        <div class="button-row">
          <button class="blank_button" ></button>
          <button id="start-button" class="start-button" data-text="startGame">开始游戏</button>
          <div id="music-control" class="music-control">
            <svg id="music-icon-play" viewBox="0 0 24 24">
              <path
                d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
            </svg>
            <svg id="music-icon-mute" viewBox="0 0 24 24" style="display: none;">
              <path
                d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
            </svg>
          </div>
        </div>
      </div>
      <div id="language-selector" class="language-selector">
        <button class="lang-btn" data-lang="zh">中文</button>
        <button class="lang-btn" data-lang="en">English</button>
        <button class="lang-btn" data-lang="ja">日本語</button>
        <button class="contact-btn" data-text="contact" id="contact-btn">联系作者</button>
      </div>
    </div>
    <div id="contact-modal" class="modal">
      <div class="modal-content">
        <span class="close">&times;</span>
        <h3 data-text="contact">联系作者</h3>
        <textarea id="contact-text" data-placeholder="contactHolder"
                  placeholder="请输入内容（不超过100字 如果你希望收到作者回复，记得留下邮箱地址）"
                  maxlength="100"></textarea>
        <div class="modal-actions">
          <button id="send-btn" data-text="submit">提交</button>
          <button id="cancel-btn" data-text="close">关闭</button>
        </div>
      </div>
    </div>
    <!-- 加载进度界面 -->
    <div>
      <img id="leaderboard-button" style="display: none; cursor: pointer"/>
    </div>
    <div id="loading-line">
      <div id="loading-fill"></div>
    </div>
    <div id="loading-text">Loading... 0%</div>


    <!-- 排行榜弹窗 -->
    <div id="leaderboard" class="modal">
      <div class="leaderboard-content leaderboard-modal">
        <span class="close" id="leaderboard-close">&times;</span>
        <h3 data-text="leaderboard">排行榜</h3>

        <div class="leaderboard-filters">
          <select id="lb-level">
            <option value="1" data-text="level1">第1关</option>
            <option value="2" data-text="level2">第2关</option>
          </select>
          <select id="lb-difficulty">
            <option value="easy" data-text="easy">简单</option>
            <option value="normal" data-text="normal">普通</option>
            <option value="hard" data-text="hard">困难</option>
            <option value="endless" data-text="endless">无尽模式</option>
          </select>
          <select id="lb-order">
            <option value="score" data-text="scoreOrder">积分顺序</option>
            <option value="rank" data-text="rankOrder">级别顺序</option>
          </select>
          <select id="lb-show">
            <option value="top30" data-text="top30">前30名</option>
            <option value="myPosition" data-text="myPosition">我的排名</option>
          </select>
        </div>


        <div id="leaderboard-list" class="leaderboard-list">
          <div class="loading-spinner"></div>
        </div>
      </div>
    </div>

    <div class="version-info">
      <div><span data-text="version">版本</span>: 0.5</div>
      <div><span data-text="updateTime">更新时间</span>: 2025-10-17</div>
      <div>
        <a href="https://github.com/zfkdiyi/bangdream" target="_blank" id="github-button" class="github-btn">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path
              d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
          </svg>
          GitHub
        </a>
      </div>
      <div id="online-count"></div>
      <div id="my-id"></div>
    </div>
  </div>

  <div id="result-screen" class="game-overlay hidden">
    <div style="display: flex; flex-direction: column; align-items: center; transform: translateY(-15%);">
      <div class="result-text">
        <div id="result-diff"></div>
        <div id="result-time"></div>
        <div id="result-kill"></div>
        <div id="result-combo">
          <span id="result-combo-text"></span>
          <img id="result-fullcombo" class="result-fullcombo">
        </div>
        <div id="result-total">
          <span id="result-total-text"></span>
          <img id="result-rank" class="result-rank">
        </div>
      </div>
      <img id="result-image" alt="RESULT"
           style="max-width: 80%; max-height: 60%; object-fit: contain;">
      <p id="result-message" class="overlay-text">不要灰心，再来一次！</p>
      <button id="restart-button" class="end-button" data-text="retry">重试</button>
      <button id="home-button" class="end-button" data-text="backToHome">回到首页</button>
    </div>
  </div>
</div>

<script>
  (function () {
    let mode = 'prod';
    // 公共前缀
    let IMG_PATH = mode == 'local' ? 'img/' : 'https://cdn.badmintonranks.com/bangdream/img/';
    let API_PATH = mode == 'local' ? 'http://localhost/dev-api/' : 'https://badmintonranks.com/prod-api/';
    let currentLang = 'zh';
    const languages = {
      zh: {
        title: '元祖！BanG Dream酱<br>音符射手',
        instructions: '移动鼠标或手指来控制角色<br>按住屏幕持续发射音符！',
        startGame: '开始游戏',
        defeatMessage: '不要灰心，再来一次！',
        retry: '重试一次',
        winMessage: '闪闪发光 心动不已！',
        playAgain: '再玩一次',
        backToHome: '回到首页',
        lives: '生命',
        score: '积分',
        version: '版本',
        updateTime: '更新时间',
        contact: '联系作者',
        submit: '提交',
        close: '关闭',
        contactHolder: '请输入内容（不超过100字 如果你希望收到作者回复，记得留下邮箱地址）',
        easy: '容易',
        normal: '中等',
        hard: '困难',
        endless: '无尽模式',
        gameTime: '用时',
        mode: '模式',
        alertEmpty: '请输入内容',
        alertFrequent: '请勿频繁提交',
        alertSuccess: '已成功提交！',
        alertError: '提交失败，请稍后重试',
        killScore: '击杀得分',
        maxCombo: '最大连击',
        totalScore: '总得分',
        level1: '第1关',
        level2: '第2关',
        scoreOrder: '积分顺序',
        rankOrder: '级别顺序',
        leaderboard: '排行榜',
        noData: '暂无排行数据',
        loadError: '加载失败，请稍后重试',
        myPosition: '我的位置',
        top30: '前30名'
      },
      en: {
        title: 'GANSO! BanG Dream Chan<br>Note Shooter',
        instructions: 'Move mouse or finger to control character<br>Hold screen to shoot notes continuously!',
        startGame: 'Start Game',
        defeatMessage: 'Don\'t give up, try again!',
        retry: 'Retry',
        winMessage: 'KIRAKIRA DOKIDOKI!',
        playAgain: 'Play Again',
        backToHome: 'Back to Home',
        lives: 'Lives',
        score: 'Score',
        version: 'Version',
        updateTime: 'Update time',
        contact: 'Contact Me',
        submit: 'Submit',
        close: 'Close',
        contactHolder: "Please enter your message (up to 100 characters). If you’d like a reply, don’t forget to leave your email address.",
        easy: 'Easy',
        normal: 'Normal',
        hard: 'Hard',
        endless: 'Endless',
        gameTime: 'Duration',
        mode: 'Mode',
        alertEmpty: 'Please enter content',
        alertFrequent: 'Please do not submit frequently',
        alertSuccess: 'Successfully submitted!',
        alertError: 'Submission failed, please try again later',
        killScore: 'Kill Score',
        maxCombo: 'Max Combo',
        totalScore: 'Total Score',
        level1: 'Level 1',
        level2: 'Level 2',
        scoreOrder: 'By Score',
        rankOrder: 'By Level',
        leaderboard: 'Score Ranking',
        noData: 'No leaderboard data',
        loadError: 'Failed to load, please try again later',
        myPosition: 'My Rank',
        top30: 'Top 30'
      },
      ja: {
        title: '「元祖！バンドリちゃん」<br>ノートシューター',
        instructions: 'マウスや指で キャラクターを操作<br>画面を押し続けて ノートを連射！',
        startGame: 'ゲーム開始',
        defeatMessage: '諦めないで、もう一度！',
        retry: 'リトライ',
        winMessage: 'キラキラドキドキ！',
        playAgain: 'もう一度',
        backToHome: 'ホームに戻る',
        lives: 'ライフ',
        score: 'ポイント',
        version: 'バージョン',
        updateTime: '更新日時',
        contact: 'お問い合わせ',
        submit: '送信',
        close: '閉じる',
        contactHolder: "内容を入力してください（100文字以内）。返信をご希望の方は、メールアドレスを忘れずにご記入ください。",
        easy: '簡単',
        normal: '普通',
        hard: '難しい',
        endless: '無限モード',
        gameTime: 'ゲーム時間',
        mode: 'モード',
        alertEmpty: '内容を入力してください',
        alertFrequent: '頻繁に送信しないでください',
        alertSuccess: '送信が完了しました！',
        alertError: '送信に失敗しました。しばらくしてからもう一度お試しください',
        killScore: '撃破スコア',
        maxCombo: '最大コンボ',
        totalScore: '合計スコア',
        level1: 'ステージ 1',
        level2: 'ステージ 2',
        scoreOrder: 'スコア順',
        rankOrder: 'レベル順',
        leaderboard: 'ランキング',
        noData: 'ランキングデータがありません',
        loadError: '読み込みに失敗しました。しばらくしてからもう一度お試しください',
        myPosition: '自分の順位',
        top30: 'Top 30'
      }
    };


    // 设首页图片
    const setIndexImage = () => {
      const randomIndex = Math.floor(Math.random() * 10) + 1;
      document.getElementById('header-image').src =
      'https://cdn.badmintonranks.com/bangdream/img/head' + randomIndex +'.jpg';
      document.getElementById('leaderboard-button').src = IMG_PATH + 'score_rank.png';
    };

    // 自动检测浏览器语言
    const detectLanguage = () => {
      const lang = (navigator.language || navigator.userLanguage || 'en').toLowerCase();
      if (lang.startsWith('zh')) return 'zh';
      if (lang.startsWith('ja')) return 'ja';
      return 'en';
    };
    // 更新语言内容
    const updateLanguage = (lang) => {
      const texts = languages[lang] || languages.en;
      // 更新文字内容
      document.querySelectorAll('[data-text]').forEach(el => {
        const key = el.dataset.text;
        if (texts[key]) el.innerHTML = texts[key];
      });
      // 更新 placeholder
      document.querySelectorAll('[data-placeholder]').forEach(el => {
        const key = el.dataset.placeholder;
        if (texts[key]) el.placeholder = texts[key];
      });
      // 更新页面标题 (用正则替换掉所有<br>换行符）
      document.title = texts.title.replace(/<br\s*\/?>/g, ' ');
      // 更新语言按钮状态
      document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.lang === lang);
      });
      // 更新关卡选择下拉框
      const levelSelector = document.getElementById('level-selector');
      if (levelSelector) {
        levelSelector.options[0].text = texts.level1;
        levelSelector.options[1].text = texts.level2;
      }
      // 更新排行榜下拉框
      const leaderboardSelects = ['level-selector', 'lb-level', 'lb-difficulty', 'lb-order', 'lb-show'];
      leaderboardSelects.forEach(selectId => {
        const selectEl = document.getElementById(selectId);
        if (selectEl) {
          Array.from(selectEl.options).forEach(option => {
            const key = option.dataset.text;
            if (key && texts[key]) option.text = texts[key];
          });
        }
      });
    };
    // 音乐控制相关变量
    let menuMusic, battleMusic, endMusic;
    let isMusicEnabled = false;

    // 公共前缀
    const audioPrefix = "https://cdn.badmintonranks.com/bangdream/music/";
    // 音乐文件名数组
    const musicFiles = [
      { id: "menu-music", file: "menu.mp3", loop: true },
      { id: "battle-music", file: "battle1.mp3", loop: true },
      { id: "end-music", file: "end.mp3", loop: true }
    ];
    // 遍历生成 <audio> 标签
    function createMusic() {
      const audioContainer = document.getElementById("audio-container");
      musicFiles.forEach(music => {
        const audio = document.createElement("audio");
        audio.id = music.id;
        audio.loop = music.loop;
        // auto表示浏览器尽可能地提前加载整个音频文件，以便用户一点击播放就能立即开始。
        // none表示浏览器不下载音频，除非用户点击播放。延迟大
        audio.preload = "auto";

        const source = document.createElement("source");
        source.src = `${audioPrefix}${music.file}`;
        source.type = "audio/mpeg";

        audio.appendChild(source);
        audioContainer.appendChild(audio);
        initMusicControl();
      });
    }
    // 播放指定音乐
    const playMusic = (musicType) => {
      let currentMusic = getTargetMusic(musicType);
      if(currentMusic) {
        // 暂停其他音乐（不重置时间）
        [menuMusic, battleMusic, endMusic].forEach(music => {
          if (music && music !== currentMusic) {
            music.pause();
            music.currentTime = 0;
          }
        });
        // 播放指定音乐
        if (isMusicEnabled) {
          currentMusic.play().catch(e => console.log('音乐播放失败:', e));
        }
      }
    };
    // 获取目标音乐对象
    const getTargetMusic = (musicType) => {
      if (musicType === 'menu') return menuMusic;
      if (musicType === 'battle') return battleMusic;
      if (musicType === 'end') return endMusic;
      return null;
    };

    // 更新音乐按钮图标
    const updateMusicIcons = () => {
      const playIcons = document.querySelectorAll('[id$="-icon-play"]');
      const muteIcons = document.querySelectorAll('[id$="-icon-mute"]');

      playIcons.forEach(icon => {
        icon.style.display = isMusicEnabled ? 'none' : 'block';
      });
      muteIcons.forEach(icon => {
        icon.style.display = isMusicEnabled ? 'block' : 'none';
      });
    };

    // 切换音乐开关
    const toggleMusic = () => {
      isMusicEnabled = !isMusicEnabled;
      updateMusicIcons();

      if (!isMusicEnabled) {
        // 关闭音乐（保持当前播放位置）
        [menuMusic, battleMusic, endMusic].forEach(music => {
          if (music) music.pause();
        });
      } else {
        // 开启音乐，根据当前状态播放对应音乐（从暂停位置继续）
        if (gameState === 'playing') {
          playMusic('battle');
        } else if (gameState === 'over') {
          const isGameOverScreen = !startScreen.classList.contains('hidden') ? false : true;
          if (isGameOverScreen) {
            playMusic('end');
          } else {
            playMusic('menu');
          }
        } else {
          playMusic('menu');
        }
      }
    };
    // 初始化音乐控制
    const initMusicControl = () => {
      menuMusic = document.getElementById('menu-music');
      battleMusic = document.getElementById('battle-music');
      endMusic = document.getElementById('end-music');

      const musicControl = document.getElementById('music-control');
      const gameMusicControl = document.getElementById('game-music-control');
      // 主菜单音乐控制按钮
      musicControl.addEventListener('click', toggleMusic);
      // 游戏中音乐控制按钮
      gameMusicControl.addEventListener('click', toggleMusic);
      // Chrome不允许用户一打开网站就自动播放声音
    };

    // 初始化语言
    function setLanguage() {
      currentLang = detectLanguage();
      updateLanguage(currentLang);
      // 语言切换按钮监听
      document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          currentLang = btn.dataset.lang;
          updateLanguage(currentLang);
        });
      });
    }

    // 联系作者弹窗逻辑
    const contactBtn = document.getElementById('contact-btn');
    const modal = document.getElementById('contact-modal');
    const closeBtn = modal.querySelector('.close');
    const cancelBtn = document.getElementById('cancel-btn');
    const sendBtn = document.getElementById('send-btn');
    const textarea = document.getElementById('contact-text');
    contactBtn.onclick = () => {
      modal.style.display = 'flex';
    };
    closeBtn.onclick = cancelBtn.onclick = () => {
      modal.style.display = 'none';
      textarea.value = '';
    };
    sendBtn.onclick = async () => {
      const text = textarea.value.trim();
      if (!text) {
        alert(languages[currentLang].alertEmpty);
        return;
      }
      try {
        const response = await fetch(API_PATH + 'bilibiliContact', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: text
        });
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        const data = await response.json();
        if (data.code == 427) {
          alert(languages[currentLang].alertFrequent);
          return;
        }
        alert(languages[currentLang].alertSuccess);
        modal.style.display = 'none';
        textarea.value = '';
      } catch (error) {
        console.error(error);
        alert(languages[currentLang].alertError);
      }
    };
    // FPS显示
    const fpsDisplay = document.getElementById('fps-display');
    let lastTimes = performance.now();
    let frames = 0;
    let fps = 0;
    let fpsVisible = true;

    function updateFPS() {
      const now = performance.now();
      frames++;
      if (now - lastTimes >= 1000) { // 每秒更新一次
        fps = frames;
        frames = 0;
        lastTimes = now;
        fpsDisplay.textContent = 'FPS: ' + fps;
      }
    }
    // 初始化FPS显示状态
    function initFPS() {
      fpsDisplay.addEventListener('click', () => {
        fpsVisible = !fpsVisible;
        fpsDisplay.style.display = fpsVisible ? 'block' : 'none';
      });
    }

    //获取在线人数
    async function sendStat() {
      let from = document.referrer;
      let width = window.outerWidth;
      let height = window.window.outerHeight;
      let playerId = getPlayerId();
      const res = await fetch(API_PATH + 'openStat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({from, width, height, playerId})
      });
      const data = await res.json();
      if (data.online !== undefined) {
        document.getElementById('online-count').textContent = `Online: ${data.online}`;
      }
      if (data.playerId) {
        localStorage.setItem("playerId", data.playerId);
        playerId = data.playerId;
      }
      document.getElementById('my-id').textContent = `ID: ${playerId}`;
    }

    // 玩家ID管理
    let playerId = null;
    // 获取或生成玩家ID
    function getPlayerId() {
      if (playerId) return playerId;
      playerId = localStorage.getItem('playerId');
      if (!playerId || playerId.length < 1) {
        return "";
      }
      return playerId;
    }

    // 发送游戏结果统计
    async function gameStat(playerId, levels, difficulty, fps, win, ranks, duration, kumaKill, kumaLive,
                      maxCombo, life, lifeLost, bossRatio, bulletRatio, itemRatio, finalScore) {
      fetch(API_PATH + 'gameStat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          playerId, levels, difficulty, fps, win, ranks, duration, kumaKill, kumaLive,
          maxCombo, life, lifeLost, bossRatio, bulletRatio, itemRatio, finalScore
        })
      });
    }
    // 排行榜数据缓存
    let leaderboardData = null;
    // 排行榜功能
    async function loadLeaderboard(level, difficulty, playerId) {
      const listEl = document.getElementById('leaderboard-list');
      listEl.innerHTML = '<div class="loading-spinner"></div>';
      try {
        let url = `${API_PATH}getRanking?levels=${level}&difficulty=${difficulty}`;
        if(playerId) {
          url = `${API_PATH}getMyRanking?levels=${level}&difficulty=${difficulty}&playerId=${playerId}`;
        }
        const response = await fetch(url);
        const data = await response.json();
        leaderboardData = data.data;
        renderLeaderboard();
      } catch (e) {
        const texts = languages[currentLang];
        listEl.innerHTML = `<div class="empty-leaderboard">${texts.loadError}</div>`;
      }
    }

    // 渲染排行榜
    function renderLeaderboard() {
      const listEl = document.getElementById('leaderboard-list');
      const orderSelect = document.getElementById('lb-order');
      const orderType = orderSelect ? orderSelect.value : 'score';
      const currentPlayerId = getPlayerId();

      if (!leaderboardData || leaderboardData.length === 0) {
        const texts = languages[currentLang];
        listEl.innerHTML = `<div class="empty-leaderboard">${texts.noData}</div>`;
        return;
      }

      const texts = languages[currentLang];

      // 根据选择的排序方式对数据进行排序
      let sortedData = [...leaderboardData];
      if (orderType === 'rank') {
        // 按级别排序：SSS、SSP、SS、SP、S、AP、A、BP、B、CP、C、D
        const rankOrder = ['sss', 'ssp', 'ss', 'sp', 's', 'ap', 'a', 'bp', 'b', 'cp', 'c', 'd'];
        sortedData.sort((a, b) => {
          const rankA = a.ranks ? a.ranks.toLowerCase() : 'z';
          const rankB = b.ranks ? b.ranks.toLowerCase() : 'z';
          const indexA = rankOrder.indexOf(rankA);
          const indexB = rankOrder.indexOf(rankB);

          // 如果等级相同，按积分从高到低排序
          if (indexA === indexB) {
            return (b.final_score || 0) - (a.final_score || 0);
          }

          // 等级不同，按等级顺序排序（未找到的等级排在最后）
          if (indexA === -1) return 1;
          if (indexB === -1) return -1;
          return indexA - indexB;
        });
      }
      // 如果是积分排序，保持原有顺序（服务器已按积分排序）

      listEl.innerHTML = sortedData.map((item, index) => {
        const rank = item.user_rank;
        const rankClass = rank === 1 ? 'rank-1' : rank === 2 ? 'rank-2' : rank === 3 ? 'rank-3' : 'rank-other';
        const displayName = `${item.player_id || 'Unknown'}`;
        const createTime = `${item.create_time || ''}`;
        const timeStr = Math.floor(item.duration / 60) + ':' + (item.duration % 60).toString().padStart(2, '0');
        const rankIcon = item.ranks ? `<img src="${IMG_PATH}rank_${item.ranks.toLowerCase()}.png" style="height: 40px; margin-right: 8px;">` : '';
        const fullComboIcon = (item.full_combo === 1) ? `<img src="${IMG_PATH}full_combo.png" style="height: 20px;">` : '';

        // 高亮当前用户
        const isCurrentUser = currentPlayerId && item.player_id === currentPlayerId;
        const highlightClass = isCurrentUser ? ' highlight' : '';

        return `
          <div class="leaderboard-item${highlightClass}"">
            <div class="leaderboard-rank ${rankClass}">${rank}</div>
            <div class="leaderboard-info">
              <div class="leaderboard-name">${displayName}  <span style="font-size: 12px;
      color: rgba(255, 255, 255, 0.8);">${createTime}</span></div>
              <div class="leaderboard-details">
                <span>${texts.maxCombo}: ${item.max_combo}</span>
                <span>${texts.gameTime}: ${timeStr}</span>
                <span>${fullComboIcon}</span>
              </div>
            </div>
            <div class="leaderboard-score">
              ${rankIcon}${item.final_score}
            </div>
          </div>
        `;
      }).join('');
    }

    // 初始化排行榜
    function initLeaderboard() {
      const leaderboard = document.getElementById('leaderboard');
      const btn = document.getElementById('leaderboard-button');
      const closeBtn = document.getElementById('leaderboard-close');
      const levelSelect = document.getElementById('lb-level');
      const difficultySelect = document.getElementById('lb-difficulty');
      const orderSelect = document.getElementById('lb-order');
      const showSelect = document.getElementById('lb-show');

      // 打开排行榜
      btn.onclick = async () => {
        await getPlayerId();
        // 设置下拉框默认值为当前选择的等级和难度
        levelSelect.value = document.getElementById('level-selector').value;
        difficultySelect.value = currentDifficulty;
        showSelect.value = 'top30';
        leaderboard.style.display = 'flex';
        loadLeaderboard(levelSelect.value, difficultySelect.value, null);
      };

      // 关闭排行榜
      closeBtn.onclick = () => {
        leaderboard.style.display = 'none';
      };

      // 筛选变化时重新加载
      levelSelect.onchange = difficultySelect.onchange = showSelect.onchange = () => {
        loadLeaderboard(levelSelect.value, difficultySelect.value,
          showSelect.value === 'myPosition' ? getPlayerId() : null);
      };

      // 排序方式变化时只重新渲染
      orderSelect.onchange = () => {
        renderLeaderboard(levelSelect.value, difficultySelect.value, null);
      };

      // 点击模态框外部关闭
      leaderboard.onclick = (e) => {
        if (e.target === leaderboard) {
          leaderboard.style.display = 'none';
        }
      };
    }

    //游戏难度和模式选择
    let currentDifficulty = 'easy';
    let gameStartTime = 0;
    let currentLevel = 1;

    // 更新难度按钮被选中的状态
    function updateDifficultyButtons() {
      document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.classList.toggle('active', btn.getAttribute('data-text') === currentDifficulty);
      });
    }

    // 初始化难度按钮状态
    updateDifficultyButtons();
    // 难度按钮点击事件
    document.querySelectorAll('.difficulty-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        currentDifficulty = btn.getAttribute('data-text');
        updateDifficultyButtons();
      });
    });

    // 获取画布和容器元素
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('game-container');

    // 获取游戏界面元素
    const startScreen = document.getElementById('start-screen');
    const resultScreen = document.getElementById('result-screen');

    const startButton = document.getElementById('start-button');
    const restartButton = document.getElementById('restart-button');
    const homeButton = document.getElementById('home-button');
    startButton.addEventListener('click', startGame);// 开始游戏按钮
    restartButton.addEventListener('click', startGame);// 重试按钮
    homeButton.addEventListener('click', backToHome);// 回到首页按钮


    // 游戏基础变量
    let canvasWidth, canvasHeight;  // 画布尺寸
    let player, bullets, bears, boss, explosions;  // 游戏对象
    let powerUps = []; //道具
    let healthPacks = []; //血包
    let bossBullets = []; //BOSS子弹
    let uiFont = 16; // UI字体大小
    let uiAdjust = 0; // UI字体距离偏移量
    let bearSpawnTimer = 0;  // 小熊生成计时器
    let bearInterval = 0;  // 小熊生成间隔（毫秒）
    let bearProbability = 0;  // 小熊生成概率
    let bossBegan = 0; // BOSS在游戏开始多久后出现
    let maxPlayerCharacter = 5;  // 第一关玩家角色数量最大值
    let bearKillCount = 0;  // 小熊击杀数
    let killsSinceLastLife = 0;  // 自上次获得生命以来的击杀数
    let comboCount = 0;  // 连击数
    let maxComboCount = 0;  // 最大连击数
    let escapedBearCount = 0;  // 逃走小熊数
    let escapedBulletCount = 0;  // 幸存BOSS子弹数
    let escapedItemCount = 0;  // 幸存道具血包数
    let destroyedBulletCount = 0;  // 玩家消灭的BOSS子弹数
    let collectedItemCount = 0;  // 玩家吃掉的道具血包数
    let deathCount = 0;  // 阵亡次数
    let bossSpawned = false;  // BOSS是否已生成
    let gameLoopId;  // 游戏循环ID
    let roadLineY = -100;  // 道路线条Y坐标
    let gameState;  // 游戏状态
    let bossDeathPosition;  // BOSS死亡位置
    let screenFlashAlpha = 0;  // 屏幕闪光透明度
    let playerInvulnerable = false;  // 玩家无敌状态
    let invulnerabilityTimer = 0;  // 无敌时间计时器
    let flashEffects = [];  // 闪光效果数组
    let isShooting = false;  // 是否正在射击
    let shootTimer = 0;  // 射击计时器
    let shootInterval = 80;  // 射击间隔（毫秒）越小子弹发射越密集，火力更强
    // 第二关参数
    let playerHealth = 3; //玩家生命值
    let playerBulletStreams = 1; // 玩家子弹束数量
    let maxPlayerBulletStreams = 10; // 玩家子弹束最大数量
    let itemProbability = 1; //道具出现概率
    let healthProbability = 1; //血包出现概率

    // 游戏资源定义
    const assets = {
      player1: 'player1.png',
      player2: 'player2.png',
      player3: 'player3.png',
      player4: 'player4.png',
      player5: 'player5.png',
      player6: 'player6.png',
      bear1: 'kuma1.png',
      bear2: 'kuma2.png',
      boss1: 'kkr1.png',
      boss2: 'kkr2.png',
      boss3: 'kkr3.png',
      boss4: 'kkr4.png',
      bullet1: 'bullet1.png',
      bullet2: 'bullet2.png',
      bullet3: 'bullet3.png',
      bullet4: 'bullet4.png',
      flash1: 'flash1.png',
      flash2: 'flash2.png',
      fire1: 'fire1.png',
      fire2: 'fire2.png',
      defeat1: 'defeat1.png',
      defeat2: 'defeat2.png',
      defeat3: 'defeat3.png',
      scoreIcon: 'kuma_icon.png',
      comboIcon: 'combo.png',
      win: 'win.png',
      defeat: 'defeat.png',
      chara1: 'chara1.png',
      chara2: 'chara2.png',
      chara3: 'chara3.png',
      blood: 'blood.png',
      fullcombo: 'full_combo.png',
      rank_sss: 'rank_sss.png',
      rank_ssp: 'rank_ssp.png',
      rank_ss: 'rank_ss.png',
      rank_sp: 'rank_sp.png',
      rank_s: 'rank_s.png',
      rank_ap: 'rank_ap.png',
      rank_a: 'rank_a.png',
      rank_bp: 'rank_bp.png',
      rank_b: 'rank_b.png',
      rank_cp: 'rank_cp.png',
      rank_c: 'rank_c.png',
      rank_d: 'rank_d.png',
    };
    // 存储加载后的图像对象
    const assetImages = {};

    function loadAssets(callback, onProgress, onError) {
      let loadedCount = 0;
      const totalCount = Object.keys(assets).length;

      function handleProgress() {
        loadedCount++;
        if (onProgress) onProgress(loadedCount, totalCount);
        if (loadedCount === totalCount) callback();
      }

      Object.entries(assets).forEach(([key, filename]) => {
        const img = new Image();
        img.src = IMG_PATH + filename;
        img.onload = handleProgress;
        img.onerror = () => {
          console.warn(`❌ Failed to load: ${img.src}，重试中...`);
          retryLoad(img, IMG_PATH + filename, 3, handleProgress, onError);
        };
        assetImages[key] = img;
      });
    }

    function retryLoad(img, src, retries, onSuccess, onError) {
      let attempts = 0;

      function tryAgain() {
        if (attempts >= retries) {
          console.error(`🚫 图片加载失败，已放弃: ${src}`);
          if (onError) onError();
          //即使失败，也推进进度
          //onSuccess();
          return;
        }
        attempts++;
        setTimeout(() => {
          img.src = src + '?retry=' + attempts;
        }, 30 * attempts);
      }

      img.onerror = tryAgain;
      img.onload = onSuccess;
      tryAgain();
    }

    function loadData() {
      const loadingText = document.getElementById('loading-text');
      const progressBarFill = document.getElementById('loading-fill');
      const loadingLine = document.getElementById('loading-line');
      const scoreRank = document.getElementById('leaderboard-button');
      let hasError = false;
      loadAssets(
        () => {
          if (!hasError) {
            progressBarFill.style.width = '100%';
            setTimeout(() => {
              loadingLine.style.opacity = '0';
              loadingText.style.opacity = '0';
              setTimeout(() => {
                loadingLine.style.display = 'none';
                loadingText.style.display = 'none';
                scoreRank.style.display = 'block';
              }, 0);
            }, 400);
          }
        },
        (loaded, total) => {
          const percent = Math.round((loaded / total) * 100);
          loadingText.textContent = `Loading... ${percent}%`;
          progressBarFill.style.width = `${percent}%`;
        },
        () => {
          if (!hasError) {
            hasError = true;
            loadingText.textContent += ' - Error';
          }
        }
      );
    }

    // 玩家类
    class Player {
      constructor() {
        this.width = canvasWidth / 7;  // 单个角色宽度
        this.height = this.width * 1.2;  // 角色高度
        this.x = canvasWidth / 2;  // X坐标（中心点）
        this.y = canvasHeight - this.height;  // Y坐标（底部）
        this.characterCount = 1;  // 角色数量（生命数）
        this.animTimer = 0;  // 动画计时器（毫秒）
        this.isDead = false;  // 死亡状态
        this.defeatCharacters = [];  // 处于defeat状态的角色
        this.characters = [1];  // 存储每个角色的类型编号
        this.deadCharacterType = 1;  // 最后一个死亡角色的类型
        this.currentCharacterType = 1;  // 第2关当前角色类型
        this.flashTimer = 0; // 受击闪光计时器（毫秒）
      }
      // 绘制玩家角色
      draw(deltaTime) {
        this.animTimer += deltaTime;
        if (this.flashTimer > 0) this.flashTimer -= deltaTime;
        if (this.isDead) {
          // 如果是死亡状态，按defeat图片的真实宽高比进行绘制
          const currentImage = assetImages[`defeat${this.deadCharacterType}`];
          const aspectRatio = currentImage.naturalWidth / currentImage.naturalHeight;
          const defeatWidth = this.height * 1.2;
          const defeatHeight = defeatWidth / aspectRatio;
          const drawX = this.x - defeatWidth / 2;
          const drawY = this.y + this.height - defeatHeight;
          ctx.drawImage(currentImage, drawX, drawY, defeatWidth, defeatHeight);
        } else if (currentLevel === 2) {
          // 第2关：绘制单个角色
          ctx.fillStyle = 'rgba(0,0,0,0.3)';
          ctx.beginPath();
          ctx.ellipse(this.x, this.y + this.height, this.width * 0.3, this.width * 0.15, 0, 0, Math.PI * 2);
          ctx.fill();
          let characterImage;
          const isFrame2 = Math.floor(this.animTimer / 400) % 2 === 1;
          if (this.currentCharacterType === 2) {
            characterImage = isFrame2 ? assetImages.player4 : assetImages.player3;
          } else if (this.currentCharacterType === 3) {
            characterImage = isFrame2 ? assetImages.player6 : assetImages.player5;
          } else {
            characterImage = isFrame2 ? assetImages.player2 : assetImages.player1;
          }
          if (this.flashTimer > 0) {
            ctx.filter = 'brightness(200%) saturate(0%)';
          }
          ctx.drawImage(characterImage, this.x - this.width / 2, this.y, this.width, this.height);
          ctx.filter = 'none';
        } else {
          // 第1关：绘制多个角色
          const totalWidth = this.width * this.characterCount;
          const startX = this.x - totalWidth / 2;
          for (let i = 0; i < this.characterCount; i++) {
            // 绘制阴影
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(startX + i * this.width + this.width / 2, this.y + this.height, this.width * 0.3, this.width * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();
            // 根据角色类型选择不同形象
            let characterImage;
            const characterType = this.characters[i];
            const isFrame2 = Math.floor(this.animTimer / 400) % 2 === 1;

            if (characterType === 2) {
              characterImage = isFrame2 ? assetImages.player4 : assetImages.player3;
            } else if (characterType === 3) {
              characterImage = isFrame2 ? assetImages.player6 : assetImages.player5;
            } else {
              characterImage = isFrame2 ? assetImages.player2 : assetImages.player1;
            }

            ctx.drawImage(characterImage, startX + i * this.width, this.y, this.width, this.height);
          }

          this.defeatCharacters.forEach(defeatChar => {
            const defeatImage = assetImages[`defeat${defeatChar.characterIndex}`];
            const aspectRatio = defeatImage.naturalWidth / defeatImage.naturalHeight;
            const defeatWidth = this.height * 1.2;
            const defeatHeight = defeatWidth / aspectRatio;
            const drawX = defeatChar.x - defeatWidth / 2;
            const drawY = this.y + this.height - defeatHeight;
            // 绘制阴影
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(defeatChar.x, this.y + this.height, defeatWidth * 0.3, defeatWidth * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.drawImage(defeatImage, drawX, drawY, defeatWidth, defeatHeight);
          });
        }
      }

      // 发射子弹
      shoot() {
        if (currentLevel === 1) {
          const totalWidth = this.width * this.characterCount;
          const startX = this.x - totalWidth / 2;
          for (let i = 0; i < this.characterCount; i++) {
            const bulletX = startX + i * this.width + this.width / 2;
            const bulletType = this.characters[i]; // 根据角色类型选择子弹
            bullets.push(new Bullet(bulletX, this.y, bulletType));
          }
        } else {
          // 第2关：根据子弹束数量发射多束子弹
          const spacing = this.width / (playerBulletStreams + 1) * 1.5; // 调大子弹束间距

          // player2形态且子弹束达到4时产生溅射效果
          if (this.currentCharacterType === 2 && playerBulletStreams >= 4) {
            const halfStreams = Math.floor(playerBulletStreams / 2);
            // 一半直射
            for (let i = 0; i < halfStreams; i++) {
              const bulletX = this.x - this.width / 2 + spacing * (i + 1);
              bullets.push(new Bullet(bulletX, this.y, this.currentCharacterType));
            }
            // 一半左右对称斜射（以直射为对称轴）
            const remainingStreams = playerBulletStreams - halfStreams;
            for (let i = 0; i < remainingStreams; i++) {
              const angle = (i+1) * (Math.PI / 2) / (remainingStreams + 1); // 最大90度斜射
              // - angle代表左斜， + angle 代表右斜
              bullets.push(new Bullet(this.x, this.y, this.currentCharacterType, true,  i % 2 == 0 ? (-Math.PI / 2 - angle) : (-Math.PI / 2 + angle) )); // 左斜
            }
          } else {
            // 普通直射子弹
            for (let i = 0; i < playerBulletStreams; i++) {
              const bulletX = this.x - this.width / 2 + spacing * (i + 1);
              bullets.push(new Bullet(bulletX, this.y, this.currentCharacterType));
            }
          }
        }
      }

      // 根据击杀数更新角色数量
      updateCharacterCount() {
        if (currentLevel === 1) {
          // 第1关：每击杀5个小熊增加1血
          if (killsSinceLastLife >= 5 && this.characterCount < maxPlayerCharacter) {
            player.characterCount++;
            const nextType = Math.floor(Math.random() * 3) + 1;
            this.characters.push(nextType);
            killsSinceLastLife = 0;
          }
        }
        // 第2关不增加角色数量
      }

      // 更新defeat角色状态
      updateDefeatCharacters(deltaTime) {
        this.defeatCharacters = this.defeatCharacters.filter(defeatChar => {
          defeatChar.timer -= deltaTime;
          return defeatChar.timer > 0;
        });
      }
    }

    // 子弹类
    class Bullet {
      constructor(x, y, bulletType = 1, isSplash = false, angle = 0) {
        this.width = canvasWidth / 18; // 子弹宽度
        this.height = this.width * 1.6; // 子弹高度
        this.x = x - this.width / 2; // X坐标（中心对齐）
        this.y = y; // Y坐标
        this.speed = canvasHeight * 1.5; // 每秒移动1.5倍画布高度
        this.image = assetImages[`bullet${bulletType}`]; // 根据类型选择子弹图像
        this.markedForDeletion = false; // 【新增】用于标记待删除的对象，替代splice
        this.bulletType = bulletType; // 子弹类型
        this.isSplash = isSplash; // 是否为溅射子弹
        this.angle = angle; // 溅射子弹的角度
        // 根据子弹类型设置伤害值（第2关）
        if (currentLevel === 2) {
          if (bulletType === 1) {
            this.damage = 5; // player1形态伤害值为5
            this.bearDamage = 5;
          } else if (bulletType === 2) {
            this.damage = 3; // player2形态普通伤害4 小熊伤害8
            this.bearDamage = 10;
          } else if (bulletType === 3) {
            this.damage = 2; // player3形态伤害值为3
            this.bearDamage = 2;
          }
        } else {
          this.damage = 1; // 第1关保持原有伤害
          this.bearDamage = 1; // 第1关保持原有伤害
        }
      }

      // 更新子弹位置（向上移动）
      update(deltaTime) {
        if (this.isSplash) {
          // 溅射子弹按角度移动
          this.x += Math.cos(this.angle) * this.speed * (deltaTime / 1000);
          this.y += Math.sin(this.angle) * this.speed * (deltaTime / 1000);
        } else {
          // 移动距离 = 速度 * 时间（秒）
          this.y -= this.speed * (deltaTime / 1000);
        }
        // 如果子弹出界，标记它为待删除
        if (this.y < -this.height || this.x < -this.width || this.x > canvasWidth) this.markedForDeletion = true;
      }

      // 绘制子弹
      draw() {
        ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
      }
    }

    // 粉色小熊类
    class Bear {
      constructor(x, y) {
        this.width = canvasWidth / 6; // 小熊宽度
        this.height = this.width; // 小熊高度
        this.x = x; // X坐标
        this.y = y; // Y坐标
        this.baseSpeed = canvasHeight * 0.3; // 基础移动速度
        this.speed = this.baseSpeed; // 当前移动速度
        this.health = currentLevel === 2 ? 15 : 5; // 第2关小熊血量为15，第1关为5
        this.animTimer = 0; // 动画计时器（毫秒）
        this.flashTimer = 0; // 受击闪光计时器（毫秒）
        this.markedForDeletion = false; // 用于标记待删除的对象
        this.slowEffect = false; // 是否被减速
        this.slowTimer = 0; // 减速效果计时器
      }
      // 应用减速效果
      applySlow() {
        if (!this.slowEffect) {
          this.slowEffect = true;
          this.speed = this.baseSpeed * 0.25; // 降低75%移动速度
          this.slowTimer = 3000; // 减速效果持续3秒
        }
      }
      // 更新小熊位置（向下移动）
      update(deltaTime) {
        // 更新减速效果
        if (this.slowEffect) {
          this.slowTimer -= deltaTime;
          if (this.slowTimer <= 0) {
            this.slowEffect = false;
            this.speed = this.baseSpeed; // 恢复原速度
          }
        }
        // 移动距离 = 速度 * 时间（秒）
        this.y += this.speed * (deltaTime / 1000);
        this.animTimer += deltaTime;
        if (this.flashTimer > 0) this.flashTimer -= deltaTime;
        // 如果小熊出界，标记它为待删除并重置combo
        if (this.y > canvasHeight) {
          this.markedForDeletion = true;
          comboCount = 0; // 小熊逃走时重置combo
          escapedBearCount++; // 增加逃走小熊数
        }
      }
      // 绘制小熊
      draw() {
        // 绘制阴影
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(this.x + this.width / 2, this.y + this.height, this.width * 0.3, this.width * 0.15, 0, 0, Math.PI * 2);
        ctx.fill();

        if (this.flashTimer > 0) {
          ctx.filter = 'brightness(200%) saturate(0%)';
        }
        const currentImage = Math.floor(this.animTimer / 400) % 2 === 0 ? assetImages.bear1 : assetImages.bear2;
        ctx.drawImage(currentImage, this.x, this.y, this.width, this.height);
        ctx.filter = 'none';
      }
    }

    // 道具类
    class PowerUp {
      constructor(x, y, type) {
        this.width = canvasWidth / 8;
        this.height = this.width;
        this.x = x;
        this.y = y;
        this.speed = canvasHeight * 0.2; // 每秒移动0.2倍画布高度
        this.type = type;
        this.markedForDeletion = false;
      }

      update(deltaTime) {
        this.y += this.speed * (deltaTime / 1000);
        if (this.y > canvasHeight) {
          this.markedForDeletion = true;
          escapedItemCount++; // 道具到达边缘时计为幸存
        }
      }

      draw() {
        const image = assetImages[`chara${this.type}`];
        ctx.drawImage(image, this.x, this.y, this.width, this.height);
      }
    }

    // 血包类
    class HealthPack {
      constructor(x, y) {
        this.width = canvasWidth / 12;
        this.height = canvasWidth / 8;
        this.x = x;
        this.y = y;
        this.speed = canvasHeight * 0.2;
        this.markedForDeletion = false;
      }

      update(deltaTime) {
        this.y += this.speed * (deltaTime / 1000);
        if (this.y > canvasHeight) {
          this.markedForDeletion = true;
          escapedItemCount++; // 血包到达边缘时计为幸存
        }
      }

      draw() {
        ctx.drawImage(assetImages.blood, this.x, this.y, this.width, this.height);
      }
    }

    // BOSS子弹类
    class BossBullet {
      constructor(x, y, targetX, targetY) {
        this.width = canvasWidth / 20;
        this.height = this.width;
        this.x = x;
        this.y = y;
        this.speedx = canvasHeight * 0.28; // BOSS子弹速度
        this.speedy = canvasHeight * 0.26; // BOSS子弹速度
        const angle = Math.atan2(targetY - y, targetX - x);
        this.vx = Math.cos(angle) * this.speedx;
        this.vy = Math.sin(angle) * this.speedy;
        this.markedForDeletion = false;
      }

      update(deltaTime) {
        this.x += this.vx * (deltaTime / 1000);
        this.y += this.vy * (deltaTime / 1000);
        if (this.x < 0 || this.x > canvasWidth || this.y < 0 || this.y > canvasHeight) {
          this.markedForDeletion = true;
          escapedBulletCount++; // BOSS子弹到达边缘时计为幸存
        }
      }

      draw() {
        ctx.drawImage(assetImages.bullet4, this.x, this.y, this.width, this.height);
      }
    }

    // BOSS类
    class Boss {
      constructor() {
        this.width = canvasWidth / 3; // BOSS宽度
        this.height = this.width * 1.1; // BOSS高度
        this.x = canvasWidth / 2 - this.width / 2; // X坐标（居中）
        this.y = -this.height; // Y坐标（从屏幕上方开始）
        this.targetY = canvasHeight * 0.1; // 第一阶段目标Y坐标
        this.baseSpeed = canvasHeight * 0.15; // 基础移动速度
        this.speedx = this.baseSpeed; // X轴方向的移动速度
        this.speedy = this.baseSpeed; // Y轴方向的移动速度
        this.directionX = 1; // X轴移动方向
        this.phase = 1; // 从阶段1开始
        this.gravity = canvasHeight * 0.1; // 【新增】重力加速度（像素/秒^2）
        this.bounceTargetY = canvasHeight * 0.3; // 弹跳目标Y坐标
        this.roamTimer = 0; // 游走计时器
        this.roamDuration = 0; // 当前游走持续时间
        this.animTimer = 0; // 动画计时器（毫秒）
        this.attackState = 'normal'; // 攻击状态：normal, raising, punching
        this.attackTimer = 0; // 攻击计时器
        this.shootTimer = 0;
        this.flashTimer = 0;
        this.bulletTimer = 0; // 子弹发射计时器
        this.isShooting = false; // 是否正在发射子弹
        this.bulletRows = 0; // 子弹束的数量
        this.shootedNumber = 0; //这一束已发射出去的子弹数
        this.bulletsNumber = 0; //这一束的子弹总数
        this.slowEffect = false; // 是否被减速
        this.slowTimer = 0; // 减速效果计时器
        this.downFactor = 0; // 下降速度因子（难度越大下降速度越快）
        this.bounceFactor = 0; // 反弹高度因子（难度越大反弹高度越低）
        this.bulletFactor = 0; // BOSS子弹数因子
        this.bloodFactor = 0; // BOSS血量因子
        // 根据难度设置参数
        let bossHealth = 0;
        if (currentDifficulty === 'easy') {
          if (currentLevel === 2) {
            bossHealth = 4500;
          }else{
            bossHealth = 800;
          }
          this.downFactor = 0.7;
          this.bounceFactor = 0.55;
          this.bulletFactor = 3;
          this.bloodFactor = 0.3;
          this.bulletRows = 1;
        } else if (currentDifficulty === 'normal' || currentDifficulty === 'endless') {
          if (currentLevel === 2) {
            bossHealth = 9000;
          }else{
            bossHealth = 1400;
          }
          this.downFactor = 1;
          this.bounceFactor = 0.65;
          this.bulletFactor = 5;
          this.bloodFactor = 0.5;
          this.bulletRows = 1;
        } else if (currentDifficulty === 'hard') {
          if (currentLevel === 2) {
            bossHealth = 13500;
          }else{
            bossHealth = 2800;
          }
          this.downFactor = 1.3;
          this.bounceFactor = 0.8;
          this.bulletFactor = 7;
          this.bloodFactor = 0.7;
          this.bulletRows = 1;
        }
        this.health = bossHealth; // 当前血量
        this.maxHealth = bossHealth; // BOSS初始血量
      }
      // 应用减速效果
      applySlow() {
        if (!this.slowEffect) {
          this.slowEffect = true;
          this.speedx = this.baseSpeed * 0.06;
          this.speedy = this.baseSpeed * 0.06;
          this.slowTimer = 3000; // 减速效果持续3秒
        }
      }
      // 更新BOSS状态和位置
      update(deltaTime, gameTime) {
        // 更新减速效果
        if (this.slowEffect) {
          this.slowTimer -= deltaTime;
          if (this.slowTimer <= 0) {
            this.slowEffect = false;
            this.speedx = this.baseSpeed; // 恢复原速度
            this.speedy = this.baseSpeed; // 恢复原速度
          }
        }
        const deltaSeconds = deltaTime / 1000;
        this.animTimer += deltaTime;
        if (this.flashTimer > 0) this.flashTimer -= deltaTime;
        if (currentDifficulty === 'normal' || currentDifficulty === 'endless') {
          if(this.health <= this.maxHealth * 0.2) {
            this.bulletRows = 2;
          }
        } else if (currentDifficulty === 'hard') {
          if(this.health <= this.maxHealth * 0.15) {
            this.bulletRows = 3;
          }else if(this.health <= this.maxHealth * 0.35) {
            this.bulletRows = 2;
          }
        }
        const distanceToPlayer = player.y - (this.y + this.height);
        // BOSS接近玩家到距离小于玩家的身高时，变成举起拳头状态持续0.3秒
        if (distanceToPlayer >= 0 && distanceToPlayer <= player.height * 0.8 &&
          this.attackState === 'normal' && this.speedy >= 0) {
          this.attackState = 'raising';
          this.attackTimer = 300;
        }
        // 处理攻击状态
        if (this.attackState === 'raising') {
          this.attackTimer -= deltaTime;
          //砸拳头
          if (this.attackTimer <= 0) {
            this.attackState = 'punching';
            this.attackTimer = 300;// 砸拳头持续时间
          }
        } else if (this.attackState === 'punching') {
          this.attackTimer -= deltaTime;
          if (this.attackTimer <= 0) {
            this.attackState = 'normal';
          }
        }
        if (currentLevel === 2) {
          // 第2关BOSS达到一定血量以下,或无限模式下游戏时间超过15秒  进入阶段2
          if ((this.health <= this.maxHealth * this.bloodFactor || (currentDifficulty === 'endless' && gameTime > 20000))
            && this.phase === 1) {
            this.phase = 2;
          }
          if (this.phase === 1) {
            // 阶段1：左右游走
            if (this.y < this.targetY) this.y += this.speedy * deltaSeconds;
            else {
              this.x += this.speedx * this.directionX * deltaSeconds;
              if (this.x <= 0) {
                this.x = 0;
                this.directionX = 1;
              }
              if (this.x + this.width >= canvasWidth) {
                this.x = canvasWidth - this.width;
                this.directionX = -1;
              }
            }
          } else {
            // 阶段2：下降+游走
            // 检查是否在游走状态
            const isRoaming = this.roamTimer > 0 && this.roamTimer < this.roamDuration;

            if (!isRoaming) {
              // 下降（不锁定玩家）
              this.speedy += this.gravity * deltaSeconds * this.downFactor;
              this.y += this.speedy * deltaSeconds;
              // 触底反弹
              if (this.y + this.height >= canvasHeight) {
                this.y = canvasHeight - this.height;
                // 反弹到随机高度
                this.speedy = -(Math.random() * canvasHeight * 0.8 + canvasHeight * 0.2);
                this.bounceTargetY = Math.random() * canvasHeight * this.bounceFactor - canvasHeight * 0.35;
                if (this.bounceTargetY < 0) {
                  this.bounceTargetY = 0;
                }
                // 设置随机游走时间（4-6秒）
                this.roamDuration = Math.random() * 2000 + 4000;
                this.roamTimer = 0;
              }
              // 到达反弹高度后开始游走
              if (this.speedy < 0 && this.y <= this.bounceTargetY) {
                this.speedy = 0;
                this.roamTimer = 1; // 开始游走计时
              }
            } else {
              // 游走状态：只左右移动，不受重力影响
              this.roamTimer += deltaTime;
              this.x += this.speedx * this.directionX * deltaSeconds;
              if (this.x <= 0) {
                this.x = 0;
                this.directionX = 1;
              }
              if (this.x + this.width >= canvasWidth) {
                this.x = canvasWidth - this.width;
                this.directionX = -1;
              }

              // 游走时间结束，重置计时器准备下次下降
              if (this.roamTimer >= this.roamDuration) {
                this.roamTimer = 0;
                this.roamDuration = 0;
              }
            }
          }
          // 发射模式控制：BOSS每隔一段时间（4秒）发射一次子弹
          // 容易：每次发射 3~6 发（普通：5-8发，困难：7-10发）子弹，
          // 每颗子弹间隔 200ms
          this.shootTimer += deltaTime;
          if (!this.isShooting && this.shootTimer > 4000) {
            // 开始新的发射周期
            this.isShooting = true;
            this.bulletTimer = 0;
            this.shootTimer = 0;
            this.shootedNumber = 0; //这一轮已发射出去的子弹数
            this.bulletsNumber = Math.floor(Math.random() * 3) + this.bulletFactor; //子弹总数
          }
          if (this.isShooting) {
            this.bulletTimer += deltaTime;
            // 每200ms发射一个子弹
            if (this.bulletTimer >= 200) {
              // 发射多排并列子弹
              const spacing = this.width / (this.bulletRows + 1);
              for (let i = 0; i < this.bulletRows; i++) {
                const bulletX = this.x + spacing * (i + 1);
                bossBullets.push(new BossBullet(
                  bulletX,
                  this.y + this.height / 2,
                  player.x,
                  player.y
                ));
              }

              this.bulletTimer = 0;
              this.shootedNumber++;
               if (this.shootedNumber >= this.bulletsNumber) {
                // 发射完毕
                this.isShooting = false;
              }
            }
          }
        } else {
          // 第1关BOSS血量75%以下或游戏时间超过15秒 进入第二阶段
          if ((this.health <= this.maxHealth * 0.75 || gameTime > 15000) && this.phase === 1) {
            this.phase = 2;
          }
          if (this.phase === 1) {
            if (this.y < this.targetY) this.y += this.speedy * deltaSeconds;
            else {
              this.x += this.speedx * this.directionX * deltaSeconds;
              if (this.x <= 0) {
                this.x = 0;
                this.directionX = 1;
              }
              if (this.x + this.width >= canvasWidth) {
                this.x = canvasWidth - this.width;
                this.directionX = -1;
              }
            }
          } else {
            const targetX = player.x - this.width / 2;
            if (Math.abs(this.x - targetX) > 2) {
              this.x += (targetX - this.x) * 0.02;
            }
            // 难度越大，BOSS下降速度越快
            this.speedy += this.gravity * deltaSeconds * this.downFactor;
            this.y += this.speedy * deltaSeconds;
            // BOSS触底后反弹
            if (this.y + this.height >= canvasHeight) {
              this.y = canvasHeight - this.height;
              // 弹跳速度与屏幕高度关联
              this.speedy = -(Math.random() * canvasHeight * 0.8 + canvasHeight * 0.2);
              // bounceTargetY越小，代表BOSS反弹后的高度越接近画面顶部，
              this.bounceTargetY = Math.random() * canvasHeight * this.bounceFactor - canvasHeight * 0.35;
              if (this.bounceTargetY < 0) {
                this.bounceTargetY = 0;
              }
            }
            if (this.speedy < 0 && this.y <= this.bounceTargetY) {
              this.speedy = 0;
            }
          }
        }
      }

      // 绘制BOSS和血量条
      draw() {
        // 绘制阴影
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(this.x + this.width / 2, this.y + this.height, this.width * 0.4, this.width * 0.2, 0, 0, Math.PI * 2);
        ctx.fill();
        // BOSS受击时的闪光效果（暂时去掉）
        if (this.flashTimer > 0 && this.health > 0) {
          //ctx.filter = 'brightness(200%) saturate(0%)';
        }
        // 根据攻击状态选择图片
        let currentImage;
        if (this.attackState === 'raising') {
          currentImage = assetImages.boss3; // 举起拳头
        } else if (this.attackState === 'punching') {
          currentImage = assetImages.boss4; // 砸下拳头
        } else {
          // 正常状态下的动画切换
          currentImage = Math.floor(this.animTimer / 400) % 2 === 0 ? assetImages.boss1 : assetImages.boss2;
        }

        ctx.drawImage(currentImage, this.x, this.y, this.width, this.height);
        ctx.filter = 'none';

        // 绘制BOSS血量条（无尽模式下不显示）
        if (currentDifficulty === 'endless') {
          return;
        }
        const barWidth = canvasWidth * 0.6, barHeight = 20, barX = canvasWidth / 2 - barWidth / 2, barY = 10;
        ctx.fillStyle = '#555';
        ctx.fillRect(barX, barY, barWidth, barHeight);  // 背景条

        const hpPercent = this.health / this.maxHealth;
        // 根据血量百分比设置颜色
        ctx.fillStyle = hpPercent > 0.5 ? 'green' : (hpPercent > 0.2 ? 'orange' : 'red');
        ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);  // 血量条

        ctx.strokeStyle = 'white';
        ctx.strokeRect(barX, barY, barWidth, barHeight);  // 边框

        // 在血条中间显示血量数字
        ctx.font = 'bold 16px "Arial", sans-serif';
        ctx.fillStyle = '#ffffff';
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.textAlign = 'center';
        //ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
        // ctx.shadowOffsetX = 1;
        // ctx.shadowOffsetY = 1;
        // ctx.shadowBlur = 4;

        const healthText = `${this.health} / ${this.maxHealth}`;
        ctx.strokeText(healthText, canvasWidth / 2, barY + 15);
        ctx.fillText(healthText, canvasWidth / 2, barY + 15);
        // 清除阴影效果
        //ctx.shadowColor = 'transparent';
        // ctx.shadowOffsetX = 0;
        // ctx.shadowOffsetY = 0;
        // ctx.shadowBlur = 0;
      }
    }

    // 爆炸效果类
    class Explosion {
      constructor(x, y) {
        this.x = x;  // 爆炸中心X坐标
        this.y = y;  // 爆炸中心Y坐标
        this.particles = [];  // 粒子数组
        this.init();
      }

      // 初始化爆炸粒子
      init() {
        const particleCount = 8;  // 粒子数量
        for (let i = 0; i < particleCount; i++) {
          const angle = Math.random() * Math.PI * 2;  // 随机角度
          const speed = Math.random() * 3 + 1;  // 随机速度
          this.particles.push({
            x: this.x, y: this.y,  // 初始位置
            vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,  // 速度分量
            size: Math.random() * 8 + 4,  // 粒子大小
            life: Math.random() * 20 + 20,  // 生命周期
            opacity: 1,  // 透明度
            color: '#ff69b4'  // 粒子颜色
          });
        }
      }

      // 更新粒子状态
      update(deltaTime) {
        this.particles.forEach((p, index) => {
          p.x += p.vx * (deltaTime / 16.67);  // 基于时间的位置更新
          p.y += p.vy * (deltaTime / 16.67);  // 基于时间的位置更新
          p.life -= deltaTime / 16.67;  // 基于时间的生命值减少
          p.opacity = p.life / 30;  // 更新透明度
          if (p.life <= 0) this.particles.splice(index, 1);  // 移除死亡粒子
        });
      }

      // 绘制爆炸效果
      draw() {
        this.particles.forEach(p => {
          ctx.save();
          ctx.globalAlpha = p.opacity;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
      }

      // 检查爆炸是否结束
      isFinished() {
        return this.particles.length === 0;
      }
    }

    // 闪光效果类
    class FlashEffect {
      constructor(x, y, isPlayer) {
        this.x = x;
        this.y = y;
        this.life = 15;
        this.maxLife = 15;
        this.images = [];
        this.angles = [];
        this.isPlayer = isPlayer;

        // 玩家碰撞只随机显示1张闪光图
        if(isPlayer){
          this.images.push(Math.random() < 0.5 ? assetImages.fire1 : assetImages.fire2);
        }else{
          // BOSS、小熊碰撞随机显示1-2张闪光图片
          const count = Math.random() < 0.5 ? 1 : 2;
          for (let i = 0; i < count; i++) {
            this.images.push(Math.random() < 0.5 ? assetImages.flash1 : assetImages.flash2);
            this.angles.push(Math.random() * Math.PI * 2);
          }
        }
      }

      update(deltaTime) {
        this.life -= deltaTime / 16.67;  // 基于时间的生命值减少
      }

      draw() {
        const alpha = this.life / this.maxLife;
        ctx.save();
        ctx.globalAlpha = alpha;

        for (let i = 0; i < this.images.length; i++) {
          ctx.save();
          if(!this.isPlayer){
            const offsetX = i * 20 - 10;
            const offsetY = i * 15 - 7;
            ctx.translate(this.x + offsetX, this.y + offsetY);
            ctx.rotate(this.angles[i]);
            ctx.drawImage(this.images[i], -25, -25, 50, 50);
          }else{
            ctx.translate(this.x, this.y);
            ctx.drawImage(this.images[i], -5, -25, 50, 50);
          }
          ctx.restore();
        }
        ctx.restore();
      }

      isFinished() {
        return this.life <= 0;
      }
    }



    // 初始化游戏
    function init() {
      currentLevel = parseInt(document.getElementById('level-selector').value);
      resizeCanvas();  // 调整画布尺寸
      player = new Player();  // 创建玩家
      bullets = [];  // 清空子弹数组
      bears = [];  // 清空小熊数组
      powerUps = [];  // 清空道具数组
      healthPacks = [];  // 清空血包数组
      bossBullets = [];  // 清空BOSS子弹数组
      explosions = [];  // 清空爆炸数组
      flashEffects = [];  // 清空闪光效果数组
      boss = null;  // 重置BOSS
      bearKillCount = 0;  // 重置小熊击杀数
      killsSinceLastLife = 0;  // 重置回血计数器
      comboCount = 0;  // 重置连击数
      maxComboCount = 0;  // 重置最大连击数
      escapedBearCount = 0;  // 重置逃走小熊数
      escapedBulletCount = 0;  // 重置幸存BOSS子弹数
      escapedItemCount = 0;  // 重置幸存道具血包数
      destroyedBulletCount = 0;  // 重置玩家消灭的BOSS子弹数
      collectedItemCount = 0;  // 重置玩家吃掉的道具血包数
      deathCount = 0;  // 重置阵亡次数
      bearSpawnTimer = 0;  // 重置小熊生成计时器
      bossSpawned = false;  // 重置BOSS生成标志
      playerInvulnerable = false;  // 重置无敌状态
      invulnerabilityTimer = 0;  // 重置无敌计时器
      gameState = 'playing';  // 设置游戏状态为游戏中
      gameStartTime = performance.now();  // 记录游戏开始时间

      // 清空结算界面的所有字段内容
      document.getElementById('result-diff').textContent = '';
      document.getElementById('result-time').textContent = '';
      document.getElementById('result-kill').textContent = '';
      document.getElementById('result-combo-text').textContent = '';
      document.getElementById('result-total-text').textContent = '';
      // 隐藏图标
      let fullcombo = document.getElementById('result-fullcombo');
      fullcombo.style.display = 'none';
      fullcombo.src = IMG_PATH + assets.fullcombo;
      document.getElementById('result-rank').style.display = 'none';


      if (currentLevel === 2) {
        playerHealth = 3;
        playerBulletStreams = 1; // 重置子弹束数量
      }
      if (currentDifficulty === 'easy') {
        // 小熊每800毫秒出现一次
        bearInterval = 800;
        // 小熊每列生成概率，中等难度64%概率生成，也就是每行6*0.6=3.6个熊
        bearProbability = 0.5;
        maxPlayerBulletStreams = 10;
        itemProbability = 0.3;
        healthProbability = 0.3;
        // 游戏开始多少秒后生成BOSS
        bossBegan = 1000;
      } else if (currentDifficulty === 'normal' || currentDifficulty === 'endless') {
        bearInterval = 750;
        bearProbability = 0.6;
        maxPlayerBulletStreams = 14;
        itemProbability = 0.24;
        healthProbability = 0.22;
        bossBegan = 2000;
      } else if (currentDifficulty === 'hard') {
        bearInterval = 700;
        bearProbability = 0.65;
        maxPlayerBulletStreams = 18;
        itemProbability = 0.18;
        healthProbability = 0.18;
        bossBegan = 3000;
      }

      if (player) {
        player.defeatCharacters = []; // 清空defeat角色
        player.characters = [1]; // 重置角色类型数组
        player.deadCharacterType = 1; // 重置死亡角色类型
        if (currentLevel === 2) {
          player.currentCharacterType = 1;
        }
      }
    }

    // 生成小熊
    function spawnBears() {
      const numColumns = 6; // 列数
      const bearWidth = canvasWidth / 6;  // 每列宽度
      for (let i = 0; i < numColumns; i++) {
        if (Math.random() < bearProbability) {
          const x = i * bearWidth;  // 计算X坐标
          const y = -bearWidth;  // 从屏幕上方开始
          let canSpawn = true;
          // 检查是否与BOSS重叠
          if (boss && boss.y > -boss.height) {
            const bossLeft = boss.x;
            const bossRight = boss.x + boss.width;
            const bearLeft = x;
            const bearRight = x + bearWidth;
            if (!(bearRight <= bossLeft || bearLeft >= bossRight)) {
              canSpawn = false;  // 与BOSS重叠，不生成
            }
          }

          if (canSpawn) {
            bears.push(new Bear(x, y));
          }
        }
      }
    }

    // 生成道具和血包（仅第2关）
    function spawnPowerUps() {
      if (currentLevel !== 2) return;

      const minDistance = canvasWidth / 10; // 最小间距
      const newItems = [];

      // 道具生成概率
      if (Math.random() < itemProbability) {
        const type = Math.floor(Math.random() * 3) + 1;
        const x = findValidPosition(canvasWidth / 8, newItems, minDistance);
        if (x !== -1) {
          powerUps.push(new PowerUp(x, -canvasWidth / 12, type));
          newItems.push({x, width: canvasWidth / 8});
        }
      }

      // 血包生成概率
      if (Math.random() < healthProbability) {
        const x = findValidPosition(canvasWidth / 12, newItems, minDistance);
        if (x !== -1) {
          healthPacks.push(new HealthPack(x, -canvasWidth / 12));
          newItems.push({x, width: canvasWidth / 12});
        }
      }
    }

    // 查找不重叠的有效位置
    function findValidPosition(itemWidth, existingItems, minDistance) {
      const maxAttempts = 10;
      for (let i = 0; i < maxAttempts; i++) {
        const x = Math.random() * (canvasWidth - itemWidth);
        let valid = true;

        for (const item of existingItems) {
          const distance = Math.abs(x + itemWidth/2 - (item.x + item.width/2));
          if (distance < minDistance) {
            valid = false;
            break;
          }
        }

        if (valid) return x;
      }
      return -1; // 找不到有效位置
    }

    // 处理所有碰撞检测
    function handleCollisions() {
      // 子弹与小熊的碰撞
      bullets.forEach(bullet => {
        if (bullet.markedForDeletion) return; // 跳过已标记的子弹
        bears.forEach(bear => {
          if (bear.markedForDeletion) return; // 跳过已标记的小熊
          if (isColliding(bullet, bear)) {
            flashEffects.push(new FlashEffect(bullet.x + bullet.width / 2, bullet.y + bullet.height / 2, false));
            bullet.markedForDeletion = true; // 标记子弹待删除
            bear.health -= (bullet.bearDamage > bear.health ? bear.health : bullet.bearDamage); // 使用子弹的伤害值
            bear.flashTimer = 50; //小熊闪白50毫秒

            // player3形态子弹击中敌人时应用减速效果
            if (currentLevel === 2 && bullet.bulletType === 3) {
              bear.applySlow();
            }
            if (bear.health <= 0) {
              bear.markedForDeletion = true; // 标记小熊待删除
              bearKillCount++;
              killsSinceLastLife++;
              comboCount++;
              if (comboCount > maxComboCount) maxComboCount = comboCount;
              player.updateCharacterCount();
            }
          }
        });
      });

      // 子弹与BOSS的碰撞
      if (boss) {
        bullets.forEach(bullet => {
          if (bullet.markedForDeletion) return; // 跳过已标记的子弹
          if (isColliding(bullet, boss)) {
            flashEffects.push(new FlashEffect(bullet.x + bullet.width / 2, bullet.y + bullet.height / 2, false));
            bullet.markedForDeletion = true; // 标记子弹待删除
            // player3形态子弹击中敌人时应用减速效果
            if (currentLevel === 2 && bullet.bulletType === 3) {
              boss.applySlow();
            }
            //无尽模式下BOSS不掉血 不能掉成负数
            if (currentDifficulty !== 'endless') {
              boss.health -= (bullet.damage > boss.health ? boss.health : bullet.damage); // 使用子弹的伤害值
            }
            boss.flashTimer = 50; //BOSS闪白50毫秒
            if (boss.health <= 0 && gameState === 'playing') {
              gameState = 'bossDying';
              bossDeathPosition = {x: boss.x, y: boss.y, width: boss.width, height: boss.height};
              screenFlashAlpha = 0.7;
              triggerScreenShake(15);
              setTimeout(() => gameOver(true), 400); // BOSS死亡400毫秒后游戏结束
            }
          }
        });
      }

      // 第2关：player3子弹与BOSS子弹的碰撞（抵消效果）
      if (currentLevel === 2) {
        bullets.forEach(playerBullet => {
          if (playerBullet.markedForDeletion || playerBullet.bulletType !== 3) return;
          bossBullets.forEach(bossBullet => {
            if (bossBullet.markedForDeletion) return;
            if (isColliding(playerBullet, bossBullet)) {
              // 两者一起消失并触发闪光特效
              playerBullet.markedForDeletion = true;
              bossBullet.markedForDeletion = true;
              destroyedBulletCount++; // 玩家消灭BOSS子弹
              flashEffects.push(new FlashEffect(
                (playerBullet.x + bossBullet.x) / 2 + playerBullet.width / 2,
                (playerBullet.y + bossBullet.y) / 2 + playerBullet.height / 2, false
              ));
            }
          });
        });
      }

      // 小熊与玩家的碰撞
      bears.forEach(bear => {
        if (bear.markedForDeletion) return;
        const totalWidth = player.width * player.characterCount;
        const startX = player.x - totalWidth / 2;

        for (let i = 0; i < player.characterCount; i++) {
          const charHitbox = {
            x: startX + i * player.width,
            y: player.y,
            width: player.width,
            height: player.height
          };

          if (isColliding(bear, charHitbox)) {
            bear.markedForDeletion = true;
            // 撞到玩家的小熊视为幸存 combo中断
            escapedBearCount++;
            comboCount = 0;
            playerBulletStreams = Math.ceil(playerBulletStreams / 2);
            triggerScreenShake(5);
            flashEffects.push(new FlashEffect(charHitbox.x, charHitbox.y, true));
            player.flashTimer = 200; //玩家闪白200毫秒
            checkDead(i);
            return;
          }
        }
      });

      // BOSS与玩家的碰撞（在无敌时间外）
      if (boss && !playerInvulnerable) {
        if (currentLevel === 2) {
          // 第2关：单个角色碰撞检测
          const playerHitbox = {
            x: player.x - player.width / 2,
            y: player.y,
            width: player.width,
            height: player.height
          };

          if (isColliding(boss, playerHitbox)) {
            playerInvulnerable = true;
            // 玩家无敌时间0.8秒，避免重复受到伤害
            invulnerabilityTimer = 800;
            playerBulletStreams = Math.ceil(playerBulletStreams / 2);
            player.flashTimer = 200; //玩家闪白200毫秒
            triggerScreenShake(8);
            flashEffects.push(new FlashEffect(playerHitbox.x, playerHitbox.y, true));
            checkDead(0);
          }
        } else {
          // 第1关：原有逻辑
          const totalWidth = player.width * player.characterCount;
          const startX = player.x - totalWidth / 2;

          for (let i = 0; i < player.characterCount; i++) {
            const charHitbox = {
              x: startX + i * player.width,
              y: player.y,
              width: player.width,
              height: player.height
            };

            if (isColliding(boss, charHitbox)) {
              playerInvulnerable = true;
              invulnerabilityTimer = 1800;
              player.flashTimer = 100; //玩家闪白100毫秒
              triggerScreenShake(8);
              flashEffects.push(new FlashEffect(charHitbox.x, charHitbox.y, true));
              checkDead(i);
              return;
            }
          }
        }
      }

      // 第2关的道具碰撞检测
      if (currentLevel === 2) {
        const playerHitbox = {
          x: player.x - player.width / 2,
          y: player.y,
          width: player.width,
          height: player.height
        };

        // BOSS的子弹与玩家碰撞
        bossBullets.forEach(bullet => {
          if (bullet.markedForDeletion) return;
          if (isColliding(bullet, playerHitbox) && !playerInvulnerable) {
            bullet.markedForDeletion = true;
            escapedBulletCount++;
            playerInvulnerable = true;
            invulnerabilityTimer = 500;
            playerBulletStreams = Math.ceil(playerBulletStreams / 2);
            player.flashTimer = 100; //玩家闪白100毫秒
            triggerScreenShake(5);
            flashEffects.push(new FlashEffect(playerHitbox.x, playerHitbox.y, true));
            checkDead(0);
          }
        });

        // 道具碰撞
        powerUps.forEach(powerUp => {
          if (powerUp.markedForDeletion) return;
          if (isColliding(powerUp, playerHitbox)) {
            powerUp.markedForDeletion = true;
            collectedItemCount++; // 玩家吃掉道具
             if (playerBulletStreams < maxPlayerBulletStreams ) {
               // 困难模式下，碰到的头像必须和自身形象相同，才增加子弹束数量
               if(currentDifficulty !== 'hard' || player.currentCharacterType !== powerUp.type){
                 playerBulletStreams++;
               }
            }
            player.currentCharacterType = powerUp.type;

          }
        });

        // 血包碰撞
        healthPacks.forEach(healthPack => {
          if (healthPack.markedForDeletion) return;
          if (isColliding(healthPack, playerHitbox)) {
            healthPack.markedForDeletion = true;
            collectedItemCount++; // 玩家吃掉血包
            playerHealth++;
          }
        });

      }
    }

    function checkDead(hitCharacterIndex) {
      if (currentLevel === 2) {
        // 第2关：减少血量
        if(playerHealth > 0) {
          playerHealth--;
          deathCount++;
        }
        if (playerHealth <= 0) {
          player.deadCharacterType = player.currentCharacterType;
          player.isDead = true;
          setTimeout(() => gameOver(false), 400);
        }
      } else {
        deathCount++;
        // 第1关：原有逻辑
        if (player.characterCount > 1) {
          // 计算被击中角色的位置
          const totalWidth = player.width * player.characterCount;
          const startX = player.x - totalWidth / 2;
          const hitCharacterX = startX + hitCharacterIndex * player.width + player.width / 2;
          const hitCharacterType = player.characters[hitCharacterIndex];

          player.defeatCharacters.push({
            x: hitCharacterX,
            characterIndex: hitCharacterType,
            timer: 1200 // 角色被击败1200毫秒后消失
          });
          // 从角色数组中移除被击中的角色
          player.characters.splice(hitCharacterIndex, 1);
          player.characterCount--;
          killsSinceLastLife = 0;
        } else {
          player.deadCharacterType = player.characters[hitCharacterIndex];
          player.isDead = true;
          setTimeout(() => gameOver(false), 400);// 玩家死亡400毫秒后游戏结束
        }
      }
    }

    // 碰撞检测函数（矩形碰撞）
    function isColliding(rect1, rect2) {
      return rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.y + rect1.height > rect2.y;
    }

    // 绘制道路中间线
    function drawRoad(deltaTime) {
      ctx.fillStyle = '#fff';
      const lineWidth = 15, lineHeight = 80, lineGap = 60;
      // 道路滚动速度与屏幕高度关联
      const roadSpeed = canvasHeight * 0.6;
      if (gameState === 'playing') {
        roadLineY += roadSpeed * (deltaTime / 1000);
      }
      if (roadLineY > lineHeight + lineGap) roadLineY = 0;

      for (let y = roadLineY - (lineHeight + lineGap); y < canvasHeight; y += lineHeight + lineGap) {
        ctx.fillRect(canvasWidth / 2 - lineWidth / 2, y, lineWidth, lineHeight);
      }
    }

    let lastTime = 0;  // 上一帧时间

    // 游戏主循环
    function gameLoop(timestamp) {
      updateFPS(); // 更新 FPS 显示
      const deltaTime = timestamp - lastTime;  // 计算帧间隔
      lastTime = timestamp;

      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      drawRoad(deltaTime); // 绘制道路

      // 将所有“游戏进行中”的逻辑（包括对象更新和清理）都放在这个代码块里
      if (gameState === 'playing') {
        const gameTime = timestamp - gameStartTime; // 计算游戏时间
        // 更新所有游戏对象
        bullets.forEach(bullet => bullet.update(deltaTime));
        bears.forEach(bear => bear.update(deltaTime));
        powerUps.forEach(powerUp => powerUp.update(deltaTime));
        healthPacks.forEach(healthPack => healthPack.update(deltaTime));
        bossBullets.forEach(bullet => bullet.update(deltaTime));
        if (boss) {
          boss.update(deltaTime, gameTime);
        }
        if (player) {
          // 更新玩家角色所在位置
          updatePlayerPosition(deltaTime);
          player.updateDefeatCharacters(deltaTime);
        }
        // 持续射击逻辑
        if (isShooting) {
          shootTimer += deltaTime;
          if (shootTimer >= shootInterval) {
            player.shoot();
            shootTimer = 0;
          }
        }
        // 小熊生成计时器
        bearSpawnTimer += deltaTime;
        if (bearSpawnTimer > bearInterval) {
          spawnBears();
          spawnPowerUps(); // 生成道具和血包
          bearSpawnTimer = 0;
        }
        if (!bossSpawned && gameTime > bossBegan) {
          boss = new Boss();
          bossSpawned = true;
        }
        // 更新玩家无敌状态
        if (playerInvulnerable) {
          invulnerabilityTimer -= deltaTime;
          if (invulnerabilityTimer <= 0) {
            playerInvulnerable = false;
          }
        }

        handleCollisions(); // 处理碰撞
        // 将子弹和小熊数组的清理操作移到这里
        // 这样当游戏不再是'playing'状态时，它们就不会被移除，从而被定格在屏幕上
        bullets = bullets.filter(b => !b.markedForDeletion);
        bears = bears.filter(b => !b.markedForDeletion);
        powerUps = powerUps.filter(p => !p.markedForDeletion);
        healthPacks = healthPacks.filter(h => !h.markedForDeletion);
        bossBullets = bossBullets.filter(b => !b.markedForDeletion);
      }

      // BOSS死亡时的连续爆炸效果 (这个逻辑保持在外，因为它在 'bossDying' 状态下运行)
      if (gameState === 'bossDying' && Math.random() < 0.8) {
        const x = bossDeathPosition.x + Math.random() * bossDeathPosition.width;
        const y = bossDeathPosition.y + Math.random() * bossDeathPosition.height;
        // explosions.push(new Explosion(x, y));
        // flashEffects.push(new FlashEffect(x, y, false));
      }

      // 更新并过滤特效 (特效的生命周期独立于游戏状态)
      flashEffects.forEach(flash => flash.update(deltaTime));
      explosions.forEach(exp => exp.update(deltaTime));
      flashEffects = flashEffects.filter(f => !f.isFinished());
      explosions = explosions.filter(e => !e.isFinished());

      // 绘制所有游戏对象 (绘制逻辑永远在主干上，确保所有状态都能正确显示)
      bullets.forEach(b => b.draw());
      bears.forEach(b => b.draw());
      powerUps.forEach(p => p.draw());
      healthPacks.forEach(h => h.draw());
      bossBullets.forEach(b => b.draw());
      if (boss) boss.draw();

      // 无敌状态下（被BOSS击中时）玩家角色闪烁，注释掉下面这一行就代表不闪烁
      //if (gameState == 'playing' && (!playerInvulnerable || Math.floor(invulnerabilityTimer / 100) % 2 === 0)) {
        player.draw(deltaTime);
      //}

      explosions.forEach(e => e.draw());
      flashEffects.forEach(f => f.draw());

      // 屏幕闪光效果
      if (screenFlashAlpha > 0) {
        ctx.fillStyle = `rgba(255, 255, 255, ${screenFlashAlpha})`;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        screenFlashAlpha -= 0.05;  // 逐渐淡化
      }
      // 绘制UI信息
      drawGameUI();
      // 继续下一帧（如果游戏未结束）
      if (gameState !== 'over') gameLoopId = requestAnimationFrame(gameLoop);
    }

    // 开始游戏
    function startGame() {
      init();  // 初始化游戏
      startScreen.classList.add('hidden');  // 隐藏开始界面
      resultScreen.classList.add('hidden');  // 隐藏结算界面

      // 显示游戏中的音乐控制按钮
      document.getElementById('game-music-control').style.display = 'flex';

      // 切换到战斗音乐（重新开始游戏时重置播放位置）
      if (battleMusic) {
        battleMusic.currentTime = 0;
        playMusic('battle');
      }

      lastTime = performance.now();  // 记录开始时间
      if (gameLoopId) cancelAnimationFrame(gameLoopId);  // 取消上一个游戏循环
      gameLoop(lastTime);  // 开始游戏循环
    }

    // 回到首页
    function backToHome() {
      init();
      gameState = 'over';  // 设置游戏状态为结束
      if (gameLoopId) cancelAnimationFrame(gameLoopId);  // 停止游戏循环

      // 隐藏游戏中的音乐控制按钮
      document.getElementById('game-music-control').style.display = 'none';
      // 切换到菜单音乐
      playMusic('menu');
      startScreen.classList.remove('hidden');  // 显示开始界面
      resultScreen.classList.add('hidden');  // 隐藏结算界面
    }

    // 绘制游戏UI
    function drawGameUI() {
      // 设置字体样式
      ctx.font = 'bold ' + uiFont + 'px "Arial Black", "Helvetica", sans-serif';
      ctx.fillStyle = '#ffffff';
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 2;
      //设置阴影
      // ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
      // ctx.shadowOffsetX = 1;
      // ctx.shadowOffsetY = 1;
      // ctx.shadowBlur = 4;

      // 绘制左上角生命值和音符子弹束信息
      const iconSize = 24;
      const noteSize = 16;
      ctx.textAlign = 'left';

      // 第一行：生命值（红心图标）- 显示当前生命值和失去生命值
      ctx.fillStyle = '#ff69b4'; // 粉色
      ctx.strokeText('❤️', 10, 62); // 红心emoji图标
      ctx.fillText('❤️', 10, 62);
      ctx.fillStyle = '#ffffff';// 恢复白色

      const currentHealthValue = currentLevel === 2 ? playerHealth : player.characterCount;
      let healthText = currentHealthValue.toString();
      // 只有失去生命后才显示横杠和失去生命值
      if (deathCount > 0) {
        healthText += '-' + deathCount.toString();
      }
      ctx.strokeText(healthText, 36 - uiAdjust, 62);
      ctx.fillText(healthText, 36 - uiAdjust, 62);

      // 第二行：音符和子弹束数量
      if (currentLevel === 2) {
        // 显示当前角色对应的音符图标
        const bulletImage = assetImages[`bullet${player.currentCharacterType}`];
        if (bulletImage) {
          ctx.drawImage(bulletImage, 10, 75, noteSize, noteSize * 1.5);
        }
        let bulletStr = playerBulletStreams.toString();
        if(playerBulletStreams == maxPlayerBulletStreams){
          bulletStr = bulletStr + " max!";
        }
        ctx.strokeText(bulletStr, 36 - uiAdjust, 92);
        ctx.fillText(bulletStr, 36 - uiAdjust, 92);
      }

      // 绘制右上角积分图标和数字
      if (assetImages.scoreIcon) {
        ctx.drawImage(assetImages.scoreIcon, canvasWidth - 40, 45, iconSize, iconSize);

        ctx.textAlign = 'right';
        // 显示格式：击杀数-逃走数（如果有逃走小熊）
        const scoreText = escapedBearCount > 0 ? `${bearKillCount}-${escapedBearCount}` : bearKillCount.toString();
        ctx.strokeText(scoreText, canvasWidth - 55, 62);
        ctx.fillText(scoreText, canvasWidth - 55, 62);

        // 绘制combo数（第二行）
        ctx.drawImage(assetImages.comboIcon, canvasWidth - 52, 75, 50, 22);
        ctx.strokeText(comboCount.toString(), canvasWidth - 55, 92);
        ctx.fillText(comboCount.toString(), canvasWidth - 55, 92);
      }

      // 绘制游戏时间和难度模式（游戏中和结束时都显示）
      if (gameState === 'playing' || gameState === 'bossDying') {
        const barWidth = canvasWidth * 0.6;
        const barX = canvasWidth / 2 - barWidth / 2;
        ctx.font = 'bold ' + uiFont + ' "Arial", sans-serif';
        // 游戏时间（血条位置左侧）
        const gameTime = performance.now() - gameStartTime;
        const timeText = formatGameTime(gameTime);
        ctx.textAlign = 'right';
        ctx.strokeText(timeText, barX - 30, 25);
        ctx.fillText(timeText, barX - 30, 25);

        // 等级和难度（血条位置右侧）
        const texts = languages[currentLang];
        // const modeText = 'Lv.' + currentLevel + ' ' + texts[currentDifficulty].replace(texts.mode, '');
        const modeText = texts[currentDifficulty].replace(texts.mode, '');
        ctx.textAlign = 'left';
        ctx.strokeText(modeText, barX + barWidth + 15, 25);
        ctx.fillText(modeText, barX + barWidth + 15, 25);
      }

      // 清除阴影效果
      //ctx.shadowColor = 'transparent';
      // ctx.shadowOffsetX = 0;
      // ctx.shadowOffsetY = 0;
      // ctx.shadowBlur = 0;
    }

    // 格式化游戏时间
    function formatGameTime(milliseconds) {
      const totalSeconds = Math.floor(milliseconds / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function roundTo2(num) {
      return Math.round((num * 100 + Number.EPSILON) * 100) / 100;
    }

    // 游戏结束
    function gameOver(isWin) {
      //避免重复执行
      if (gameState == 'over') {
        return;
      }
      gameState = 'over';  // 设置游戏状态为结束
      // 切换到结束音乐
      playMusic('end');
      cancelAnimationFrame(gameLoopId);  // 停止游戏循环
      const gameTime = performance.now() - gameStartTime;
      // 隐藏游戏中的音乐控制按钮
      // document.getElementById('game-music-control').style.display = 'none';

      // 计算最终得分
      const killScore = Math.max(0, (bearKillCount - escapedBearCount) * 20);
      const comboScore = maxComboCount * 20;
      const deathPenalty = currentDifficulty === 'endless' ? deathCount * 10 : deathCount * 50;
      const fullComboScore = (isWin && (maxComboCount == bearKillCount)) ? maxComboCount * 10 : 1;
      const bossScore = boss ? (boss.maxHealth - boss.health) * 5 : 0;
      const bearRatio = bearKillCount > 0 ? bearKillCount / (bearKillCount + escapedBearCount) : 0;
      const bossRatio = boss ? (boss.maxHealth - boss.health) / boss.maxHealth : 0;
      const playerRatio = currentLevel == 1 ? (player.characterCount / maxPlayerCharacter) : (playerBulletStreams / maxPlayerBulletStreams);
      const playerRatioScore = isWin ? playerRatio * 50 : playerRatio * 4;
      const bulletRatio = destroyedBulletCount > 0 ? destroyedBulletCount / (destroyedBulletCount + escapedBulletCount) : 0;
      const bulletRatioScore = isWin ? bulletRatio * 1000 : bulletRatio * 20;
      const itemRatio = collectedItemCount > 0 ? collectedItemCount / (collectedItemCount + escapedItemCount) : 0;
      const itemRatioScore = isWin ? itemRatio * 1000 : itemRatio * 5;
      const gameSeconds = Math.floor(gameTime / 1000);
      const timeScore = ((currentDifficulty === 'endless' && gameSeconds > 60) ? (gameSeconds - 60) * 50 : gameSeconds);
      const resultRank = getResultRank(bearRatio, bossRatio, deathCount, gameSeconds);
      const finalScore = Math.floor(Math.max(0, killScore + bossScore + comboScore - deathPenalty + fullComboScore
        + playerRatioScore + bulletRatioScore + itemRatioScore + timeScore));
      //发送游戏统计
      try {
        gameStat(getPlayerId(), currentLevel, currentDifficulty, fps, isWin ? 1 : 0, resultRank, gameSeconds, bearKillCount, escapedBearCount, maxComboCount, (currentLevel === 2 ? playerHealth : player.characterCount),
          deathCount, roundTo2(bossRatio), roundTo2(bulletRatio), roundTo2(itemRatio), finalScore);
      } catch (e) {
        //忽略报错
      }
      // 显示结算动画
      showScoreAnimation(isWin, killScore, maxComboCount, finalScore, gameTime, bearRatio, deathCount, resultRank);
    }

    // 结算动画函数
    function showScoreAnimation(isWin, killScore, maxComboCount, finalScore, gameTime, bearRatio, deathCount, resultRank) {
      const texts = languages[currentLang];
      // 显示结算界面
      resultScreen.classList.remove('hidden');
      // 获取DOM元素
      const diffEl = document.getElementById('result-diff');
      const timeEl = document.getElementById('result-time');
      const killEl = document.getElementById('result-kill');
      const comboTextEl = document.getElementById('result-combo-text');

      const totalEl = document.getElementById('result-total-text');
      const imageEl = document.getElementById('result-image');
      const messageEl = document.getElementById('result-message');
      const restartBtn = document.getElementById('restart-button');

      // 设置图片和消息
      if (isWin) {
        imageEl.src = assetImages.win.src;
        imageEl.alt = 'YOU WIN';
        messageEl.textContent = texts.winMessage;
        restartBtn.textContent = texts.playAgain;
      } else {
        imageEl.src = assetImages.defeat.src;
        imageEl.alt = 'DEFEAT';
        messageEl.textContent = texts.defeatMessage;
        restartBtn.textContent = texts.retry;
      }

      // 回到首页按钮文本不变
      document.getElementById('home-button').textContent = texts.backToHome;

      // 设置固定内容
      diffEl.textContent = `${texts['level'+currentLevel]}: ${texts[currentDifficulty]}`;
      timeEl.textContent = `${texts.gameTime}: ${formatGameTime(gameTime)}`;
      //数字动态递增动画
      const animateLine = (targetValue, label, element, callback) => {
        const duration = 1000;
        const frameRate = 60;
        const totalFrames = (duration / 1000) * frameRate;
        let frame = 0;

        const animate = () => {
          frame++;
          const progress = frame / totalFrames;
          const easeProgress = 1 - Math.pow(1 - progress, 3);
          const currentValue = Math.floor(targetValue * easeProgress);
          element.textContent = `${label}:  ${currentValue}`;

          if (frame < totalFrames) {
            requestAnimationFrame(animate);
          } else {
            setTimeout(callback, 100);
          }
        };
        animate();
      };

      setTimeout(() => {
        animateLine(killScore, texts.killScore, killEl, () => {
          animateLine(maxComboCount, texts.maxCombo, comboTextEl, () => {
            // maxCombo数值显示完毕后，根据fullComboScore决定是否显示fullcombo图片
            if (bearRatio === 1) {
              document.getElementById('result-fullcombo').style.display = 'block';
            }
            animateLine(finalScore, texts.totalScore, totalEl, () => {
              if(resultRank){
                let rankImg = document.getElementById('result-rank');
                // 给HTML图片赋值src（结算界面的图片在showScoreAnimation中动态设置）
                rankImg.style.display = 'block';
                rankImg.src = IMG_PATH + assets['rank_' + resultRank];
              }
            });
          });
        });
      }, 100);
    }

    function getResultRank(bearRatio, bossRatio, deathCount, gameSeconds) {
      if(currentDifficulty === 'endless') {
        if(gameSeconds < 30){
          return "d";
        }else if(gameSeconds < 60){
          return "c";
        }else if(gameSeconds < 90){
          return "cp";
        }else if(gameSeconds < 120){
          return "b";
        }else if(gameSeconds < 180){
          return "bp";
        }else if(gameSeconds < 240){
          return "a";
        }else if(gameSeconds < 300){
          return "ap";
        }else if(gameSeconds < 450){
          return "s";
        }else if(gameSeconds < 600){
          return "sp";
        }else if(gameSeconds < 900){
          return "ss";
        }else if(gameSeconds < 1800){
          return "ssp";
        }else {
          return "sss";
        }
      }
      let rank = '';
      if(bossRatio <= 0.1){
        rank = 'd';
      }else if (bossRatio <= 0.4){
        rank = 'c';
      }else if (bossRatio <= 0.6){
        rank = 'cp';
      }else if (bossRatio <= 0.8){
        rank = 'b';
      }else if (bossRatio < 1){
        rank = 'bp'
      }else{
        if(bearRatio <= 0.6){
          rank = 'a';
        }else if(bearRatio <= 0.8){
          rank = 'ap';
        }else if(bearRatio < 1){
          rank = 's';
        }else{
          if(currentLevel === 1) {
            if (deathCount >= 9) {
              rank = 'sp';
            }else if (deathCount >= 6) {
              rank = 'ss';
            } else if (deathCount >= 3) {
              rank = 'ssp';
            } else {
              rank = 'sss';
            }
          }else {
            if (deathCount >= 8) {
              rank = 'sp';
            }else if (deathCount >= 4) {
              rank = 'ss';
            } else if (deathCount >= 1) {
              rank = 'ssp';
            } else {
              rank = 'sss';
            }
          }
        }
      }
      return rank;
    }

    // 调整画布尺寸
    function resizeCanvas() {
      const rect = container.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      canvasWidth = canvas.width;
      canvasHeight = canvas.height;
      if (player) {
        player.width = canvasWidth / 7;
        player.height = player.width * 1.2;
      }
      if (canvasWidth <= 390) {
        uiFont = 12;
        uiAdjust = 5;
      } else if (canvasWidth <= 450) {
        uiFont = 14;
        uiAdjust = 2;
      }
    }

    window.addEventListener('resize', resizeCanvas);  // 监听窗口大小变化

    // 定义一个目标位置的全局变量，方便玩家角色位置更新函数里使用
    let targetPos = {x: player ? player.x : 0, y: player ? player.y : 0};

    // 获取鼠标位置
    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
      return {x: evt.clientX - rect.left, y: evt.clientY - rect.top};
    }

    // 获取触摸位置
    function getTouchPos(evt) {
      const rect = canvas.getBoundingClientRect();
      return {x: evt.touches[0].clientX - rect.left, y: evt.touches[0].clientY - rect.top};
    }

    // 鼠标按下或触摸开始 开始射击
    function handleInputStart(x, y) {
      isShooting = true;
      shootTimer = shootInterval; // 立即射击第一发

    }

    // 鼠标移动或触摸滑动 角色目标位置更新
    function handleInputMove(x, y) {
      targetPos.x = x;
      targetPos.y = y;
    }

    // 鼠标松开/离开或触摸结束 停止射击
    function handleInputEnd() {
      isShooting = false;
      shootTimer = 0;
    }

    // 玩家位置更新函数
    function updatePlayerPosition(deltaTime) {
      // 下面代码的作用是让玩家角色平滑移动，从而修复移动端点击任意位置会瞬移过去，不会接触到移动路线上任何物体的bug
      // speed数值越大，角色移动越接近真实的随鼠标移动/移动端瞬移，speed数值越小，角色移动的滞后性越大
      const speed = 2400;
      const dx = targetPos.x - player.x;
      const dy = targetPos.y - player.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance > 1) {
        const moveDist = Math.min(speed * deltaTime / 1000, distance); // 注意 deltaTime 单位 ms
        player.x += dx / distance * moveDist;
        player.y += dy / distance * moveDist;
      }

      // 下面三行代码作用是避免角色移动位置超出边界
      const totalWidth = player.width * player.characterCount;
      player.x = Math.max(totalWidth / 2, Math.min(canvasWidth - totalWidth / 2, player.x));
      player.y = Math.max(0, Math.min(canvasHeight - player.height, player.y));
    }

    // 鼠标按下
    container.addEventListener('mousedown', e => {
      const pos = getMousePos(e);
      handleInputStart(pos.x, pos.y);
    });

    //鼠标移动
    container.addEventListener('mousemove', e => {
      const pos = getMousePos(e);
      handleInputMove(pos.x, pos.y);
    });

    //鼠标松开按钮
    container.addEventListener('mouseup', handleInputEnd);

    // 如果希望鼠标移到画布范围以外依然保持射击，就注释下面这行
    // container.addEventListener('mouseleave', handleInputEnd);

    // 触摸开始 （手指首次触碰屏幕）
    container.addEventListener('touchstart', e => {
      // 阻止在按钮等UI元素上的默认行为
      if (e.target.tagName !== 'CANVAS') return;
      e.preventDefault();
      const pos = getTouchPos(e);
      handleInputStart(pos.x, pos.y);
    }, {passive: false});

    // 触摸移动 （手指在屏幕上滑动时连续触发）
    container.addEventListener('touchmove', e => {
      if (e.target.tagName !== 'CANVAS') return;
      e.preventDefault();
      const pos = getTouchPos(e);
      handleInputMove(pos.x, pos.y);
    }, {passive: false});

    // 触摸结束 (手指离开屏幕时触发)
    container.addEventListener('touchend', e => {
      if (e.target.tagName !== 'CANVAS') return;
      e.preventDefault();
      handleInputEnd();
    }, {passive: false});

    // 触摸取消 (系统取消触控，例如来电弹窗出现)
    container.addEventListener('touchcancel', e => {
      if (e.target.tagName !== 'CANVAS') return;
      e.preventDefault();
      handleInputEnd();
    }, {passive: false});


    // 屏幕震动效果函数
    function triggerScreenShake(intensity) {
      container.style.animation = `shake ${0.3}s`;  // 设置震动动画

      // 定义震动关键帧
      const keyframes = `@keyframes shake {
            10%, 90% { transform: translate3d(${-intensity / 4}px, 0, 0); }
            20%, 80% { transform: translate3d(${intensity / 2}px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(${-intensity}px, 0, 0); }
            40%, 60% { transform: translate3d(${intensity}px, 0, 0); }
        }`;

      // 使用动态样式表避免重复添加关键帧
      if (!document.getElementById('shake-style')) {
        const style = document.createElement('style');
        style.id = 'shake-style';
        document.head.appendChild(style);
      }
      document.getElementById('shake-style').innerHTML = keyframes;

      // 0.2秒后清除震动效果
      setTimeout(() => container.style.animation = '', 200);
    }

    document.addEventListener('DOMContentLoaded', () => {
      //发送请求
      sendStat();
      // 设置首页图片
      setIndexImage();
      // 创建音乐
      createMusic();
      // 初始化语言
      setLanguage();
      initFPS();
      // 初始化排行榜
      initLeaderboard();
      // 图片资源
      loadData();
      // 画布尺寸
      resizeCanvas();
    });
  })();
</script>

</body>
</html>
